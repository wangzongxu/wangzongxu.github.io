<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wangzongxu&#39;s Blog</title>
  <subtitle>The top class of virtue is like water,which benefits all things without any demands for return.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wangzongxu.github.io/"/>
  <updated>2018-02-13T07:49:35.380Z</updated>
  <id>https://wangzongxu.github.io/</id>
  
  <author>
    <name>wangzongxu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>中庸</title>
    <link href="https://wangzongxu.github.io/2018/02/13/ZhongYong/"/>
    <id>https://wangzongxu.github.io/2018/02/13/ZhongYong/</id>
    <published>2018-02-13T07:49:35.380Z</published>
    <updated>2018-02-13T07:49:35.380Z</updated>
    
    <content type="html"><![CDATA[<p>喜怒哀乐之未发谓之中，发之皆中节谓之和。</p>
<a id="more"></a>
<blockquote>
<p>中庸之道的主题思想是教育人们自觉地进行自我修养、自我监督、自我教育、自我完善，把自己培养成为具有理想人格，达到至善、至仁、至诚、至道、至德、至圣、合外内之道的理想人物，共创“致中和，天地位焉，万物育焉”的“太平和合”境界。</p>
</blockquote>
<p><a href="https://wangzongxu.gitbooks.io/zhongyong/content/" target="_blank" rel="external">点击阅读</a><br><a href="https://wangzongxu.gitbooks.io/zhongyong/content/" target="_blank" rel="external">https://wangzongxu.gitbooks.io/zhongyong/content/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;喜怒哀乐之未发谓之中，发之皆中节谓之和。&lt;/p&gt;
    
    </summary>
    
      <category term="国学" scheme="https://wangzongxu.github.io/categories/%E5%9B%BD%E5%AD%A6/"/>
    
    
      <category term="电子书" scheme="https://wangzongxu.github.io/tags/%E7%94%B5%E5%AD%90%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>demo之canvas打砖块</title>
    <link href="https://wangzongxu.github.io/2017/09/21/hitBricks-canvas-demo/"/>
    <id>https://wangzongxu.github.io/2017/09/21/hitBricks-canvas-demo/</id>
    <published>2017-09-21T09:09:24.000Z</published>
    <updated>2017-09-21T09:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>一个canvas打砖块小游戏</p>
<a id="more"></a>
<blockquote>
<p>扫码查看：</p>
</blockquote>
<p><img width="200" alt="" align="center" src="https://wangzongxu.github.io/img-cache/blog/hitBricksCode.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个canvas打砖块小游戏&lt;/p&gt;
    
    </summary>
    
      <category term="canvas" scheme="https://wangzongxu.github.io/categories/canvas/"/>
    
    
      <category term="动画" scheme="https://wangzongxu.github.io/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>道德经</title>
    <link href="https://wangzongxu.github.io/2017/09/21/TaoTeChing/"/>
    <id>https://wangzongxu.github.io/2017/09/21/TaoTeChing/</id>
    <published>2017-09-21T09:09:24.000Z</published>
    <updated>2017-09-21T09:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>整理了一下道德经诸传本，加粗浅的字面解释；<br>道德经解释仁者见仁智者见智，需要有自己的理解，因为其中的玄妙不是能够用语言可以表达的，正所谓：道可道，非常道。<br><a id="more"></a><br><a href="https://wangzongxu.gitbooks.io/taoteching/content/" target="_blank" rel="external">点击阅读</a><br><a href="https://wangzongxu.gitbooks.io/taoteching/content/" target="_blank" rel="external">https://wangzongxu.gitbooks.io/taoteching/content/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整理了一下道德经诸传本，加粗浅的字面解释；&lt;br&gt;道德经解释仁者见仁智者见智，需要有自己的理解，因为其中的玄妙不是能够用语言可以表达的，正所谓：道可道，非常道。&lt;br&gt;
    
    </summary>
    
      <category term="国学" scheme="https://wangzongxu.github.io/categories/%E5%9B%BD%E5%AD%A6/"/>
    
    
      <category term="电子书" scheme="https://wangzongxu.github.io/tags/%E7%94%B5%E5%AD%90%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>Chrome配置跨域</title>
    <link href="https://wangzongxu.github.io/2017/09/21/chromeConf/"/>
    <id>https://wangzongxu.github.io/2017/09/21/chromeConf/</id>
    <published>2017-09-21T09:09:24.000Z</published>
    <updated>2017-09-21T09:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为前端码农在项目开发中时常需要和后台进行接口联调，如果是前后端分离的情况下，本地开发调试后台接口的话，涉及到跨域问题比较令人头疼，很多人不知道其实chrome可以配置这一点：<br><a id="more"></a></p>
<h3 id="Chrome配置跨域"><a href="#Chrome配置跨域" class="headerlink" title="Chrome配置跨域"></a>Chrome配置跨域</h3><ul>
<li><p>windows环境下：</p>
<ol>
<li>在任意位置新建一个Chrome快捷方式，</li>
<li>右键点击快捷方式并打开属性，</li>
<li>在属性弹窗的选项中找到目标选项，</li>
<li>在目标选项中添加禁用安全限制配置(注意空格开头)<br>–disable-web-security –user-data-dir=C:\MyChromeDevUserData</li>
<li>点击确定，然后打开这个快捷方式，发现搜索框下边有一黄条提示就成功了，接下来就可以试一下请求跨域的资源了。</li>
</ol>
</li>
<li><p>mac环境下：</p>
<ol>
<li>先将Chrome完全退出，</li>
<li>打开命令行，</li>
<li>输入open -a’Google Chrome’ –args –disable-web-security –user-data-dir=/Users/这里输入你的mac用户名/MyChromeDevUserData/</li>
<li>配置完成，尝试请求跨域资源。</li>
</ol>
</li>
</ul>
<h3 id="顺便整理一些chrome配置参数"><a href="#顺便整理一些chrome配置参数" class="headerlink" title="顺便整理一些chrome配置参数"></a>顺便整理一些chrome配置参数</h3><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>–purge-memory-button</td>
<td>在Chrome的任务管理器中增加内存清理功能</td>
</tr>
<tr>
<td>–allow-outdated-plugins</td>
<td>不停用过期的插件。</td>
</tr>
<tr>
<td>–allow-running-insecure-content</td>
<td>默认情况下，https 页面不允许从 http 链接引用 javascript/css/plug-ins。添加这一参数会放行这些内容。</td>
</tr>
<tr>
<td>–allow-scripting-gallery</td>
<td>允许拓展脚本在官方应用中心生效。默认情况下，出于安全因素考虑这些脚本都会被阻止。</td>
</tr>
<tr>
<td>–disable-popup-blocking</td>
<td>禁用弹出拦截</td>
</tr>
<tr>
<td>–disable-javascript</td>
<td>禁用JavaScript</td>
</tr>
<tr>
<td>–disable-java</td>
<td>禁用Java</td>
</tr>
<tr>
<td>–disable-plugins</td>
<td>禁用插件</td>
</tr>
<tr>
<td>–-disable-images</td>
<td>禁用图像</td>
</tr>
<tr>
<td>–disable-accelerated-video</td>
<td>停用 GPU 加速视频。</td>
</tr>
<tr>
<td>–disable-dart</td>
<td>停用 Dart。</td>
</tr>
<tr>
<td>–disable-desktop-notifications</td>
<td>禁用桌面通知，在 Windows 中桌面通知默认是启用的。</td>
</tr>
<tr>
<td>–disable-extensions</td>
<td>禁用拓展。</td>
</tr>
<tr>
<td>–disable-file-system</td>
<td>停用 FileSystem API。</td>
</tr>
<tr>
<td>–disable-preconnect</td>
<td>停用 TCP/IP 预连接。</td>
</tr>
<tr>
<td>–disable-remote-fonts</td>
<td>关闭远程字体支持。SVG 中字体不受此参数影响。</td>
</tr>
<tr>
<td>–disable-speech-input</td>
<td>停用语音输入。</td>
</tr>
<tr>
<td>–disable-web-security</td>
<td>不遵守同源策略。</td>
</tr>
<tr>
<td>–user-data-dir=（chrome资料路径</td>
<td>代表自定义指定Chrome的资料路径</td>
</tr>
<tr>
<td>–disk-cache-dir</td>
<td>将缓存设置在给定的路径。</td>
</tr>
<tr>
<td>–disk-cache-size</td>
<td>设置缓存大小上限，以字节为单位。</td>
</tr>
<tr>
<td>–dns-prefetch-disable</td>
<td>停用DNS预读。</td>
</tr>
<tr>
<td>–enable-print-preview</td>
<td>启用打印预览。</td>
</tr>
<tr>
<td>–extensions-update-frequency</td>
<td>设定拓展自动更新频率，以秒为单位。</td>
</tr>
<tr>
<td>–incognito</td>
<td>让浏览器直接以隐身模式启动。</td>
</tr>
<tr>
<td>–keep-alive-for-test</td>
<td>最后一个标签关闭后仍保持浏览器进程。（某种意义上可以提高热启动速度，不过你最好得有充足的内存）</td>
</tr>
<tr>
<td>–kiosk</td>
<td>启用kiosk模式。（一种类似于全屏的浏览模式）</td>
</tr>
<tr>
<td>–lang</td>
<td>使用指定的语言。</td>
</tr>
<tr>
<td>–no-displaying-insecure-content</td>
<td>默认情况下，https 页面允许从 http 链接引用图片/字体/框架。添加这一参数会阻止这些内容。</td>
</tr>
<tr>
<td>–no-first-run</td>
<td>跳过 Chromium 首次运行检查。</td>
</tr>
<tr>
<td>–no-referrers</td>
<td>不发送 Http-Referer 头。</td>
</tr>
<tr>
<td>–no-sandbox</td>
<td>彻底停用沙箱。</td>
</tr>
<tr>
<td>–no-startup-window</td>
<td>启动时不建立窗口。</td>
</tr>
<tr>
<td>–proxy-pac-url</td>
<td>使用给定 URL 的 pac 代理脚本。（也可以使用本地文件，如 –proxy-pac-url=”file:\\c:\proxy.pac”）</td>
</tr>
<tr>
<td>–proxy-server</td>
<td>使用给定的代理服务器，这个参数只对 http 和 https 有效。（例如 –proxy-server=127.0.0.1:8087 ）</td>
</tr>
<tr>
<td>–single-process</td>
<td>以单进程模式运行 Chromium。（启动时浏览器会给出不安全警告）</td>
</tr>
<tr>
<td>–start-maximized</td>
<td>启动时最大化。</td>
</tr>
<tr>
<td>–user-agent</td>
<td>使用给定的 User-Agent 字符串</td>
</tr>
<tr>
<td>–process-per-tab</td>
<td>每个分页使用单独进程</td>
</tr>
<tr>
<td>–process-per-site</td>
<td>每个站点使用单独进程</td>
</tr>
<tr>
<td>–in-process-plugins</td>
<td>插件不启用单独进程</td>
</tr>
<tr>
<td>–omnibox-popup-count=”num”</td>
<td>将网址列弹出的提示选单数量改为num个</td>
</tr>
<tr>
<td>–enable-vertical-tabs</td>
<td>调整chrome游览器标签存放在左边，非顶部</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为前端码农在项目开发中时常需要和后台进行接口联调，如果是前后端分离的情况下，本地开发调试后台接口的话，涉及到跨域问题比较令人头疼，很多人不知道其实chrome可以配置这一点：&lt;br&gt;
    
    </summary>
    
      <category term="chrome" scheme="https://wangzongxu.github.io/categories/chrome/"/>
    
    
      <category term="chrome" scheme="https://wangzongxu.github.io/tags/chrome/"/>
    
  </entry>
  
  <entry>
    <title>关于浏览器缓存</title>
    <link href="https://wangzongxu.github.io/2017/09/21/cache_control/"/>
    <id>https://wangzongxu.github.io/2017/09/21/cache_control/</id>
    <published>2017-09-21T09:09:24.000Z</published>
    <updated>2017-09-21T09:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器缓存，也就是客户端缓存，既是网页性能优化里面静态资源相关优化的一大利器，也是无数web开发人员在工作过程不可避免的一大问题，所以在产品开发的时候我们总是想办法避免缓存产生，而在产品发布之时又在想策略管理缓存提升网页的访问速度。了解浏览器的缓存命中原理，是开发web应用的基础。<br><a id="more"></a></p>
<h3 id="浏览器缓存基本介绍"><a href="#浏览器缓存基本介绍" class="headerlink" title="浏览器缓存基本介绍"></a>浏览器缓存基本介绍</h3><blockquote>
<p>它分为强缓存和协商缓存：</p>
</blockquote>
<ol>
<li><p>浏览器在加载资源时，先根据这个资源的一些http header判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。比如某个css文件，如果浏览器在加载它所在的网页时，这个css文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个css，连请求都不会发送到网页所在服务器；</p>
</li>
<li><p>当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些http header验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源；</p>
</li>
<li><p>强缓存与协商缓存的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。</p>
</li>
<li><p>当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。</p>
</li>
</ol>
<h3 id="强缓存原理"><a href="#强缓存原理" class="headerlink" title="强缓存原理"></a>强缓存原理</h3><ul>
<li><p>浏览器对某个资源的请求命中了强缓存时，返回的http状态为200，在chrome的开发者工具的network里面size会显示为from disk cache，比如天猫的首页里就有很多静态资源配置了强缓存，用network可以看到有不少请求就是从缓存中加载的：<br><img src="https://wangzongxu.github.io/img-cache/blog/强缓存原理配图1.png" alt="强缓存原理配图"></p>
</li>
<li><p>强缓存是利用Expires或者Cache-Control这两个http response header实现的，它们都用来表示资源在客户端缓存的有效期。</p>
</li>
<li><p>Expires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回，用GMT格式的字符串表示，如：Expires:Thu, 31 Dec 2037 23:55:55 GMT，它的缓存原理是：]</p>
<ol>
<li><p>1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Expires的header，如：<br><img src="https://wangzongxu.github.io/img-cache/blog/expires.png" alt="Expires"></p>
</li>
<li><p>浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来（所以缓存命中的请求返回的header并不是来自服务器，而是来自之前缓存的header）；</p>
</li>
<li><p>浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的Expires跟当前的请求时间比较，如果请求时间在Expires指定的时间之前，就能命中缓存，否则就不行。</p>
</li>
<li><p>如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header在重新加载的时候会被更新。</p>
</li>
</ol>
</li>
<li><p>Expires是较老的强缓存管理header，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。所以在http1.1的时候，提出了一个新的header，就是Cache-Control，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示，如：Cache-Control:max-age=315360000，它的缓存原理是：</p>
<ol>
<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Cache-Control的header，如<br><img src="https://wangzongxu.github.io/img-cache/blog/cache-control.png" alt="Cache-Control"></li>
<li><p>浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来；</p>
</li>
<li><p>浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。</p>
</li>
<li><p>如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header在重新加载的时候会被更新。</p>
</li>
</ol>
</li>
<li><p>Cache-Control描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较Expires，Cache-Control的缓存管理更有效，安全一些。</p>
</li>
<li><p>这两个header可以只启用一个，也可以同时启用，当response header中，Expires和Cache-Control同时存在时，Cache-Control优先级高于Expires。<br><img src="https://wangzongxu.github.io/img-cache/blog/expires-and-control.png" alt="expires-and-control"></p>
</li>
</ul>
<h3 id="强缓存的管理"><a href="#强缓存的管理" class="headerlink" title="强缓存的管理"></a>强缓存的管理</h3><ul>
<li><p>前面介绍的是强缓存的原理，在实际应用中我们会碰到需要强缓存的场景和不需要强缓存的场景，通常有2种方式来设置是否启用强缓存：</p>
<ol>
<li><p>通过代码的方式，在web服务器返回的响应中添加Expires和Cache-Control Header；</p>
</li>
<li><p>通过配置web服务器的方式，让web服务器在响应资源的时候统一添加Expires和Cache-Control Header。</p>
</li>
</ol>
</li>
<li><p>比如在javaweb里面，我们可以使用类似下面的代码设置强缓存：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.util.Date date = <span class="keyword">new</span> java.util.Date();    </span><br><span class="line">response.setDateHeader(<span class="string">"Expires"</span>,date.getTime()+<span class="number">20000</span>); <span class="comment">//Expires:过时期限值</span></span><br><span class="line">response.setHeader(<span class="string">"Cache-Control"</span>, <span class="string">"public"</span>); <span class="comment">//Cache-Control来控制页面的缓存与否,public:浏览器和缓存服务器都可以缓存页面信息；</span></span><br><span class="line">response.setHeader(<span class="string">"Pragma"</span>, <span class="string">"Pragma"</span>); <span class="comment">//Pragma:设置页面是否缓存，为Pragma则缓存，no-cache则不缓存</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以通过类似下面的java代码设置不启用强缓存：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader( <span class="string">"Pragma"</span>, <span class="string">"no-cache"</span> );   </span><br><span class="line">response.setDateHeader(<span class="string">"Expires"</span>, <span class="number">0</span>);   </span><br><span class="line">response.addHeader( <span class="string">"Cache-Control"</span>, <span class="string">"no-cache"</span> );<span class="comment">//浏览器和缓存服务器都不应该缓存页面信息</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>tomcat还提供了一个ExpiresFilter专门用来配置强缓存，具体使用的方式可参考tomcat的官方文档：<a href="http://tomcat.apache.org/tomcat-7.0-doc/config/filter.html#Expires_Filter" target="_blank" rel="external">http://tomcat.apache.org/tomcat-7.0-doc/config/filter.html#Expires_Filter</a></p>
</blockquote>
<ul>
<li><p>nginx和apache作为专业的web服务器，都有专门的配置文件，可以配置expires和cache-control，这方面的知识，如果你对运维感兴趣的话，可以在百度上搜索“nginx 设置 expires cache-control”或“apache 设置 expires cache-control”都能找到不少相关的文章。</p>
</li>
<li><p>由于在开发的时候不会专门去配置强缓存，而浏览器又默认会缓存图片，css和js等静态资源，所以开发环境下经常会因为强缓存导致资源没有及时更新而看不到最新的效果，解决这个问题的方法有很多，常用的有以下几种：</p>
<ol>
<li><p>直接ctrl+f5，这个办法能解决页面直接引用的资源更新的问题；</p>
</li>
<li><p>使用浏览器的隐私模式开发；</p>
</li>
<li><p>如果用的是chrome，可以f12在network那里把缓存给禁掉（这是个非常有效的方法）：<br><img src="https://wangzongxu.github.io/img-cache/blog/disabled-cache.png" alt="disabled-cache"></p>
</li>
<li><p>在开发阶段，给资源加上一个动态的参数，如css/index.css?v=0.0001，由于每次资源的修改都要更新引用的位置，同时修改参数的值，所以操作起来不是很方便，除非你是在动态页面比如jsp里开发就可以用服务器变量来解决（v=${sysRnd}），或者你能用一些前端的构建工具来处理这个参数修改的问题；</p>
</li>
<li><p>如果资源引用的页面，被嵌入到了一个iframe里面，可以在iframe的区域右键单击重新加载该页面，以chrome为例：<br><img src="https://wangzongxu.github.io/img-cache/blog/重新加载框架.png" alt="重新加载框架"></p>
</li>
<li><p>如果缓存问题出现在ajax请求中，最有效的解决办法就是ajax的请求地址追加随机数；</p>
</li>
<li><p>还有一种情况就是动态设置iframe的src时，有可能也会因为缓存问题，导致看不到最新的效果，这时候在要设置的src后面添加随机数也能解决问题；</p>
</li>
<li><p>如果你用的是grunt和gulp这种前端工具开发，通过它们的插件比如grunt-contrib-connect来启动一个静态服务器，则完全不用担心开发阶段的资源更新问题，因为在这个静态服务器下的所有资源返回的respone header中，cache-control始终被设置为不缓存：<br><img src="https://wangzongxu.github.io/img-cache/blog/disabled-cache-control.png" alt="disabled-cache-control"></p>
</li>
</ol>
</li>
</ul>
<h3 id="强缓存的应用"><a href="#强缓存的应用" class="headerlink" title="强缓存的应用"></a>强缓存的应用</h3><ul>
<li><p>强缓存是前端性能优化最有力的工具，没有之一，对于有大量静态资源的网页，一定要利用强缓存，提高响应速度。通常的做法是，为这些静态资源全部配置一个超时时间超长的Expires或Cache-Control，这样用户在访问网页时，只会在第一次加载时从服务器请求静态资源，其它时候只要缓存没有失效并且用户没有强制刷新的条件下都会从自己的缓存中加载，比如前面提到过的京东首页缓存的资源，它的缓存过期时间都设置到了2026年：<br><img src="https://wangzongxu.github.io/img-cache/blog/cache-2026.png" alt="cache-2026"></p>
</li>
<li><p>然而这种缓存配置方式会带来一个新的问题，就是发布时资源更新的问题，比如某一张图片，在用户访问第一个版本的时候已经缓存到了用户的电脑上，当网站发布新版本，替换了这个图片时，已经访问过第一个版本的用户由于缓存的设置，导致在默认的情况下不会请求服务器最新的图片资源，除非他清掉或禁用缓存或者强制刷新，否则就看不到最新的图片效果。</p>
</li>
<li><p>这个问题已经有成熟的解决方案，具体内容可阅读知乎这篇文章详细了解：<a href="http://www.zhihu.com/question/20790576" target="_blank" rel="external">http://www.zhihu.com/question/20790576</a></p>
</li>
<li><p>文章提到的东西都属于理论上的解决方案，不过现在已经有很多前端工具能够实际地解决这个问题，由于每个工具涉及到的内容细节都有很多，本文没有办法一一深入介绍。有兴趣的可以去了解下grunt gulp webpack fis 还有edp这几个工具，基于这几个工具都能解决这个问题，尤其是fis和edp是百度推出的前端开发平台，有现成的文档可以参考：</p>
</li>
</ul>
<p><a href="http://fis.baidu.com/fis3/api/index.html" target="_blank" rel="external">http://fis.baidu.com/fis3/api/index.html</a>   </p>
<p><a href="http://ecomfe.github.io/edp/doc/initialization/install/" target="_blank" rel="external">http://ecomfe.github.io/edp/doc/initialization/install/</a></p>
<ul>
<li>强缓存还有一点需要注意的是，通常都是针对静态资源使用，动态资源需要慎用，除了服务端页面可以看作动态资源外，那些引用静态资源的html也可以看作是动态资源，如果这种html也被缓存，当这些html更新之后，可能就没有机制能够通知浏览器这些html有更新，尤其是前后端分离的应用里，页面都是纯html页面，每个访问地址可能都是直接访问html页面，这些页面通常不加强缓存，以保证浏览器访问这些页面时始终请求服务器最新的资源。</li>
</ul>
<h3 id="协商缓存的原理"><a href="#协商缓存的原理" class="headerlink" title="协商缓存的原理"></a>协商缓存的原理</h3><ul>
<li><p>当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串，比如你打开京东的首页，按f12打开开发者工具，再按f5刷新页面，查看network，可以看到有不少请求就是命中了协商缓存的<br><img src="https://wangzongxu.github.io/img-cache/blog/304.png" alt="304"></p>
</li>
<li><p>查看单个请求的Response Header，也能看到304的状态码和Not Modified的字符串，只要看到这个就可说明这个资源是命中了协商缓存，然后从客户端缓存中加载的，而不是服务器最新的资源：<br><img src="https://wangzongxu.github.io/img-cache/blog/304-detail.png" alt="304-detail"></p>
</li>
<li><p>协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的。</p>
</li>
<li><p>【Last-Modified，If-Modified-Since】的控制缓存的原理是：</p>
<ol>
<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间：<br><img src="https://wangzongxu.github.io/img-cache/blog/Last-Modified.png" alt="Last-Modified"></li>
<li>浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值：<br><img src="https://wangzongxu.github.io/img-cache/blog/If-Modified-Since.png" alt="If-Modified-Since"></li>
<li>服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header：<br><img src="https://wangzongxu.github.io/img-cache/blog/304res.png" alt="304res"></li>
<li><p>浏览器收到304的响应后，就会从缓存中加载资源。</p>
</li>
<li><p>如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值。</p>
</li>
</ol>
</li>
<li><p>【Last-Modified，If-Modified-Since】都是根据服务器时间返回的header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个header配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对header来管理协商缓存，这对header就是【ETag、If-None-Match】。它们的缓存管理的方式是：</p>
<ol>
<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题：<br><img src="https://wangzongxu.github.io/img-cache/blog/ETag.png" alt="ETag"></li>
<li>浏览器再次跟服务器请求这个资源时，在request的header上加上If-None-Match的header，这个header的值就是上一次请求时返回的ETag的值：<br><img src="https://wangzongxu.github.io/img-cache/blog/if-none-match.png" alt="if-none-match"></li>
<li>服务器再次收到资源请求时，根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化：<br><img src="https://wangzongxu.github.io/img-cache/blog/ETag.png" alt="ETag"></li>
<li>浏览器收到304的响应后，就会从缓存中加载资源。</li>
</ol>
</li>
</ul>
<h3 id="协商缓存的管理"><a href="#协商缓存的管理" class="headerlink" title="协商缓存的管理"></a>协商缓存的管理</h3><ul>
<li><p>协商缓存跟强缓存不一样，强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。大部分web服务器都默认开启协商缓存，而且是同时启用【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】，比如apache:<br><img src="https://wangzongxu.github.io/img-cache/blog/etagandlast.png" alt="etagandlast"></p>
</li>
<li><p>如果没有协商缓存，每个到服务器的请求，就都得返回资源内容，这样服务器的性能会极差。</p>
</li>
<li><p>【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】一般都是同时启用，这是为了处理Last-Modified不可靠的情况。有一种场景需要注意：</p>
</li>
<li><p>分布式系统里多台机器间文件的Last-Modified必须保持一致，以免负载均衡到不同机器导致比对失败；</p>
</li>
<li><p>分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样）；</p>
</li>
<li><p>京东页面的资源请求，返回的repsones header就只有Last-Modified，没有ETag：<br><img src="https://wangzongxu.github.io/img-cache/blog/only-lastmodify.png" alt="only-lastmodify"></p>
</li>
<li><p>协商缓存需要配合强缓存使用，你看前面这个截图中，除了Last-Modified这个header，还有强缓存的相关header，因为如果不启用强缓存的话，协商缓存根本没有意义。</p>
</li>
</ul>
<h3 id="浏览器行为对缓存的影响"><a href="#浏览器行为对缓存的影响" class="headerlink" title="浏览器行为对缓存的影响"></a>浏览器行为对缓存的影响</h3><ul>
<li><p>如果资源已经被浏览器缓存下来，在缓存失效之前，再次请求时，默认会先检查是否命中强缓存，如果强缓存命中则直接读取缓存，如果强缓存没有命中则发请求到服务器检查是否命中协商缓存，如果协商缓存命中，则告诉浏览器还是可以从缓存读取，否则才从服务器返回最新的资源。这是默认的处理方式，这个方式可能被浏览器的行为改变：</p>
<ol>
<li><p>当ctrl+f5强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；</p>
</li>
<li><p>当f5刷新网页时，跳过强缓存，但是会检查协商缓存；</p>
</li>
</ol>
</li>
<li><p>参考出处：<a href="http://www.cnblogs.com/lyzg/p/5125934.html" target="_blank" rel="external">http://www.cnblogs.com/lyzg/p/5125934.html</a></p>
</li>
</ul>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="https://wangzongxu.github.io/img-cache/blog/browser-cache.jpeg" alt="流程图"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浏览器缓存，也就是客户端缓存，既是网页性能优化里面静态资源相关优化的一大利器，也是无数web开发人员在工作过程不可避免的一大问题，所以在产品开发的时候我们总是想办法避免缓存产生，而在产品发布之时又在想策略管理缓存提升网页的访问速度。了解浏览器的缓存命中原理，是开发web应用的基础。&lt;br&gt;
    
    </summary>
    
      <category term="剪切板" scheme="https://wangzongxu.github.io/categories/%E5%89%AA%E5%88%87%E6%9D%BF/"/>
    
    
      <category term="浏览器缓存" scheme="https://wangzongxu.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>demo之canvas时钟</title>
    <link href="https://wangzongxu.github.io/2017/09/21/date-canvas-demo/"/>
    <id>https://wangzongxu.github.io/2017/09/21/date-canvas-demo/</id>
    <published>2017-09-21T09:09:24.000Z</published>
    <updated>2017-09-21T09:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>偶尔看到网上的动画挺漂亮，自己也来做一个收藏。</p>
<a id="more"></a>
<p><a href="https://wangzongxu.github.io/canvas-demo/time/">点击查看</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;偶尔看到网上的动画挺漂亮，自己也来做一个收藏。&lt;/p&gt;
    
    </summary>
    
      <category term="canvas" scheme="https://wangzongxu.github.io/categories/canvas/"/>
    
    
      <category term="动画" scheme="https://wangzongxu.github.io/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>常用Chrome扩展工具</title>
    <link href="https://wangzongxu.github.io/2017/09/21/chromeUtils/"/>
    <id>https://wangzongxu.github.io/2017/09/21/chromeUtils/</id>
    <published>2017-09-21T09:09:24.000Z</published>
    <updated>2017-09-21T09:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用chrome前端开发，就少不了一些扩展程序来提升开发和调试效率，在这里整理一下常用的开发工具：<br><a id="more"></a></p>
<h4 id="Axure-RP-Extension-for-Chrome"><a href="#Axure-RP-Extension-for-Chrome" class="headerlink" title="Axure RP Extension for Chrome"></a>Axure RP Extension for Chrome</h4><p>这个插件可以打开RP原型文件，本身chrome是不支持的。<br><img src="https://wangzongxu.github.io/img-cache/blog/axure.jpeg" width="300" alt="" align="center"></p>
<h4 id="JavaScript-and-CSS-Code-Beautifier"><a href="#JavaScript-and-CSS-Code-Beautifier" class="headerlink" title="JavaScript and CSS Code Beautifier"></a>JavaScript and CSS Code Beautifier</h4><p>用于查看js、css等源码时对其进行高亮、格式化、美化、压缩等操作.<br><img src="https://wangzongxu.github.io/img-cache/blog/beautifulCode.png" width="600" alt="" align="center"></p>
<h4 id="JSON-handle"><a href="#JSON-handle" class="headerlink" title="JSON-handle"></a>JSON-handle</h4><p>它是JSON文档的浏览器和编辑器，可以获得美丽的视图。<br><img src="https://wangzongxu.github.io/img-cache/blog/jsonHandle.png" width="600" alt="" align="center"></p>
<h4 id="Wappalyzer"><a href="#Wappalyzer" class="headerlink" title="Wappalyzer"></a>Wappalyzer</h4><p>可以知道浏览的网站所用的技术。<br><img src="https://wangzongxu.github.io/img-cache/blog/wappalyzer.png" width="300" alt="" align="center"></p>
<h4 id="whistle"><a href="#whistle" class="headerlink" title="whistle"></a>whistle</h4><p>whistle是一款用Node实现的跨平台的Web调试代理工具，支持查看修改http(s)、Websocket连接的请求和响应内容。<a href="https://avwo.github.io/whistle/" target="_blank" rel="external">官方中文教程</a><br><img src="https://wangzongxu.github.io/img-cache/blog/whistle1.png" width="200" alt="" align="center"><br><img src="https://wangzongxu.github.io/img-cache/blog/whistle2.png" width="600" alt="" align="center"><br><img src="https://wangzongxu.github.io/img-cache/blog/whistle3.png" width="600" alt="" align="center"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用chrome前端开发，就少不了一些扩展程序来提升开发和调试效率，在这里整理一下常用的开发工具：&lt;br&gt;
    
    </summary>
    
      <category term="chrome" scheme="https://wangzongxu.github.io/categories/chrome/"/>
    
    
      <category term="chrome" scheme="https://wangzongxu.github.io/tags/chrome/"/>
    
  </entry>
  
  <entry>
    <title>console.log打印漂亮的日志</title>
    <link href="https://wangzongxu.github.io/2017/09/21/console/"/>
    <id>https://wangzongxu.github.io/2017/09/21/console/</id>
    <published>2017-09-21T09:09:24.000Z</published>
    <updated>2017-09-21T09:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>打开百度、天猫控制台，你都会发现漂亮的图案，是怎么做的呢？<br><a id="more"></a></p>
<h4 id="了解console方法"><a href="#了解console方法" class="headerlink" title="了解console方法"></a>了解console方法</h4><p>我们都知道console.log可以打印多个参数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>)</span><br></pre></td></tr></table></figure></p>
<h4 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h4><p>在console.log输出的字符串中可以加入以下占位符，不同格式的数据必须使用对应格式的占位符，我们只需用到’%c’，其他的就暂且不谈；</p>
<blockquote>
<p>%s 字符串<br>%d 整数<br>%i 整数<br>%f 浮点数<br>%o 对象的链接<br>%c CSS格式字符串</p>
</blockquote>
<h4 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h4><ul>
<li>如果第一个参数是格式字符串（使用了格式占位符），console.log方法将依次用后面的参数替换占位符，然后再进行输出，使用很简单：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'%cABC'</span>,<span class="string">'color:red'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="https://wangzongxu.github.io/img-cache/console/console1.png" width="300" alt="" align="center"><br>在控制台查看效果，我们发现ABC变成了红色：%c对应第二个参数，这个参数是css字符串，可以包含多个属性，以分号隔开：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'%cABC'</span>,<span class="string">'color:red;font-size:30px'</span>)</span><br></pre></td></tr></table></figure></p>
<p><img src="https://wangzongxu.github.io/img-cache/console/console2.png" width="400" alt="" align="center"><br>此时我们发现字体变大了。</p>
<p>如果你想让‘ABC’有更多的风格，我们只需再加上几个’%c’和对应的参数即可：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'%cA%cB%cC'</span>,<span class="string">'color:red'</span>,<span class="string">'color:blue'</span>,<span class="string">'color:green'</span>)</span><br></pre></td></tr></table></figure></p>
<p><img src="https://wangzongxu.github.io/img-cache/console/console3.png" width="600" alt="" align="center"><br>每一个%c，只对从他后边的字符开始至下一个%c之前的位置起作用，第一个%c到第三个%c的样式，分别对应从第二个参数开始的’color:red’,’color:blue’,’color:green’，如果你想要更多的颜色，可以添加更多占位符。</p>
<h4 id="制作图案"><a href="#制作图案" class="headerlink" title="制作图案"></a>制作图案</h4><p>这里以我平时使用图案的为例来看一下简单的制作过程：<br><img src="https://wangzongxu.github.io/img-cache/webchalk/webchalk.png" width="500" alt="" align="center"></p>
<ol>
<li><p>首先第一步比较重要，也是不容易的，因为需要排版，把组成图案的每一个字符对应准确<br><img src="https://wangzongxu.github.io/img-cache/console/console4.png" width="500" alt="" align="center"><br>这里我先声明一个准备输出的字符串图案，使用的单个字符是一个方块，大家也可以去网上找更多好看的字符尝试，记得在换行的位置加’\n’和该行结束位置的’\’，这个我就不多说了，拼接过字符串的童鞋都知道，当然，如果你使用ES6的模板字符串就不必考虑这么多了。</p>
</li>
<li><p>添加占位符<br><img src="https://wangzongxu.github.io/img-cache/console/console5.png" width="500" alt="" align="center"><br>我们在每个需要更换颜色的开始位置增加了占位符，虽然看起来字符已经错位，但是并不影响正常输出。</p>
</li>
<li><p>注意占位符的数量和顺序，编写console的样式参数并输出：<br><img src="https://wangzongxu.github.io/img-cache/console/console6.png" width="300" alt="" align="center"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>其实非常简单，不过比较头疼的地方就是要选择插入占位符的位置和对准占位符和参数的位置，<br>不过推荐大家一款个人插件:web-chalk</p>
</li>
</ol>
<h4 id="webchalk"><a href="#webchalk" class="headerlink" title="webchalk"></a>webchalk</h4><p><a href="https://github.com/wangzongxu/web-chalk.git" target="_blank" rel="external">web-chalk</a>使用这款插件可以像html一样定义css样式，用法非常简单，不必为上述问题而头疼，链接里有用法简介。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;打开百度、天猫控制台，你都会发现漂亮的图案，是怎么做的呢？&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="https://wangzongxu.github.io/categories/JS/"/>
    
    
      <category term="JS" scheme="https://wangzongxu.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>esLint入门</title>
    <link href="https://wangzongxu.github.io/2017/09/21/esLint/"/>
    <id>https://wangzongxu.github.io/2017/09/21/esLint/</id>
    <published>2017-09-21T09:09:24.000Z</published>
    <updated>2017-09-21T09:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="esLint入门"><a href="#esLint入门" class="headerlink" title="esLint入门"></a>esLint入门</h3><p>ESLint是用于识别和报告ECMAScript / JavaScript代码书写风格的工具，目的是使代码更加一致并避免错误。 在许多方面，它与JSLint和JSHint类似，但有一些例外：<br><a id="more"></a><br>这里只介绍基本使用各规则，详细可去<a href="http://eslint.org/" target="_blank" rel="external">官方文档</a><br><img src="http://eslint.org/img/logo.svg" width="200" alt="" align="center"></p>
<ul>
<li>ESLint使用<a href="https://github.com/eslint/espree" target="_blank" rel="external">Espree</a>进行JavaScript解析。</li>
<li>ESLint使用AST来评估代码中的模式。</li>
<li>ESLint配置灵活，每个规则都是一个插件，您可以在运行时添加更多。</li>
</ul>
<h4 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h4><p>有两种方法来安装ESLint：全局和本地。</p>
<h5 id="本地安装和使用"><a href="#本地安装和使用" class="headerlink" title="本地安装和使用"></a>本地安装和使用</h5><p>如果要将ESLint作为项目构建系统的一部分，我们建议您在本地进行安装。 你可以使用npm：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install eslint --save-dev</span><br></pre></td></tr></table></figure>
<p>然后应该初始化一个配置文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./node_modules/.bin/eslint --init</span><br></pre></td></tr></table></figure>
<p>之后，您可以在任何文件或目录下运行ESLint，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./node_modules/.bin/eslint yourFile.js</span><br></pre></td></tr></table></figure>
<p>您使用的任何插件或可共享配置也必须在本地安装以与本地安装的ESLint配合使用。</p>
<h5 id="全局安装和使用"><a href="#全局安装和使用" class="headerlink" title="全局安装和使用"></a>全局安装和使用</h5><p>安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g eslint</span><br></pre></td></tr></table></figure>
<p>初始化</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eslint --init</span><br></pre></td></tr></table></figure>
<p>运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eslint yourFile.js</span><br></pre></td></tr></table></figure>
<blockquote>
<p>eslint –init只在根据每个项目设置和配置ESLint，并将ESLint及其插件的本地安装运行在运行的目录中。 如果您希望使用ESLint的全局安装，则配置中使用的任何插件也必须全局安装。</p>
</blockquote>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><blockquote>
<p>如果你是1.0.0之前的版本，请参阅 <a href="http://eslint.org/docs/user-guide/migrating-to-1.0.0" target="_blank" rel="external">migration guide</a>.</p>
</blockquote>
<p>运行eslint –init后，您的目录中将有一个.eslintrc文件。 在其中，您将看到一些如下配置的规则:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"rules"</span>: &#123;</span><br><span class="line">        <span class="attr">"semi"</span>: [<span class="string">"error"</span>, <span class="string">"always"</span>],</span><br><span class="line">        <span class="attr">"quotes"</span>: [<span class="string">"error"</span>, <span class="string">"double"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>属性名“semi”和“quotes”是ESLint中规则的名称。 数组的第一个值是规则的错误级别，可以是以下值之一：</p>
<ul>
<li>“off” 或 0 是关闭规则</li>
<li>“warn” 或 1 将规则作为警告（不影响退出代码）</li>
<li>“error” 或 2 将规则作为错误（退出代码）</li>
</ul>
<p>这三个错误级别允许您细分控制ESLint应用规则（有关更多配置选项和详细信息，请参阅<a href="http://eslint.org/docs/user-guide/configuring" target="_blank" rel="external">配置文档</a>）。</p>
<p>你的 .eslintrc 配置文件将会包含下列选项：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"extends": "eslint:recommended"</span><br></pre></td></tr></table></figure></p>
<p>由于这一行，规则页面上标记为“yes”的所有规则将被打开。 或者，您可以通过在npmjs.com上搜索“eslint-config”来使用其他人创建的配置，例如<a href="https://github.com/sivan/javascript-style-guide/blob/master/es5/README.md" target="_blank" rel="external">Airbnb JavaScript Style Guide</a>、<a href="https://github.com/feross/standard/blob/master/docs/README-zhtw.md" target="_blank" rel="external">standard</a>。 ESLint不会删除您的代码，除非您从共享配置中扩展或在配置中明确地打开规则。</p>
<h3 id="规则-rules"><a href="#规则-rules" class="headerlink" title="规则:rules"></a>规则:rules</h3><p>ESLint中的规则按类别分组，以帮助您了解其目的。</p>
<blockquote>
<p>默认情况下不启用任何规则。 配置文件中的“extends”：“eslint：recommended”属性可以启用报告常见问题的规则，下面有一个为 “yes” 的复选标记。</p>
</blockquote>
<p>命令行加上–fix选项会自动修复下面有扳手 “fix” 的规则报告的问题（目前大部分为空格）。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eslint yourFile.js --fix</span><br></pre></td></tr></table></figure></p>
<h4 id="可能导致的错误"><a href="#可能导致的错误" class="headerlink" title="可能导致的错误"></a>可能导致的错误</h4><p>这些规则与JavaScript代码中可能的语法或逻辑错误有关：</p>
<table>
<thead>
<tr>
<th>eslint:recommended</th>
<th>可被修复</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>x</td>
<td>no-await-in-loop</td>
<td>不允许在循环内使用await</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-compare-neg-zero</td>
<td>不允许与-0比较</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-cond-assign</td>
<td>在条件表达式中禁止使用赋值运算符</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-console</td>
<td>禁止使用console</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-constant-condition</td>
<td>禁止条件下的常量表达式</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-control-regex</td>
<td>禁止正则表达式中的控制字符 ：new RegExp(“\x1f”)</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-debugger</td>
<td>禁止使用debugger</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-dupe-args</td>
<td>禁止函数中定义重复参数</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-dupe-keys</td>
<td>禁止在对象中有重复的属性名</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-duplicate-case</td>
<td>禁止重复的case标签</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-empty</td>
<td>禁止空语句块</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-empty-character-class</td>
<td>禁止在正则表达式中使用空字符集 (/^abc[]/)</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-ex-assign</td>
<td>禁止对 catch 子句的参数重新赋值</td>
</tr>
<tr>
<td>yes</td>
<td>fix</td>
<td>no-extra-boolean-cast</td>
<td>禁止不必要的布尔转换</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>no-extra-parens</td>
<td>禁止不必要的括号 (a * b) + c</td>
</tr>
<tr>
<td>yes</td>
<td>fix</td>
<td>no-extra-semi</td>
<td>禁止不必要的分号</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-func-assign</td>
<td>禁止对 function 声明重新赋值</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-inner-declarations</td>
<td>禁止在嵌套的块中出现 function 或 var 声明</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-invalid-regexp</td>
<td>禁止 RegExp 构造函数中无效的正则表达式字符串</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-irregular-whitespace</td>
<td>禁止在字符串和注释之外不规则的空白</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-obj-calls</td>
<td>禁止直接使用 Object.prototypes 的内置属性</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-prototype-builtins</td>
<td>禁止直接使用 Object.prototypes 的内置属性</td>
</tr>
<tr>
<td>yes</td>
<td>fix</td>
<td>no-regex-spaces</td>
<td>禁止正则表达式字面量中出现多个空格</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-sparse-arrays</td>
<td>禁用稀疏数组</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-template-curly-in-string</td>
<td>禁止常规字符串中使用的模板字符串语法</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-unexpected-multiline</td>
<td>禁止出现令人困惑的多行表达式</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-unreachable</td>
<td>禁止在return、throw、continue 和 break语句之后出现不可达代码</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-unsafe-finally</td>
<td>禁止在finally代码块中使用控制流语句</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>no-unsafe-negation</td>
<td>不允许否定关系运算符左边的操作数</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>use-isnan</td>
<td>要求使用 isNaN() 检查 NaN</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>valid-jsdoc</td>
<td>强制使用有效的 JSDoc 注释</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>valid-typeof</td>
<td>强制 typeof 表达式与有效的字符串进行比较</td>
</tr>
</tbody>
</table>
<h4 id="最佳做法"><a href="#最佳做法" class="headerlink" title="最佳做法"></a>最佳做法</h4><p>这些规则涉及更好的方法来帮助您避免问题：</p>
<table>
<thead>
<tr>
<th>eslint:recommended</th>
<th>可被修复</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>x</td>
<td>accessor-pairs</td>
<td>在对象中强制使用getter和setter</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>array-callback-return</td>
<td>在数组方法的回调中使用返回语句</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>block-scoped-var</td>
<td>强制把变量的使用限制在其定义的作用域范围内</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>class-methods-use-this</td>
<td>强制将在的方法中利用“this”</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>complexity</td>
<td>强制执行一个程序允许的最大循环复杂度</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>curly</td>
<td>对所有控制语句使用一致的括号风格</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>default-case</td>
<td>switch 语句强制 default 分支，也可添加 // no default 注释取消此次警告</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>dot-location</td>
<td>在’.’之前和之后一致的换行符</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>dot-notation</td>
<td>强制使用.号取属性</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>eqeqeq</td>
<td>使用===、!==替代==、!=</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>guard-for-in</td>
<td>要求for-in循环包含一个if语句</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-alert</td>
<td>禁止使用alert，confirm和prompt</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-caller</td>
<td>不允许使用arguments.caller或arguments.callee</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-case-declarations</td>
<td>在case子句中禁止词法声明</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-div-regex</td>
<td>禁止除法操作符显式的出现在正则表达式开始的位置</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>no-else-return</td>
<td>禁止 if 语句中有 return 之后有 else</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-empty-function</td>
<td>禁止出现空函数.如果一个函数包含了一条注释，它将不会被认为有问题</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-empty-pattern</td>
<td>禁止使用空解构模式no-empty-pattern</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-eq-null</td>
<td>禁止在没有类型检查操作符的情况下与 null 进行比较</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-eval</td>
<td>禁用 eval()</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-extend-native</td>
<td>禁止扩展原生类型</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>no-extra-bind</td>
<td>禁止不必要的 .bind() 调用</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>no-extra-label</td>
<td>禁用不必要的标签</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-fallthrough</td>
<td>禁止 case 语句落空</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>no-floating-decimal</td>
<td>禁止数字字面量中使用前导和末尾小数点</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-global-assign</td>
<td>不允许对本地对象或只读全局变量分配</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>no-implicit-coercion</td>
<td>禁止使用短符号进行类型转换(!!fOO)</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-implied-eval</td>
<td>禁止使用类似 eval() 的方法</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-invalid-this</td>
<td>禁止 this 关键字出现在类和类对象之外</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-iterator</td>
<td>禁用 <strong>iterator</strong> 属性</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-labels</td>
<td>禁用标签语句</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-lone-blocks</td>
<td>禁用不必要的嵌套块</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-loop-func</td>
<td>禁止在循环中出现 function 声明和表达式</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-magic-numbers</td>
<td>禁用魔术数字(3.14什么的用常量代替)</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>no-multi-spaces</td>
<td>禁止使用多个空格</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-multi-str</td>
<td>禁止使用多行字符串，在 JavaScript 中，可以在新行之前使用斜线创建多行字符串</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-new</td>
<td>禁止在非赋值或条件语句中使用 new 操作符</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-new-func</td>
<td>禁止对 Function 对象使用 new 操作符</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-new-wrappers</td>
<td>禁止对 String，Number 和 Boolean 使用 new 操作符</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-octal</td>
<td>禁用八进制字面量</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-octal-escape</td>
<td>禁止在字符串中使用八进制转义序列</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-param-reassign</td>
<td>不允许对 function 的参数进行重新赋值</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-proto</td>
<td>禁用 <strong>proto</strong> 属性</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-redeclare</td>
<td>禁止使用 var 多次声明同一变量</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-restricted-properties</td>
<td>禁止某些对象上的某些属性</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-return-assign</td>
<td>禁用指定的通过 require 加载的模块</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-return-await</td>
<td>禁止不必要的return await</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-script-url</td>
<td>禁止使用 javascript: url</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-self-assign</td>
<td>禁止自我赋值</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-self-compare</td>
<td>禁止自身比较</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-sequences</td>
<td>禁用逗号操作符</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-throw-literal</td>
<td>禁止抛出非异常字面量</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-unmodified-loop-condition</td>
<td>禁用一成不变的循环条件</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-unused-expressions</td>
<td>禁止出现未使用过的表达式</td>
</tr>
<tr>
<td>yes</td>
<td>fix</td>
<td>no-unused-labels</td>
<td>禁用未使用过的标签</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-useless-call</td>
<td>禁止不必要的 .call() 和 .apply()</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-useless-concat</td>
<td>禁止不必要的字符串字面量或模板字面量的连接</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-useless-escape</td>
<td>禁用不必要的转义字符</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>no-useless-return</td>
<td>不允许冗余return语句</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-void</td>
<td>禁用 void 操作符</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-warning-comments</td>
<td>禁止在注释中使用特定的警告术语</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-with</td>
<td>禁用 with 语句</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>prefer-promise-reject-errors</td>
<td>要求将Error对象用作“Promise”拒绝原因</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>radix</td>
<td>强制在parseInt()使用基数参数</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>require-await</td>
<td>禁止async函数中没有await表达式</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>vars-on-top</td>
<td>要求所有的 var 声明出现在它们所在的作用域顶部</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>wrap-iife</td>
<td>要求 IIFE 使用括号括起来</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>yoda</td>
<td>要求或禁止 “Yoda” 条件</td>
</tr>
</tbody>
</table>
<h4 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h4><table>
<thead>
<tr>
<th>eslint:recommended</th>
<th>可被修复</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>fix</td>
<td>strict</td>
<td>要求或禁止使用严格模式指令</td>
</tr>
</tbody>
</table>
<h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><table>
<thead>
<tr>
<th>eslint:recommended</th>
<th>可被修复</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>x</td>
<td>init-declarations</td>
<td>要求或禁止 var 声明中的初始化(初值)</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-catch-shadow</td>
<td>不允许 catch 子句的参数与外层作用域中的变量同名</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-delete-var</td>
<td>禁止删除变量</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-restricted-globals</td>
<td>禁用特定的全局变量</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-shadow</td>
<td>禁止 var 声明 与外层作用域的变量同名</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-label-var</td>
<td>不允许标签与变量同名</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-shadow-restricted-names</td>
<td>禁止覆盖受限制的标识符</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-undef</td>
<td>禁用未声明的变量，除非它们在 /*global*/ 注释中被提到</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>no-undef-init</td>
<td>禁止将变量初始化为 undefined</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-undefined</td>
<td>禁止将 undefined 作为标识符</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-unused-vars</td>
<td>禁止出现未使用过的变量</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-use-before-define</td>
<td>不允许在变量定义之前使用它们</td>
</tr>
</tbody>
</table>
<h4 id="Node-js-and-CommonJS"><a href="#Node-js-and-CommonJS" class="headerlink" title="Node.js and CommonJS"></a>Node.js and CommonJS</h4><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>callback-return</td>
<td>回调后需要返回的语句</td>
</tr>
<tr>
<td>global-require</td>
<td>要求 require() 出现在顶层模块作用域中</td>
</tr>
<tr>
<td>handle-callback-err</td>
<td>要求回调函数中有容错处理</td>
</tr>
<tr>
<td>no-mixed-requires</td>
<td>禁止混合常规 var 声明和 require 调用</td>
</tr>
<tr>
<td>no-new-require</td>
<td>禁止调用 require 时使用 new 操作符</td>
</tr>
<tr>
<td>no-path-concat</td>
<td>禁止对 __dirname 和 __filename进行字符串连接</td>
</tr>
<tr>
<td>no-process-env</td>
<td>禁用 process.env</td>
</tr>
<tr>
<td>no-process-exit</td>
<td>禁用 process.exit()</td>
</tr>
<tr>
<td>no-sync</td>
<td>禁用同步方法</td>
</tr>
</tbody>
</table>
<h4 id="风格问题"><a href="#风格问题" class="headerlink" title="风格问题"></a>风格问题</h4><table>
<thead>
<tr>
<th>eslint:recommended</th>
<th>可被修复</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>fix</td>
<td>array-bracket-spacing</td>
<td>指定数组的元素之间要以空格隔开(, 后面)， never参数：[ 之前和 ] 之后不能带空格，always参数：[ 之前和 ] 之后必须带空格</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>block-spacing</td>
<td>禁止或强制在单行代码块中使用空格(禁用)</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>brace-style</td>
<td>强制使用一致的缩进 第二个参数为 tab 时，会使用tab，</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>camelcase</td>
<td>双峰驼命名格式</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>capitalized-comments</td>
<td>执行或不允许评论的第一个字母大写</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>comma-spacing</td>
<td>控制逗号前后的空格</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>comma-dangle</td>
<td>要求不允许逗号</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>comma-style</td>
<td>控制逗号在行尾出现还是在行首出现 (默认行尾)</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>computed-property-spacing</td>
<td>以方括号取对象属性时，[ 后面和 ] 前面是否需要空格, 可选参数 never, always</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>consistent-this</td>
<td>用于指统一在回调函数中指向this的变量名，箭头函数中的this已经可以指向外层调用者，应该没卵用了</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>func-names</td>
<td>强制使用命名的 function 表达式</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>eol-last</td>
<td>文件末尾强制换行</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>indent</td>
<td>执行一致的缩进</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>key-spacing</td>
<td>强制在对象字面量的属性中键和值之间使用一致的间距</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>linebreak-style</td>
<td>强制使用一致的换行风格</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>lines-around-comment</td>
<td>要求在注释周围有空行      ( 要求在块级注释之前有一空行)</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>func-style</td>
<td>强制一致地使用函数声明或函数表达式，方法定义风格，参数：</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>max-nested-callbacks</td>
<td>强制回调函数最大嵌套深度 5层</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>id-blacklist</td>
<td>禁止使用指定的标识符</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>id-length</td>
<td>强制标识符的最新和最大长度</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>id-match</td>
<td>要求标识符匹配一个指定的正则表达式</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>jsx-quotes</td>
<td>强制在 JSX 属性中一致地使用双引号或单引号</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>keyword-spacing</td>
<td>强制在关键字前后使用一致的空格 (前后腰需要)</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>max-len</td>
<td>强制一行的最大长度</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>max-lines</td>
<td>强制最大行数</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>max-params</td>
<td>强制 function 定义中最多允许的参数数量</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>max-statements</td>
<td>强制 function 块最多允许的的语句数量</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>max-statements-per-line</td>
<td>强制每一行中所允许的最大语句数量</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>new-cap</td>
<td>要求构造函数首字母大写  （要求调用 new 操作符时有首字母大小的函数，允许调用首字母大写的函数时没有 new 操作符。）</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>new-parens</td>
<td>要求调用无参构造函数时有圆括号</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>newline-after-var</td>
<td>要求或禁止 var 声明语句后有一行空行</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-array-constructor</td>
<td>禁止使用 Array 构造函数</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-bitwise</td>
<td>禁用按位运算符</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>newline-before-return</td>
<td>要求 return 语句之前有一空行</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>newline-per-chained-call</td>
<td>要求方法链中每个调用都有一个换行符</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-continue</td>
<td>禁用 continue 语句</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-inline-comments</td>
<td>禁止在代码行后使用内联注释</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>no-lonely-if</td>
<td>禁止 if 作为唯一的语句出现在 else 语句中</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-mixed-operators</td>
<td>禁止混合使用不同的操作符</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-mixed-spaces-and-tabs</td>
<td>不允许空格和 tab 混合缩进</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>no-multiple-empty-lines</td>
<td>不允许多个空行</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-negated-condition</td>
<td>不允许否定的表达式</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-nested-ternary</td>
<td>不允许使用嵌套的三元表达式</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-new-object</td>
<td>禁止使用 Object 的构造函数</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-plusplus</td>
<td>禁止使用一元操作符 ++ 和 –</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-restricted-syntax</td>
<td>禁止使用特定的语法</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-spaced-func</td>
<td>禁止 function 标识符和括号之间出现空格</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-ternary</td>
<td>不允许使用三元操作符</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>no-trailing-spaces</td>
<td>禁用行尾空格</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-underscore-dangle</td>
<td>禁止标识符中有悬空下划线_bar</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>no-unneeded-ternary</td>
<td>禁止可以在有更简单的可替代的表达式时使用三元操作符</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>no-whitespace-before-property</td>
<td>禁止属性前有空白</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>object-curly-newline</td>
<td>强制花括号内换行符的一致性</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>object-curly-spacing</td>
<td>强制在花括号中使用一致的空格</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>object-property-newline</td>
<td>强制将对象的属性放在不同的行上</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>one-var</td>
<td>强制函数中的变量要么一起声明要么分开声明</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>one-var-declaration-per-line</td>
<td>要求或禁止在 var 声明周围换行</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>operator-assignment</td>
<td>要求或禁止在可能的情况下要求使用简化的赋值操作符</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>operator-linebreak</td>
<td>强制操作符使用一致的换行符</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>padded-blocks</td>
<td>要求或禁止块内填充</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>quote-props</td>
<td>要求对象字面量属性名称用引号括起来</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>quotes</td>
<td>强制使用一致的反勾号、双引号或单引号</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>require-jsdoc</td>
<td>要求使用 JSDoc 注释</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>semi</td>
<td>要求或禁止使用分号而不是 ASI（这个才是控制行尾部分号的，）</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>semi-spacing</td>
<td>强制分号之前和之后使用一致的空格</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>sort-vars</td>
<td>要求同一个声明块中的变量按顺序排列</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>space-before-blocks</td>
<td>强制在块之前使用一致的空格</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>space-before-function-paren</td>
<td>强制在 function的左括号之前使用一致的空格</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>space-in-parens</td>
<td>强制在圆括号内使用一致的空格</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>space-infix-ops</td>
<td>要求操作符周围有空格</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>space-unary-ops</td>
<td>强制在一元操作符前后使用一致的空格</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>spaced-comment</td>
<td>强制在注释中 // 或 /* 使用一致的空格</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>unicode-bom</td>
<td>要求或禁止 Unicode BOM</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>wrap-regex</td>
<td>要求正则表达式被括号括起来</td>
</tr>
</tbody>
</table>
<h4 id="ECMAScript-6"><a href="#ECMAScript-6" class="headerlink" title="ECMAScript 6"></a>ECMAScript 6</h4><table>
<thead>
<tr>
<th>eslint:recommended</th>
<th>可被修复</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>fix</td>
<td>arrow-body-style</td>
<td>要求箭头函数体使用大括号</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>arrow-parens</td>
<td>要求箭头函数的参数使用圆括号</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>constructor-super</td>
<td>强制在子类构造函数中用super()调用父类构造函数，TypeScrip的编译器也会提示</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>generator-star-spacing</td>
<td>强制 generator 函数中 * 号周围使用一致的空格</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-class-assign</td>
<td>禁止修改类声明的变量</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-confusing-arrow</td>
<td>不允许箭头功能，在那里他们可以混淆的比较</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-const-assign</td>
<td>禁止修改 const 声明的变量</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-dupe-class-members</td>
<td>禁止类成员中出现重复的名称</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-duplicate-imports</td>
<td>不允许复制模块的进口</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-new-symbol</td>
<td>禁止 Symbol  的构造函数</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-restricted-imports</td>
<td>允许指定模块加载时的进口</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-this-before-super</td>
<td>禁止在构造函数中，在调用 super() 之前使用 this 或 super</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>no-useless-computed-key</td>
<td>禁止不必要的计算性能键对象的文字</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>no-var</td>
<td>要求使用 let 或 const 而不是 var</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>object-shorthand</td>
<td>要求或禁止对象字面量中方法和属性使用简写语法</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>prefer-arrow-callback</td>
<td>要求使用箭头函数作为回调</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>prefer-const</td>
<td>要求使用 const 声明那些声明后不再被修改的变量</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>prefer-reflect</td>
<td>要求在合适的地方使用 Reflect 方法</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>prefer-spread</td>
<td>要求使用扩展运算符而非 .apply()</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>prefer-template</td>
<td>要求使用模板字面量而非字符串连接</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>prefer-rest-params</td>
<td>对于arguments使用…rest</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>require-yield</td>
<td>要求generator 函数内有 yield</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>rest-spread-spacing</td>
<td>“rest”和扩展运算符及其表达式之间的间距</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>sort-imports</td>
<td>强制模块内的 import 排序</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>template-curly-spacing</td>
<td>要求或禁止模板字符串中的嵌入表达式周围空格的使用</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>yield-star-spacing</td>
<td>强制在 yield<em> 表达式中 </em> 周围使用空格</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;esLint入门&quot;&gt;&lt;a href=&quot;#esLint入门&quot; class=&quot;headerlink&quot; title=&quot;esLint入门&quot;&gt;&lt;/a&gt;esLint入门&lt;/h3&gt;&lt;p&gt;ESLint是用于识别和报告ECMAScript / JavaScript代码书写风格的工具，目的是使代码更加一致并避免错误。 在许多方面，它与JSLint和JSHint类似，但有一些例外：&lt;br&gt;
    
    </summary>
    
      <category term="代码风格" scheme="https://wangzongxu.github.io/categories/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/"/>
    
    
      <category term="代码风格" scheme="https://wangzongxu.github.io/tags/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/"/>
    
  </entry>
  
  <entry>
    <title>ES6函数参数解构典型问题</title>
    <link href="https://wangzongxu.github.io/2017/09/21/decomposition-function-params/"/>
    <id>https://wangzongxu.github.io/2017/09/21/decomposition-function-params/</id>
    <published>2017-09-21T09:09:24.000Z</published>
    <updated>2017-09-21T09:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>函数参数解构的一个典型问题</p>
<a id="more"></a>
<h3 id="首先对比两个例子"><a href="#首先对比两个例子" class="headerlink" title="首先对比两个例子"></a>首先对比两个例子</h3><blockquote>
<p>例子一</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, 0]</span></span><br><span class="line">move(&#123;&#125;); <span class="comment">// [0, 0]</span></span><br><span class="line">move();  <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>例子二</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x, y&#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, undefined]</span></span><br><span class="line">move(&#123;&#125;); <span class="comment">// [undefined, undefined]</span></span><br><span class="line">move(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>不能理解结果的话继续往下看^_^</li>
</ul>
<h3 id="从babel转码看解构原理"><a href="#从babel转码看解构原理" class="headerlink" title="从babel转码看解构原理"></a>从babel转码看解构原理</h3><p>利用babel<a href="https://babeljs.io/repl/" target="_blank" rel="external">在线转码</a>方便学习解构的原理:</p>
<ul>
<li>再次分析函数的参数</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>我们将上边函数参数分为两部分，等号前边 {x = 0, y = 0} 称之为模式，等号后边 {} 是称之为默认参数，如果函数执行时没有传参，则会取默认参数。</li>
</ul>
<blockquote>
<p>babel转码后的例子一</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _ref = <span class="built_in">arguments</span>.length &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">arguments</span>[<span class="number">0</span>] !== <span class="literal">undefined</span> ? <span class="built_in">arguments</span>[<span class="number">0</span>] : &#123;&#125;;</span><br><span class="line">  <span class="comment">// 如果没有传参，那么取默认值空对象&#123;&#125;</span></span><br><span class="line">  <span class="keyword">var</span> _ref$x = _ref.x;</span><br><span class="line">  <span class="comment">// 模式对参数进行解构：取参数的x值</span></span><br><span class="line">  <span class="keyword">var</span> x = _ref$x === <span class="literal">undefined</span> ? <span class="number">0</span> : _ref$x;</span><br><span class="line">  <span class="comment">// 模式中的x有默认值，所以当被解构的参数中没有x，则取模式中的x值：0</span></span><br><span class="line">  <span class="keyword">var</span> _ref$y = _ref.y;</span><br><span class="line">  <span class="comment">// 模式对参数进行解构：取参数的y值</span></span><br><span class="line">  <span class="keyword">var</span> y = _ref$y === <span class="literal">undefined</span> ? <span class="number">0</span> : _ref$y;</span><br><span class="line">  <span class="comment">// 模式中的y有默认值，所以当被解构的参数中没有y，则取模式中的y值：0</span></span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123; <span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span> &#125;);</span><br><span class="line"><span class="comment">// 传递了参数 &#123; x: 3, y: 8 &#125; 则模式对该参数进行解构，结果为：[3, 8]</span></span><br><span class="line">move(&#123; <span class="attr">x</span>: <span class="number">3</span> &#125;);</span><br><span class="line"><span class="comment">// 传递了参数 &#123; x: 3 &#125; 则模式对该参数进行解构，解构过程中x成功取值:3，由于参数中没有y，所以y值取值失败，失败后取模式中的y默认值0，所以结果为：[3, 0]</span></span><br><span class="line">move(&#123;&#125;);</span><br><span class="line"><span class="comment">// 传递了参数空对象&#123;&#125; 则模式对该空对象进行解构，由于该参数中xy都没有，所以都取模式中xy默认值0，最后结果为[0, 0]</span></span><br><span class="line">move();</span><br><span class="line"><span class="comment">// 没有传递参数，则取默认参数空对象 &#123;&#125;，模式对默认参数进行解构，和上边一样，参数中xy都没有，所以都取模式中xy默认值0，最后结果为[0, 0]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>babel转码后的例子二</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _ref2 = <span class="built_in">arguments</span>.length &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">arguments</span>[<span class="number">0</span>] !== <span class="literal">undefined</span> ? <span class="built_in">arguments</span>[<span class="number">0</span>] : &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;;</span><br><span class="line">  <span class="comment">// 如果没有传参，那么取默认值：&#123; x: 0, y: 0 &#125;</span></span><br><span class="line">  <span class="keyword">var</span> x = _ref2.x;</span><br><span class="line">  <span class="comment">// 模式对参数进行解构：取参数的x值</span></span><br><span class="line">  <span class="keyword">var</span> y = _ref2.y;</span><br><span class="line">  <span class="comment">// 模式对参数进行解构：取参数的y值</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123; <span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span> &#125;);</span><br><span class="line"><span class="comment">// 传递了参数 &#123; x: 3, y: 8 &#125; 则模式对该参数进行解构，结果为：[3, 8]</span></span><br><span class="line">move(&#123; <span class="attr">x</span>: <span class="number">3</span> &#125;);</span><br><span class="line"><span class="comment">// 传递了参数 &#123; x: 3 &#125;，模式对该参数进行解构，解构过程中x成功取值:3，由于参数中没有y，所以y值取值失败，此时模式中也没有指定y的默认值，所以结果为：[3, undefined]</span></span><br><span class="line">move(&#123;&#125;);</span><br><span class="line"><span class="comment">// 传递了参数空对象 &#123;&#125;，模式对参数空对象进行解构，xy皆取值失败，模式中xy也并没有默认值，所以最后结果为：[undefined, undefined]</span></span><br><span class="line">move();</span><br><span class="line"><span class="comment">// 没有传递参数，则取默认参数&#123; x: 0, y: 0 &#125;，模式对默认参数进行解构，x取值0，取值0，所以结果为[0, 0]</span></span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>当一个函数执行时要看该函数在定义过程中是否有默认参数，模式中是否有默认值：<br>首先根据是否传参和是否有默认参数来确定参数是谁，然后将模式对参数进行解构。<br>结构过程中如果解构失败要根据模式中是否指定了默认值来确定最后取值。<br>逻辑比较乱，多多练习，慢慢体会。</p>
<ul>
<li>取值过程<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">if (有默认参数) &#123;</span><br><span class="line">    if (执行时传参了) &#123;</span><br><span class="line">        将模式对参数解构</span><br><span class="line">         if (解构成功) &#123;</span><br><span class="line">             最终取值成功解构的值</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             if (模式中制定了默认值) &#123;</span><br><span class="line">                最终取模式中默认值</span><br><span class="line">             &#125; else &#123;</span><br><span class="line">                取值undefined</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">        将模式对默认参数解构</span><br><span class="line">        if (解构成功) &#123;</span><br><span class="line">            最终取值成功解构的值</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (模式中制定了默认值) &#123;</span><br><span class="line">                最终取模式中默认值</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                取值undefined</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    if (执行时传参了) &#123;</span><br><span class="line">       最终以执行传递的参数为准</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">       最终参数为undefined</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>(完)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;函数参数解构的一个典型问题&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="https://wangzongxu.github.io/categories/JS/"/>
    
    
      <category term="JS" scheme="https://wangzongxu.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>前端优化技巧</title>
    <link href="https://wangzongxu.github.io/2017/09/21/front-end-optimzation/"/>
    <id>https://wangzongxu.github.io/2017/09/21/front-end-optimzation/</id>
    <published>2017-09-21T09:09:24.000Z</published>
    <updated>2017-09-21T09:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>总结一些前端优化技巧：<br><a id="more"></a></p>
<h3 id="减少HTTP请求"><a href="#减少HTTP请求" class="headerlink" title="减少HTTP请求"></a>减少HTTP请求</h3><ul>
<li>把CSS/JS文件进行合并压缩(前端压缩一下,服务器做一下GZIP压缩),一个页面只有一个CSS/JS。</li>
<li>在移动端页面开发过程中,如果CSS/JS的代码量不是很多的话,我们尽量使用内嵌式。</li>
<li>数据缓存(localStorage):把我们的CSS/JS代码存储到本地,下一次刷新页面的时候直接的在本地缓存中读取即可,不需要重新的发送HTTP请求了(需要更新可以通过JS的版本号来实现更新)。</li>
<li>CSS SPRITE 把静态的资源图片进行合并,合并到一张大图上,通过POSITION定位找到具体的图片,这样的话只需要发送一次HTTP请求即可。</li>
<li>能够用代码(SVG)绘制出来的图片我们尽量不使用IMG来做。</li>
<li>图片的延迟加载：首屏图片等到一段时间在进行加载,其它屏幕的图片当页面滚动到对应区域的时候在进行延迟加载。</li>
<li>静态资源小图可采用BASE64技术进行编码。</li>
<li>数据的异步加载:第一次只请求出部分数据(一般都是一到两屏幕的数据),当我们滚动到的底部的时候在开始加载下面的两屏幕数据(上拉/下拉刷新)。</li>
<li>数据缓存(localStorage):第一次把请求回来的数据保存在自己的本地,在有效时间内,我们刷新页面的时候,只需要把本地的存储数据获取到绑定到页面中即可,不需要重新的发送Ajax请求,直到时间过期,在从新的发送请求,用最新请求的数据替换本地之前存储的数据。</li>
<li>把音视频播放进行延迟加载(PRELOAD=’NONE’),在JS中做延迟播放,播放的时候在加载资源;有条件的话可以把音视频都用文件流的方式进行操作;</li>
</ul>
<h3 id="减少HTTP请求资源的大小"><a href="#减少HTTP请求资源的大小" class="headerlink" title="减少HTTP请求资源的大小"></a>减少HTTP请求资源的大小</h3><ul>
<li><a href="/2017/03/26/yahoo34/">雅虎优化34条建议</a></li>
<li>CSS/JS去除冗余代码(低耦合高内聚)</li>
<li>图片尽量压缩</li>
<li>每一次请求回来的数据尽量少一些,我们可以分批请求</li>
<li>所有的CSS/JS上传到服务器的都是经过压缩过的</li>
</ul>
<h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><ul>
<li>尽量减少不销毁闭包的使用(堆栈内存的释放问题)</li>
<li>尽量多使用异步编程,少使用同步编程</li>
<li>移动端开发,能够使用CSS实现的功能最好也不用JS;能够使用CSS3实现的动画,绝对不用JS;能用TransForm实现的动画尽量用它实现(TransForm开启了硬件加速);能够自己使用原生的JS实现的,绝对不用任何的框架或者类库(多人开发,项目偏大,我们在使用相关的框架);</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结一些前端优化技巧：&lt;br&gt;
    
    </summary>
    
      <category term="前端优化" scheme="https://wangzongxu.github.io/categories/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="前端优化" scheme="https://wangzongxu.github.io/tags/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>hexo</title>
    <link href="https://wangzongxu.github.io/2017/09/21/hexo/"/>
    <id>https://wangzongxu.github.io/2017/09/21/hexo/</id>
    <published>2017-09-21T09:09:24.000Z</published>
    <updated>2017-09-21T09:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。<br><a id="more"></a></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序：</p>
<ul>
<li><a href="http://nodejs.org/" target="_blank" rel="external">node</a></li>
<li><a href="http://git-scm.com/" target="_blank" rel="external">git</a></li>
</ul>
<p>安装hexo</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<blockquote>
<p>node版本5.0或更高导致报错，但不影响hexo的正常使用</p>
</blockquote>
<h3 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h3><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line"><span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>新建完成后，指定文件夹的目录如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>
<h3 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h3><p>网站的 配置 信息，您可以在此配置大部分的参数。</p>
<h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p>应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"hexo-site"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.0"</span>,</span><br><span class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"hexo"</span>: &#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">""</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"hexo"</span>: <span class="string">"^3.0.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-archive"</span>: <span class="string">"^0.1.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-category"</span>: <span class="string">"^0.1.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-index"</span>: <span class="string">"^0.1.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-tag"</span>: <span class="string">"^0.1.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-renderer-ejs"</span>: <span class="string">"^0.1.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-renderer-stylus"</span>: <span class="string">"^0.2.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-renderer-marked"</span>: <span class="string">"^0.2.4"</span>,</span><br><span class="line">    <span class="attr">"hexo-server"</span>: <span class="string">"^0.1.2"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="scaffolds"><a href="#scaffolds" class="headerlink" title="scaffolds"></a>scaffolds</h3><p>模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。<br>Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。</p>
<h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><p>资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</p>
<h3 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h3><p><a href="https://hexo.io/themes/" target="_blank" rel="external">主题</a> 文件夹。Hexo 会根据主题来生成静态页面。</p>
<ol>
<li>在themes文件夹下新建一个文件夹准备存放主题文件，例如命名为’simple’</li>
<li>更改根目录下_config.yml文件中的theme字段的值为 simple（注意空格开头）</li>
<li>选择喜欢的<a href="https://hexo.io/themes/" target="_blank" rel="external">主题</a>并下载解压到刚刚创建的simple文件夹下</li>
<li>命令行执行 hexo server</li>
</ol>
<h3 id="一键部署到Github"><a href="#一键部署到Github" class="headerlink" title="一键部署到Github"></a>一键部署到Github</h3><ol>
<li>在自己github下新建一个仓库并命名为‘github用户名’+’.github.io’</li>
<li><p>编辑根目录下的_config.yml,拖到最下方,找到deploy标签,然后更为如下配置,注意:你自己在修改时,需要将 xxxxx修改为自己的github用户名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repository: https://github.com/xxxxx/xxxxx.github.io.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装插件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git –save</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译<br>执行项目清理和静态网页生成</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br></pre></td></tr></table></figure>
</li>
<li><p>部署</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
</li>
<li><p>完成<br>去自己刚刚建立的github仓库查看是否成功部署</p>
</li>
</ol>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hexo init [blogName] <span class="comment">#初始化博客</span></span><br><span class="line">hexo version <span class="comment">#hexo版本</span></span><br><span class="line">hexo new <span class="string">"我的博客"</span> ==hexo n <span class="string">"我的博客"</span><span class="comment">#新建文章</span></span><br><span class="line">hexo publish  == hexo p <span class="comment">#发表草稿</span></span><br><span class="line">hexo generate == hexo g <span class="comment">#生成</span></span><br><span class="line">hexo clean <span class="comment">#清除缓存文件 (db.json) 和已生成的静态文件 (public)</span></span><br><span class="line">hexo server == hexo s <span class="comment">#启动服务预览</span></span><br><span class="line">hexo deploy ==hexo d <span class="comment">#部署</span></span><br></pre></td></tr></table></figure>
<h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hexo server <span class="comment">#Hexo 会监视文件变动并自动更新，您无须重启服务器。</span></span><br><span class="line">hexo server -s <span class="comment">#静态模式</span></span><br><span class="line">hexo server -p 5000 <span class="comment">#更改端口</span></span><br><span class="line">hexo server -i 192.168.1.1 <span class="comment">#自定义 IP</span></span><br><span class="line"></span><br><span class="line">hexo clean <span class="comment">#清除缓存 网页正常情况下可以忽略此条命令</span></span><br><span class="line">hexo g <span class="comment">#生成静态网页</span></span><br><span class="line">hexo d <span class="comment">#开始部署</span></span><br></pre></td></tr></table></figure>
<h3 id="监视文件变动"><a href="#监视文件变动" class="headerlink" title="监视文件变动"></a>监视文件变动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate <span class="comment">#生成静态文件</span></span><br><span class="line">hexo generate --watch <span class="comment">#监视文件变动自动生成静态文件</span></span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。&lt;br&gt;
    
    </summary>
    
      <category term="博客" scheme="https://wangzongxu.github.io/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="博客" scheme="https://wangzongxu.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>BS 架构概述</title>
    <link href="https://wangzongxu.github.io/2017/09/21/BS/"/>
    <id>https://wangzongxu.github.io/2017/09/21/BS/</id>
    <published>2017-09-21T09:09:24.000Z</published>
    <updated>2017-09-21T09:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>B/S结构即浏览器和服务器结构。<br><a id="more"></a><br></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>它是随着互联网s技术的兴起，对C/S结构的一种变化或者改进的结构。<br>在这种结构下，用户工作界面是通过WWW浏览器来实现，极少部分事务逻辑在前端(Browser)实现，但是主要事务逻辑在服务器端(Server)实现，形成所谓三层3-tier结构。<br>B/S结构是WEB兴起后的一种网络结构模式，WEB浏览器是客户端最主要的应用软件。这种模式统一了客户端，将系统功能实现的核心部分集中到服务器上，简化了系统的开发、维护和使用。<br>客户机上只要安装一个浏览器（Browser），服务器安装Oracle、Sybase、Informix或 SQL Server等数据库。浏览器通过Web Server同数据库进行数据交互。 这样就大大简化了客户端电脑载荷，减轻了系统维护与升级的成本和工作量，降低了用户的总体成本(TCO)。</p>
<h2 id="维护和升级"><a href="#维护和升级" class="headerlink" title="维护和升级"></a>维护和升级</h2><p>软件系统的改进和升级越来越频繁，B/S架构的产品明显体现着更为方便的特性。<br>对一个稍微大一点单位来说，系统管理人员如果需要在几百甚至上千部电脑之间来回奔跑，效率和工作量是可想而知的，但B/S架构的软件只需要管理服务器就行了，所有的客户端只是浏览器，根本不需要做任何的维护。<br>无论用户的规模有多大，有多少分支机构都不会增加任何维护升级的工作量，所有的操作只需要针对服务器进行；如果是异地，只需要把服务器连接专网即可，实现远程维护、升级和共享。所以客户机越来越“瘦”，而服务器越来越“胖”是将来信息化发展的主流方向。<br>今后，软件升级和维护会越来越容易，而使用起来会越来越简单，这对用户人力、物力、时间、费用的节省是显而易见的，惊人的。因此，维护和升级革命的方式是“瘦”客户机，“胖”服务器。</p>
<h2 id="成本与选择"><a href="#成本与选择" class="headerlink" title="成本与选择"></a>成本与选择</h2><p>大家都知道windows在桌面电脑上几乎一统天下，浏览器成为了标准配置。<br>但在服务器操作系统上，windows并不是处于绝对的统治地位。<br>软件的趋势是凡使用B/S架构的应用管理软件，只需安装在Linux服务器上即可，而且安全性高。<br>所以服务器操作系统的选择是很多的，不管选用那种操作系统都可以让大部分人使用windows作为桌面操作系统电脑不受影响，这就使得最流行免费的Linux操作系统快速发展起来，Linux除了操作系统是免费的以外，连数据库也是免费的，这种选择非常盛行。</p>
<h2 id="负荷重"><a href="#负荷重" class="headerlink" title="负荷重"></a>负荷重</h2><p>由于B/S架构管理软件只安装在服务器端（Server）上，网络管理人员只需要管理服务器就行了，用户界面主要事务逻辑在服务器（Server）端完全通过WWW浏览器实现，极少部分事务逻辑在前端（Browser）实现，所有的客户端只有浏览器，网络管理人员只需要做硬件维护。<br>但是，应用服务器运行数据负荷较重，一旦发生服务器“崩溃”等问题，后果不堪设想。因此，许多单位都备有数据库存储服务器，以防万一。</p>
<h2 id="C-S特点"><a href="#C-S特点" class="headerlink" title="C/S特点"></a>C/S特点</h2><p>C/S又称Client/Server或客户/服务器模式。<br>服务器通常采用高性能的PC、工作站或小型机，并采用大型数据库系统，如Oracle、Sybase、Informix或 SQL Server。客户端需要安装专用的客户端软件。<br>C/S的优点是能充分发挥客户端PC的处理能力，很多工作可以在客户端处理后再提交给服务器。对应的优点就是客户端响应速度快。缺点主要有以下几个：  </p>
<p>而随着互联网的飞速发展，移动办公和分布式办公越来越普及，这需要我们的系统具有扩展性。这种方式远程访问需要专门的技术，同时要对系统进行专门的设计来处理分布式的数据。  </p>
<p>客户端需要安装专用的客户端软件。首先涉及到安装的工作量，其次任何一台电脑出问题，如病毒、硬件损坏，都需要进行安装或维护。特别是有很多分部或专卖店的情况，不是工作量的问题，而是路程的问题。还有，系统软件升级时，每一台客户机需要重新安装，其维护和升级成本非常高。  </p>
<p>对客户端的操作系统一般也会有限制。可能适应于Win98，但不能用于win2000或Windows XP。或者不适用于微软新的操作系统等等，更不用说Linux、Unix等。  </p>
<p>Client/Server是建立在局域网的基础上的。Browser/Server是建立在广域网的基础上的。  </p>
<ol>
<li><p>硬件环境不同：C/S 一般建立在专用的网络上，小范围里的网络环境，局域网之间再通过专门服务器提供连接和数据交换服务。B/S 建立在广域网之上的， 不必是专门的网络硬件环境。例如电话上网,，租用设备.，信息管理，有比C/S更强的适应范围，一般只要有操作系统和浏览器就行。</p>
</li>
<li><p>对安全要求不同：C/S 一般面向相对固定的用户群， 对信息安全的控制能力很强， 一般高度机密的信息系统采用C/S 结构适宜，可以通过B/S发布部分可公开信息。B/S 建立在广域网之上, 对安全的控制能力相对弱，面向是不可知的用户群。</p>
</li>
<li><p>对程序架构不同：C/S 程序可以更加注重流程,，可以对权限多层次校验,，对系统运行速度可以较少考虑。B/S 对安全以及访问速度的多重的考虑,，建立在需要更加优化的基础之上，比C/S有更高的要求。 B/S结构的程序架构是发展的趋势，从MS的.Net系列的BizTalk 2000 Exchange 2000等，全面支持网络的构件搭建的系统.。SUN 和IBM推的JavaBean 构件技术等，使 B/S更加成熟。</p>
</li>
<li><p>软件重用不同：C/S 程序可以不可避免的整体性考虑，构件的重用性不如在B/S要求下的构件的重用性好。B/S 对的多重结构,要求构件相对独立的功能，能够相对较好的重用。</p>
</li>
<li><p>系统维护不同：系统维护在是软件生存周期中，开销大。重要C/S 程序由于整体性,，必须整体考察， 处理出现的问题以及系统升级。升级难，可能是再做一个全新的系统。B/S程序由构件组成，方便构件个别的更换，实现系统的无缝升级，系统维护开销减到最小，用户从网上自己下载安装就可以实现升级。</p>
</li>
<li><p>处理问题不同：C/S 程序可以处理用户面固定，并且在相同区域,，安全要求高需求，与操作系统相关，应该都是相同的系统。B/S 建立在广域网上，面向不同的用户群，分散地域，这是C/S无法作到的，与操作系统平台关系最小。</p>
</li>
<li><p>用户接口不同：C/S 多是建立的Window平台上，表现方法有限。对程序员普遍要求较高。B/S 建立在浏览器上,，有更加丰富和生动的表现方式与用户交流，并且大部分难度减低，减低开发成本。</p>
</li>
<li><p>信息流不同：C/S 程序一般是典型的中央集权的机械式处理，交互性相对低。B/S 信息流向可变化， B-B、 B-C、 B-G等信息流向的变化，更象交易中心。</p>
</li>
</ol>
<h5 id="技术比较"><a href="#技术比较" class="headerlink" title="技术比较"></a>技术比较</h5><p>C/S结构软件（即客户机/服务器模式）分为客户机和服务器两层，客户机不是毫无运算能力的输入、输出设备，而是具有了一定的数据处理和数据存储能力，通过把应用软件的计算和数据合理地分配在客户机和服务器两端，可以有效地降低网络通信量和服务器运算量。由于服务器连接个数和数据通信量的限制，这种结构的软件适于在用户数目不多的局域网内使用。国内现阶段的大部分ERP（财务）软件产品即属于此类结构。  </p>
<p>B/S(浏览器/服务器模式)是随着Internet技术的兴起，对C/S结构的一种改进。在这种结构下，软件应用的业务逻辑完全在应用服务器端实现，用户表现完全在Web服务器实现，客户端只需要浏览器即可进行业务处理，是一种全新的软件系统构造技术。这种结构更成为当今应用软件的首选体系结构。e通管理系列产品即属于此类结构。  </p>
<ol>
<li><p>数据安全性比较。由于C/S结构软件的数据分布特性，客户端所发生的火灾、盗抢、地震、病毒、黑客等都成了可怕的数据杀手。另外，对于集团级的异地软件应用，C/S结构的软件必须在各地安装多个服务器，并在多个服务器之间进行数据同步。如此一来，每个数据点上的数据安全都影响了整个应用的数据安全。所以，对于集团级的大型应用来讲，C/S结构软件的安全性是令人无法接受的。对于B/S结构的软件来讲，由于其数据集中存放于总部的数据库服务器，客户端不保存任何业务数据和数据库连接信息，也无需进行什么数据同步，所以这些安全问题也就自然不存在了。</p>
</li>
<li><p>数据一致性比较。在C/S结构软件的解决方案里，对于异地经营的大型集团都采用各地安装区域级服务器，然后再进行数据同步的模式。这些服务器每天必须同步完毕之后，总部才可得到最终的数据。由于局部网络故障造成个别数据库不能同步不说，即使同步上来，各服务器也不是一个时点上的数据，数据永远无法一致，不能用于决策。对于B/S结构的软件来讲，其数据是集中存放的，客户端发生的每一笔业务单据都直接进入到中央数据库，不存在数据一致性的问题。</p>
</li>
<li><p>数据实时性比较。在集团级应用里，C/S结构不可能随时随地看到当前业务的发生情况，看到的都是事后数据；而B/S结构则不同，它可以实时看到当前发生的所有业务，方便了快速决策，有效地避免了企业损失。</p>
</li>
<li><p>数据溯源性比较。由于B/S结构的数据是集中存放的，所以总公司可以直接追溯到各级分支机构（分公司、门店）的原始业务单据，也就是说看到的结果可溯源。大部分C/S结构的软件则不同，为了减少数据通信量，仅仅上传中间报表数据，在总部不可能查到各分支机构（分公司、门店）的原始单据。</p>
</li>
<li><p>服务响应及时性比较。企业的业务流程、业务模式不是一成不变的，随着企业不断发展，必然会不断调整。软件供应商提供的软件也不是完美无缺的，所以，对已经部署的软件产品进行维护、升级是正常的。C/S结构软件，由于其应用是分布的，需要对每一个使用节点进行程序安装，所以，即使非常小的程序缺陷都需要很长的重新部署时间，重新部署时，为了保证各程序版本的一致性，必须暂停一切业务进行更新（即“休克更新”），其服务响应时间基本不可忍受。而B/S结构的软件不同，其应用都集中于总部服务器上，各应用结点并没有任何程序，一个地方更新则全部应用程序更新，可以做到快速服务响应。</p>
</li>
<li><p>网络应用限制比较。C/S结构软件仅适用于局域网内部用户或宽带用户（1兆以上）；而我们的B/S结构软件可以适用于任何网络结构（包括33.6K拨号入网方式），特别适于宽带不能到达的地方（例如迪信通集团的某些分公司，仅靠电话上网即可正常使用软件系统）。</p>
</li>
<li><p>存储模式比较。B/S结构相应数据完全来自于后台数据库，而C/S结构部分数据来源于存储在本地的临时文件，剩余的部分来源于数据库，因此C/S结构响应时间会更快。</p>
</li>
</ol>
<h5 id="商业比较"><a href="#商业比较" class="headerlink" title="商业比较"></a>商业比较</h5><ol>
<li><p>投入成本比较。B/S结构软件一般只有初期一次性投入成本。对于集团来讲，有利于软件项目控制和避免IT黑洞，而C/S结构的软件则不同，随着应用范围的扩大，投资会连绵不绝。</p>
</li>
<li><p>硬件投资保护比较。在对已有硬件投资的保护方面，两种结构也是完全不同的。当应用范围扩大，系统负载上升时，C/S结构软件的一般解决方案是购买更高性能的服务器；而B/S架构则是通过增加服务器的数量来承担更大的负载。</p>
</li>
</ol>
<h2 id="融合"><a href="#融合" class="headerlink" title="融合"></a>融合</h2><p>未来发展趋势，是将B/S与C/S的优势完美地结合起来，就是说，该平台的应用系统既能以B/S的方式发布运行，同时又具有C/S方式的极强的可操作性。</p>
<h2 id="发展前景"><a href="#发展前景" class="headerlink" title="发展前景"></a>发展前景</h2><p>C/S和B/S各有优势，C/S在图形的表现能力上以及运行的速度上肯定是强于B/S模式的，不过缺点就是他需要运行专门的客户端，而且更重要的是它不能跨平台，用c++在windows下写的程序肯定是不能在linux下跑的。<br>而B/S模式就不同了，它不需要专门的客户端，只要浏览器，而浏览器是随操作系统就有的，方便就是他的优势了。<br>而且，B/S是基于网页语言的、与操作系统无关，所以跨平台也是它的优势，而且以后随着网页语言以及浏览器的进步，B/S在表现能力上的处理以及运行的速度上会越来越快，它的缺点将会越来越少。比如，未来的HTML5，在图形的渲染方面以及音频、文件的处理上已经非常强大了。<br>不过，C/S架构也有着不可替代的作用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;B/S结构即浏览器和服务器结构。&lt;br&gt;
    
    </summary>
    
      <category term="剪切板" scheme="https://wangzongxu.github.io/categories/%E5%89%AA%E5%88%87%E6%9D%BF/"/>
    
    
      <category term="网络" scheme="https://wangzongxu.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>http 状态码</title>
    <link href="https://wangzongxu.github.io/2017/09/21/httpStatus/"/>
    <id>https://wangzongxu.github.io/2017/09/21/httpStatus/</id>
    <published>2017-09-21T09:09:24.000Z</published>
    <updated>2017-09-21T09:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>整理一些http状态码。<br><a id="more"></a></p>
<h3 id="1xx信息-Informational"><a href="#1xx信息-Informational" class="headerlink" title="1xx信息 Informational"></a>1xx信息 Informational</h3><table>
<thead>
<tr>
<th>状态码</th>
<th>说明</th>
<th>原文</th>
</tr>
</thead>
<tbody>
<tr>
<td>100</td>
<td>继续</td>
<td>Continue</td>
</tr>
<tr>
<td>101</td>
<td>交换协议</td>
<td>Switching Protocols</td>
</tr>
<tr>
<td>102</td>
<td>加工</td>
<td>Processing</td>
</tr>
</tbody>
</table>
<h3 id="2××成功-Success"><a href="#2××成功-Success" class="headerlink" title="2××成功 Success"></a>2××成功 Success</h3><table>
<thead>
<tr>
<th>状态码</th>
<th>说明</th>
<th>原文</th>
</tr>
</thead>
<tbody>
<tr>
<td>200</td>
<td>成功</td>
<td>OK</td>
</tr>
<tr>
<td>201</td>
<td>创建</td>
<td>Created</td>
</tr>
<tr>
<td>202</td>
<td>接受</td>
<td>Accepted</td>
</tr>
<tr>
<td>203</td>
<td>非权威信息</td>
<td>Non-authoritative Information</td>
</tr>
<tr>
<td>204</td>
<td>无内容</td>
<td>No Content</td>
</tr>
<tr>
<td>205</td>
<td>重置内容</td>
<td>Reset Content</td>
</tr>
<tr>
<td>206</td>
<td>部分内容</td>
<td>artial Content</td>
</tr>
<tr>
<td>207</td>
<td>多状态</td>
<td>Multi-Status</td>
</tr>
<tr>
<td>208</td>
<td>已报告</td>
<td>Already Reported</td>
</tr>
<tr>
<td>226</td>
<td>IM使用</td>
<td>IM Used</td>
</tr>
</tbody>
</table>
<h3 id="3××重定向-Redirection"><a href="#3××重定向-Redirection" class="headerlink" title="3××重定向 Redirection"></a>3××重定向 Redirection</h3><table>
<thead>
<tr>
<th>状态码</th>
<th>说明</th>
<th>原文</th>
</tr>
</thead>
<tbody>
<tr>
<td>300</td>
<td>多项选择</td>
<td>Multiple Choices</td>
</tr>
<tr>
<td>301</td>
<td>永久移动</td>
<td>Moved Permanently</td>
</tr>
<tr>
<td>302</td>
<td>找到</td>
<td>Found</td>
</tr>
<tr>
<td>303</td>
<td>见其他</td>
<td>See Other</td>
</tr>
<tr>
<td>304</td>
<td>未修改</td>
<td>Not Modified</td>
</tr>
<tr>
<td>305</td>
<td>使用代理</td>
<td>Use Proxy</td>
</tr>
<tr>
<td>307</td>
<td>临时重定向</td>
<td>emporary Redirect</td>
</tr>
<tr>
<td>308</td>
<td>永久重定向</td>
<td>Permanent Redirect</td>
</tr>
</tbody>
</table>
<h3 id="4××客户端错误-Client-Error"><a href="#4××客户端错误-Client-Error" class="headerlink" title="4××客户端错误 Client Error"></a>4××客户端错误 Client Error</h3><table>
<thead>
<tr>
<th>状态码</th>
<th>说明</th>
<th>原文</th>
</tr>
</thead>
<tbody>
<tr>
<td>400</td>
<td>错误请求</td>
<td>Bad Request</td>
</tr>
<tr>
<td>401</td>
<td>未经授权</td>
<td>Unauthorized</td>
</tr>
<tr>
<td>402</td>
<td>付款需要</td>
<td>Payment Required</td>
</tr>
<tr>
<td>403</td>
<td>禁止</td>
<td>Forbidden</td>
</tr>
<tr>
<td>404</td>
<td>未找到</td>
<td>Not Found</td>
</tr>
<tr>
<td>405</td>
<td>方法不允许</td>
<td>Method Not Allowed</td>
</tr>
<tr>
<td>406</td>
<td>不可接受</td>
<td>Not Acceptable</td>
</tr>
<tr>
<td>407</td>
<td>代理验证需要</td>
<td>Proxy Authentication Required</td>
</tr>
<tr>
<td>408</td>
<td>请求超时</td>
<td>Request Timeout</td>
</tr>
<tr>
<td>409</td>
<td>冲突</td>
<td>Conflict</td>
</tr>
<tr>
<td>410</td>
<td>过时</td>
<td>Gone</td>
</tr>
<tr>
<td>411</td>
<td>需要长度字段</td>
<td>Length Required</td>
</tr>
<tr>
<td>412</td>
<td>前提条件失败</td>
<td>Precondition Failed</td>
</tr>
<tr>
<td>413</td>
<td>有效负载太大</td>
<td>Payload Too Large</td>
</tr>
<tr>
<td>414</td>
<td>请求URI太长</td>
<td>Request-URI Too Long</td>
</tr>
<tr>
<td>415</td>
<td>不支持的介质类型</td>
<td>Unsupported Media Type</td>
</tr>
<tr>
<td>416</td>
<td>请求范围不满意</td>
<td>Requested Range Not Satisfiable</td>
</tr>
<tr>
<td>417</td>
<td>未满足期望值</td>
<td>Expectation Failed</td>
</tr>
<tr>
<td>418</td>
<td>我是一个茶壶</td>
<td>I’m a teapot</td>
</tr>
<tr>
<td>421</td>
<td>错误请求</td>
<td>Misdirected Request</td>
</tr>
<tr>
<td>422</td>
<td>不可处理的实体</td>
<td>Unprocessable Entity</td>
</tr>
<tr>
<td>423</td>
<td>锁定</td>
<td>Locked</td>
</tr>
<tr>
<td>424</td>
<td>失败的依赖关系</td>
<td>Failed Dependency</td>
</tr>
<tr>
<td>426</td>
<td>需要升级</td>
<td>Upgrade Required</td>
</tr>
<tr>
<td>428</td>
<td>需要前提条件</td>
<td>Precondition Required</td>
</tr>
<tr>
<td>429</td>
<td>太多请求</td>
<td>Too Many Requests</td>
</tr>
<tr>
<td>431</td>
<td>请求标题字段太大</td>
<td>Request Header Fields Too Large</td>
</tr>
<tr>
<td>444</td>
<td>连接没有响应关闭</td>
<td>Connection Closed Without Response</td>
</tr>
<tr>
<td>451</td>
<td>不适用于法律理由</td>
<td>Unavailable For Legal Reasons</td>
</tr>
<tr>
<td>499</td>
<td>客户关闭请求</td>
<td>Client Closed Request</td>
</tr>
</tbody>
</table>
<h3 id="5××服务器错误-Server-Error"><a href="#5××服务器错误-Server-Error" class="headerlink" title="5××服务器错误 Server Error"></a>5××服务器错误 Server Error</h3><table>
<thead>
<tr>
<th>状态码</th>
<th>说明</th>
<th>原文</th>
</tr>
</thead>
<tbody>
<tr>
<td>500</td>
<td>内部服务器错误</td>
<td>Internal Server Error</td>
</tr>
<tr>
<td>501</td>
<td>未实施</td>
<td>Not Implemented</td>
</tr>
<tr>
<td>502</td>
<td>错误的网关</td>
<td>Bad Gateway</td>
</tr>
<tr>
<td>503</td>
<td>服务不可用</td>
<td>Service Unavailable</td>
</tr>
<tr>
<td>504</td>
<td>网关超时</td>
<td>Gateway Timeout</td>
</tr>
<tr>
<td>505</td>
<td>HTTP版本不受支持</td>
<td>HTTP Version Not Supported</td>
</tr>
<tr>
<td>506</td>
<td>变种也谈判</td>
<td>Variant Also Negotiates</td>
</tr>
<tr>
<td>507</td>
<td>存储不足</td>
<td>Insufficient Storage</td>
</tr>
<tr>
<td>508</td>
<td>检测到回路</td>
<td>Loop Detected</td>
</tr>
<tr>
<td>510</td>
<td>未扩展</td>
<td>Not Extended</td>
</tr>
<tr>
<td>511</td>
<td>网络认证需要</td>
<td>Network Authentication Required</td>
</tr>
<tr>
<td>599</td>
<td>网络连接超时错误</td>
<td>Network Connect Timeout Error</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整理一些http状态码。&lt;br&gt;
    
    </summary>
    
      <category term="剪切板" scheme="https://wangzongxu.github.io/categories/%E5%89%AA%E5%88%87%E6%9D%BF/"/>
    
    
      <category term="网络" scheme="https://wangzongxu.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>jsonp原理</title>
    <link href="https://wangzongxu.github.io/2017/09/21/jsonp/"/>
    <id>https://wangzongxu.github.io/2017/09/21/jsonp/</id>
    <published>2017-09-21T09:09:24.000Z</published>
    <updated>2017-09-21T09:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>介绍jsonp实现原理</p>
<a id="more"></a>
<h3 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h3><blockquote>
<p>三要素:协议 域名 端口</p>
</blockquote>
<ul>
<li><p>什么是同域请求?<br>一个请求的url三要素与当前页面url的三要素相同的请求叫做同域请求</p>
</li>
<li><p>什么是跨域请求?<br>一个请求的url三要素与当前页面url的三要素只要有一个不同,那么这个请求就是跨域请求.<br>例如：<a href="http://www.baidu.com" target="_blank" rel="external">http://www.baidu.com</a> 和 <a href="http://tieba.baidu.com" target="_blank" rel="external">http://tieba.baidu.com</a> 的域名不一样，造成跨域</p>
</li>
</ul>
<h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><p>它是一种浏览器厂商为了安全,强制添加的一种安全限制.<br>它限制了js在哪些地方(同域请求中)可以用,哪些地方(跨域请求中)不可以用.</p>
<h3 id="如何安全绕过同源策略的限制"><a href="#如何安全绕过同源策略的限制" class="headerlink" title="如何安全绕过同源策略的限制?"></a>如何安全绕过同源策略的限制?</h3><p>平时可能注意过，当img、script、iframe标签的src引用地址是可以引用跨域资源的。比较img script iframe 这三个标签的特点：</p>
<ul>
<li>img的特点</li>
</ul>
<ol>
<li>加载跨域资源时不受同源策略的限制</li>
<li>会把加载过来的内容强制当成图片来显示.如果不是合法图片,则显示裂图.</li>
</ol>
<ul>
<li>script的特点</li>
</ul>
<ol>
<li>加载跨域资源时不受同源策略的限制</li>
<li>会把加载过来的内容强制当成脚本来执行.如果返回的数据不是合法的脚本,则执行出错.</li>
</ol>
<ul>
<li>iframe</li>
</ul>
<ol>
<li>加载跨域资源时不受同源策略的限制</li>
<li>数据可以成功加载进来,但是由于同源策略的限制无法获取里头的内容.</li>
</ol>
<ul>
<li>比较以上特点，我们可以利用script标签的这两个特点,来实现一个跨域请求.</li>
</ul>
<h3 id="jsonp的原理"><a href="#jsonp的原理" class="headerlink" title="jsonp的原理:"></a>jsonp的原理:</h3><ol>
<li>利用script标签实现跨域请求,<script src="http://www.abc.com?callback=functionName"></script></li>
<li>server定义好的那个用来设置返回数据中执行函数的函数名的那个参数就叫callback;(参见示例中的jsonp参数)</li>
<li>callback后面跟的value(参见示例中的randomName方法的执行)必须是全局作用域下的一个函数</li>
<li>server返回的数据格式是固定的: functionName( /*json data*/ );</li>
</ol>
<h3 id="为什么叫jsonp"><a href="#为什么叫jsonp" class="headerlink" title="为什么叫jsonp?"></a>为什么叫jsonp?</h3><ol>
<li>根据返回的数据格式来看：函数名 + json数据<br>即：functionName + json data</li>
<li>用语言表达出来：函数名装入一个json数据<br>即：functionName append a json data</li>
<li>更换主语：json数据填入到一个函数名内<br>即：json data padding a functionName</li>
<li>缩句：json数据填入函数名<br>即：json padding functionName =&gt;</li>
<li>缩句（专注过程）：一个json填充的过程<br>即：json padding</li>
<li>再缩句<br>即：jsonp</li>
</ol>
<h3 id="jsonp的注意事项"><a href="#jsonp的注意事项" class="headerlink" title="jsonp的注意事项:"></a>jsonp的注意事项:</h3><ol>
<li>因为jsonp是通过script的src属性去加载跨域资资源,所以jsonp请求全部都是get方法请求.</li>
<li>get系方法有的特点jsonp全有</li>
<li>所有的jsonp接口必须含有一个callback,否则不是合法的jsonp接口.</li>
<li>所有的jsonp接口必须按照格式返回 =&gt; functionName( /*json data*/ );</li>
</ol>
<h3 id="jsonp为什么不是ajax"><a href="#jsonp为什么不是ajax" class="headerlink" title="jsonp为什么不是ajax?"></a>jsonp为什么不是ajax?</h3><ol>
<li>因为ajax是通过浏览器提供的操作http请求的API来实现的.</li>
<li>jsonp是通过script实现的.所以jsonp不是ajax.</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理模块化兼容：</span></span><br><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params">name, factory</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">'function'</span>) &#123; <span class="comment">// requireJs</span></span><br><span class="line">    define(factory);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">'object'</span> &amp;&amp; <span class="built_in">module</span>.exports) &#123; <span class="comment">// commonJs</span></span><br><span class="line">    <span class="built_in">module</span>.exports = factory();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不支持模块化，将jsonp方法放在window上</span></span><br><span class="line">    <span class="keyword">this</span>[name] = factory();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="string">'jsonp'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定义一些需要的方法:</span></span><br><span class="line">  <span class="keyword">var</span> tools = &#123;</span><br><span class="line">    <span class="comment">// 合并对象</span></span><br><span class="line">    extends: <span class="function"><span class="keyword">function</span>(<span class="params">target, mix</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> mix) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mix.hasOwnProperty(key)) &#123;</span><br><span class="line">          target[key] = mix[key]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 格式化参数</span></span><br><span class="line">    queryString:<span class="function"><span class="keyword">function</span>(<span class="params">str, obj</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> params = [];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">          params.push(key + <span class="string">'='</span> + obj[key])</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">var</span> fields = params.join(<span class="string">'&amp;'</span>);</span><br><span class="line">      <span class="keyword">if</span> (fields.length === <span class="number">0</span>)<span class="keyword">return</span> str;</span><br><span class="line">      <span class="keyword">if</span> (str.indexOf(<span class="string">'?'</span>) &gt; <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> str + fields</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> str + <span class="string">'?'</span> + fields</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 类型判断</span></span><br><span class="line">    type:<span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="regexp">/\[object\s(\w+)\]/</span>.exec(</span><br><span class="line">        <span class="built_in">Object</span>.prototype.toString.call(target)</span><br><span class="line">      )[<span class="number">1</span>];</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 创建全局functionName随机名称</span></span><br><span class="line">    randomName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'jsonp'</span> + <span class="built_in">Math</span>.random().toString().substr(<span class="number">2</span>,<span class="number">7</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对外暴露接口</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">opt</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 定义默认参数</span></span><br><span class="line">    <span class="keyword">var</span> fields = &#123;</span><br><span class="line">      <span class="attr">url</span>: <span class="string">''</span>, <span class="comment">// 接口地址</span></span><br><span class="line">      data: &#123;&#125;, <span class="comment">// 参数（问号传参）</span></span><br><span class="line">      context: <span class="built_in">window</span>, <span class="comment">// success、error、complete三个函数的上下文环境</span></span><br><span class="line">      jsonp: <span class="string">'callback'</span>, <span class="comment">// 与server端约定的jsonp参数名</span></span><br><span class="line">      success: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;, <span class="comment">// 成功的对调</span></span><br><span class="line">      error: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;, <span class="comment">// 失败的回调</span></span><br><span class="line">      complete: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 执行完成的回调</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将用户传入的参数与默认参数融合</span></span><br><span class="line">    tools.extends(fields, opt);</span><br><span class="line">    <span class="comment">// 参数不正确进行报错</span></span><br><span class="line">    <span class="keyword">if</span> (!fields.url) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'url must be string'</span>);</span><br><span class="line">    <span class="keyword">if</span> (tools.type(fields.url) !== <span class="string">'String'</span> ||</span><br><span class="line">        tools.type(fields.jsonp) !== <span class="string">'String'</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'url and jsonp must be string'</span>);</span><br><span class="line">    <span class="keyword">if</span> (tools.type(fields.data) !== <span class="string">'Object'</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'data must be object'</span>);</span><br><span class="line">    <span class="keyword">if</span> (tools.type(fields.success) !== <span class="string">'Function'</span> ||</span><br><span class="line">        tools.type(fields.error) !== <span class="string">'Function'</span> ||</span><br><span class="line">        tools.type(fields.complete) !== <span class="string">'Function'</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'success、error and complete must be function'</span>);</span><br><span class="line">    <span class="comment">// 生成随机全局functionName</span></span><br><span class="line">    <span class="keyword">var</span> tempName = tools.randomName();</span><br><span class="line">    <span class="comment">// 因为functionName也要序列化到url上，所以将functionName加入data参数中</span></span><br><span class="line">    fields.data[fields.jsonp] = tempName;</span><br><span class="line">    <span class="comment">// 序列化生成新url</span></span><br><span class="line">    <span class="keyword">var</span> url = tools.queryString(fields.url, fields.data);</span><br><span class="line">    <span class="comment">// 根据functionName定义全局可执行函数</span></span><br><span class="line">    <span class="built_in">window</span>[tempName] = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 该方法被调用后执行成功的回调并更改上下文环境</span></span><br><span class="line">      fields.success.call(fields.context, data);</span><br><span class="line">      <span class="comment">// 执行完成</span></span><br><span class="line">      complete(tempName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建script标签</span></span><br><span class="line">    createScriptNode(url, tempName);</span><br><span class="line">    <span class="comment">// 这里根据url创建了一个script标签并插入body，将functionName作为其id，以后用来删除</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">createScriptNode</span>(<span class="params">url, tempName</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">      script.id = tempName;</span><br><span class="line">      <span class="comment">// 异步加载，防阻塞</span></span><br><span class="line">      script.async = <span class="literal">true</span>;</span><br><span class="line">      script.src = url;</span><br><span class="line">      <span class="comment">// 处理错误</span></span><br><span class="line">      script.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">          <span class="comment">// 该方法被调用后执行失败的回调并更改上下文环境</span></span><br><span class="line">        fields.error.call(fields.context, err);</span><br><span class="line">        <span class="comment">// 执行完成</span></span><br><span class="line">        complete(tempName);</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// 插入body</span></span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据functionName删除script标签</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">removeScriptNode</span>(<span class="params">tempName</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> script = <span class="built_in">document</span>.getElementById(tempName);</span><br><span class="line">      <span class="built_in">document</span>.body.removeChild(script);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行完成</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">complete</span>(<span class="params">tempName</span>)</span>&#123;</span><br><span class="line">      <span class="comment">// 删除全局可执行函数</span></span><br><span class="line">      <span class="keyword">delete</span> <span class="built_in">window</span>[tempName];</span><br><span class="line">      <span class="comment">// 删除标签</span></span><br><span class="line">      removeScriptNode(tempName);</span><br><span class="line">      <span class="comment">// 执行完成的回调</span></span><br><span class="line">      fields.complete.call(fields.context);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍jsonp实现原理&lt;/p&gt;
    
    </summary>
    
      <category term="jsonp" scheme="https://wangzongxu.github.io/categories/jsonp/"/>
    
    
      <category term="jsonp" scheme="https://wangzongxu.github.io/tags/jsonp/"/>
    
  </entry>
  
  <entry>
    <title>后台管理系统</title>
    <link href="https://wangzongxu.github.io/2017/09/21/manageOS/"/>
    <id>https://wangzongxu.github.io/2017/09/21/manageOS/</id>
    <published>2017-09-21T09:09:24.000Z</published>
    <updated>2017-09-21T09:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>个人总结内容管理系统（CMS）的心得。<br><a id="more"></a></p>
<p>来到某云计算公司长期以来做的一直是管理系统控制台，，从jquery到vue，颇有心得。</p>
<h2 id="菜单树"><a href="#菜单树" class="headerlink" title="菜单树"></a>菜单树</h2><ul>
<li>关于菜单树，是每个管理系统必有的，作为导航性质的，非常重要的部分，整理好DOM结构，方便多级目录的展开和收起，如果使用vue，react等组件化框架，把菜单树但独立出来即可。</li>
<li>关于图标，一般放在菜单树每一项文字的前边，对于现在浏览器，我们使用的是svg，相对于图片而言，即使放大再多，也不会是真。但是有时候有一点问题，在chrome中，如果页面中的svg过多，可能造成页面解析闪烁，解决方法也比较简单：在加载页面时将svg用js拼接字符串动态插入就好。</li>
</ul>
<h2 id="面包屑"><a href="#面包屑" class="headerlink" title="面包屑"></a>面包屑</h2><ul>
<li>不知道这个名字怎么起的，所谓‘面包屑’就是页面左上角的当前位置，这里非常简单，点击每一步骤都可以进行跳转就可以了，最好的交互是如果当前是表单页面，当用户点击的时候，进行一下确认提示，防止误点导致填写的东西丢失。<br><img src="https://wangzongxu.github.io/img-cache/blog/bread.png" width="200" alt="bread" align="center"></li>
</ul>
<h2 id="列表全选和分页"><a href="#列表全选和分页" class="headerlink" title="列表全选和分页"></a>列表全选和分页</h2><ul>
<li>之前项目使用的jq来做，比较头疼的地方就是这里，因为通常在一个列表管理页面，每一条数据要有删除放入复选框，问题是当用户切换页码之后再次回到原来页数，我们如果不做特殊处理，之前选中复选框选中态会被清除，这样并不利于交互，而如果我们在逻辑处理，实践中证明虽然问题是小，但是导致的代码量增加的不少，而且可维护性和性能降低。权衡之下我们采用了这种分页结构：<br><img src="https://wangzongxu.github.io/img-cache/blog/page.png" width="400" alt="page" align="center"><br>如此之来，用户如果想要选择更多数据，只要切换当夜显示的条数即可，算是一个交互与程序复杂度的这种点吧。</li>
<li>如果项目使用的MVVM框架，则无需考虑以上问题。交互与性能兼并。</li>
</ul>
<h2 id="分步创建和编辑"><a href="#分步创建和编辑" class="headerlink" title="分步创建和编辑"></a>分步创建和编辑</h2><p>创建和编辑功能也是管理系统中不可缺失的一部分，复杂度很高，其中包括：表单验证，编辑回填，文字转义等多重问题，以下图为例：<br><img src="https://wangzongxu.github.io/img-cache/blog/step.png" width="400" alt="step" align="center"></p>
<ul>
<li>按常理来我们将这三步骤分成三个页面来做。因为这样方便代码维护，可读性也比较高，于是我们这么做了，完成之后发现一个问题：用户在这三步中是可以任意来回切换的，切换之后再回来仍然需要显示之前填写的东西。但是我们做的是三个页面，如果要保存用户的数据，还要用本地存储，过程十分繁琐。</li>
<li>如果不想考虑上一个问题，我们可以从刚开始吧这三步骤放到一个页面里，用户点击上下步骤的时候，保留当期步骤，让其他步骤隐藏即可。我们发现即使切换步骤，也不会丢失之前数据，但是试想一下，三个页面的逻辑都放在一个页面中，无论加载速度，可读性和维护性都不敢直视，上千行代码也没的说。</li>
<li>其实这里还是建议使用vue，感觉真的是为做这种系统而生的，他有个动态组件功能，允许我们把这个三个步骤单独为三个组件，当用户切换步骤的时候，我们只是控制的组件的展示，还可以将切换出取的其他步骤保存在缓存中，使得用户再次回来这个步骤，之前的数据仍然不变。这样即保证的代码的质量，也保证的用户的体验。</li>
</ul>
<h2 id="弹窗"><a href="#弹窗" class="headerlink" title="弹窗"></a>弹窗</h2><p>弹窗作为用户获得信息的重要途径，当然需要认真设计一下：</p>
<ul>
<li>将弹窗基本分为三类，确认弹窗（confirm），提示弹窗（alert/toast），操作弹窗。</li>
<li>操作弹窗即一些用提供给用户管理的大型弹窗，也可以叫做一个小的‘轻页面’，比如用户要在一个管理组里添加成员，点击添加按钮，页面跳出一个弹窗，里边展示着可以添加的每个。</li>
<li>由于操作弹窗的功能各异，样式也就不用。所以我们一般把确认和提示弹窗做成通用封装到一个全局工具包中，方便随时操作，而操作弹窗则依照实际情况而定。</li>
<li>关于弹窗，不论大小，有一点比较好的体验：当弹窗展示的过程中，我们将页面的宽高都设为100%，即禁止屏幕滚动，防止在弹窗在展示时页面可以滚动，最重要的是如果我们的操作弹窗非常高，以至于超出屏幕高度，这时候肯定要进行滚动展示，当弹窗内出现滚动条时，如果同时页面也有滚动条，这会导致页面不仅看起来非常丑，而且操作上很奇怪。如果我们将页面全屏防止滚动就可以去掉页面滚动条，只保留弹窗内滚动条，这样一个小小的细节使得不论看起来和操作上都比较完美。</li>
</ul>
<h2 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h2><p>字符转义和我们做的项目相关，如果项目不允许用户输入特殊符号，我们做了输入限制，就不会有此问题。如果允许输入特殊字符（这里仍要防止XSS攻击），我们就要做相应处理。</p>
<ul>
<li>我们的项目中，对于特殊字符，后台会一律转码，比如我们在填写表单的时候输入的是&amp;，再次编辑的时候就变成了&amp;.</li>
<li>一般单独封装一个转义的函数，将已知的‘码’都预设在里边，传入被后台转义之后的，返回正常显示的特殊符号，函数比较简单，就不在此费口舌了。</li>
<li>需要注意的两个地方就是列表的数据和编辑某一项的时候，需要转义。</li>
</ul>
<h2 id="字符超长剪裁"><a href="#字符超长剪裁" class="headerlink" title="字符超长剪裁"></a>字符超长剪裁</h2><p>对于列表中某一个字段可能过长，导致页面显示错乱</p>
<ul>
<li><p>添加css字符剪裁<br><img src="https://wangzongxu.github.io/img-cache/blog/ellipsis.png" width="200" alt="ellipsis" align="center"></p>
</li>
<li><p>添加title，让用户能够看到完整的文字。</p>
</li>
</ul>
<h2 id="loading"><a href="#loading" class="headerlink" title="loading"></a>loading</h2><p>关于loading，可以让用户知道操作的进行状态，没有它，用户点击了一个按钮以后，会认为没有反馈。</p>
<ul>
<li>一般我们吧loading分为两种：列表loading 和 操作loading</li>
<li>列表loading就是当用户进入列表页面的时候，或者切换页码的时候，我们应该对用户友好提示‘加载中…’，如果加载成功的话，就隐藏该提示，如果加载失败，就显示错误信息。这里也有一点：列表加载错误的提示建议不使用弹窗形式，因为在加载过程中用户看得是这个列表，我们一般把列表loading就放在列表位置，当失败的时候将loading文字更改一下，用户一目了然,没必要在使用弹窗提示。<br><img src="https://wangzongxu.github.io/img-cache/blog/list-loading.png" width="auto" alt="list-loading" align="center"></li>
<li>操作loading是当用户进行分步创建新的数据的时候，点击下一步的时候，此时一般我们都会进行和后台数据交互，反应可能会有延迟，这是需要给用户一个友好的loading，用意是告诉用户我们正在加载中，别着急。<br><img src="https://wangzongxu.github.io/img-cache/blog/screen-loading1.png" width="400" alt="screen-loading1" align="center"></li>
</ul>
<h2 id="二次封装ajax"><a href="#二次封装ajax" class="headerlink" title="二次封装ajax"></a>二次封装ajax</h2><p>一般我们的接口数据返回格式会和后台约定好下边格式：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"code"</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="attr">"msg"</span>: <span class="string">"执行成功"</span>,</span><br><span class="line">  <span class="attr">"data"</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>code是返回状态，成功为200,注意这个不是网络状态码，只是与后台的约定。</li>
<li>依照以上数据，正常情况我们写ajax的时候，会这样写(jq为例)：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">'xxx'</span>,</span><br><span class="line">  <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123; <span class="comment">// 网络请求成功</span></span><br><span class="line">    <span class="keyword">if</span> (data.code === <span class="number">200</span>) &#123; <span class="comment">// 操作成功</span></span><br><span class="line">      <span class="comment">// do something ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 操作失败</span></span><br><span class="line">      <span class="comment">// do something ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; <span class="comment">// 网络错误</span></span><br><span class="line">    alert(<span class="string">'网络错误，请重试'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>看得出，成功只有一种情况，而错误会有两种情况，即网络错误和后台返回的code不是200的操作错误，<br>如果每个数据请求都这么写，代码会很冗余，举例简单将其封装一下：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myAjax</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  $.ajax(&#123;</span><br><span class="line">    <span class="attr">url</span>: obj.url,</span><br><span class="line">    <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123; <span class="comment">// 网络请求成功</span></span><br><span class="line">      <span class="keyword">if</span> (data.code === <span class="number">200</span>) &#123; <span class="comment">// 操作成功</span></span><br><span class="line">        <span class="comment">// do something ...</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 操作失败</span></span><br><span class="line">        obj.error(data.msg);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; <span class="comment">// 网络错误</span></span><br><span class="line">      obj.error(<span class="string">'网络错误，请重试'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如此一来，我们就可以少处理一个错误：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">myAjax(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">'xxx'</span>,</span><br><span class="line">  <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123; <span class="comment">// 成功</span></span><br><span class="line">    <span class="comment">// do something ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; <span class="comment">// 错误</span></span><br><span class="line">    alert(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h2><p>在用户创建信息的时候，通常我们会进行前端输入验证：</p>
<ul>
<li>建议使用统一验证插件，方便团队中其他人维护的便捷性（vue的话建议<a href="http://vee-validate.logaretm.com/" target="_blank" rel="external">vee-validate</a>）</li>
<li>多人开发要统一错误提示方式和提示用语。</li>
</ul>
<h2 id="日历插件"><a href="#日历插件" class="headerlink" title="日历插件"></a>日历插件</h2><p>列表中和表单中选择时间也是必不可少的</p>
<ul>
<li>用了很多插件，发现无论拓展性，稳定性都不如心意，推荐一款：</li>
<li><a href="http://www.my97.net/index.asp" target="_blank" rel="external">My97 DatePicker</a></li>
</ul>
<h2 id="连点问题"><a href="#连点问题" class="headerlink" title="连点问题"></a>连点问题</h2><p>连点问题是个需要重视的问题，比如用户在创建信息的时候点击完成，用户连点了多次，会造成多次请求，可能导致最终的创建信息失败。</p>
<ul>
<li>在loading中我们就处理过，在点击按钮的时候添加loading效果，其实稍加改动便可解决连点问题</li>
<li>给loading图添加一个大背景，让其全屏展示即可，应为此时的用户再也点不到按钮了，直到得到后台的反馈之后才可再次点击。<br><img src="https://wangzongxu.github.io/img-cache/blog/screen-loading2.png" width="400" alt="screen-loading2" align="center"></li>
</ul>
<p>(完)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;个人总结内容管理系统（CMS）的心得。&lt;br&gt;
    
    </summary>
    
      <category term="前端心得" scheme="https://wangzongxu.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="交互" scheme="https://wangzongxu.github.io/tags/%E4%BA%A4%E4%BA%92/"/>
    
  </entry>
  
  <entry>
    <title>一个轻量的模板引擎</title>
    <link href="https://wangzongxu.github.io/2017/09/21/mini-render/"/>
    <id>https://wangzongxu.github.io/2017/09/21/mini-render/</id>
    <published>2017-09-21T09:09:24.000Z</published>
    <updated>2017-09-21T09:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>一个轻量的模板引擎，语法简洁，性能高效</p>
<a id="more"></a>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install mini-render --save</span><br><span class="line">// 或者</span><br><span class="line">&lt;script src=<span class="string">'miniRender.js'</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="定义一些数据"><a href="#定义一些数据" class="headerlink" title="定义一些数据"></a>定义一些数据</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123;</span><br><span class="line">    <span class="attr">gt</span>: <span class="number">7</span>,</span><br><span class="line">    <span class="attr">lt</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="attr">first</span>: <span class="string">'first'</span>,</span><br><span class="line">    <span class="attr">array</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">    <span class="attr">object</span>: &#123;</span><br><span class="line">         <span class="attr">key1</span>: <span class="string">'value1'</span>,</span><br><span class="line">        <span class="attr">key2</span>: <span class="string">'value2'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">word</span>: <span class="string">'aaaaa'</span>,</span><br><span class="line">    <span class="attr">empty</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 渲染元素模板</span></span><br><span class="line">miniRender.renderElement(<span class="string">'#box'</span>, data)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以返回渲染结果</span></span><br><span class="line"><span class="keyword">var</span> str = miniRender.renderString(<span class="string">'&lt;div&gt;&#123;&#123;word&#125;&#125;&lt;/div&gt;'</span>, data)</span><br><span class="line"><span class="built_in">console</span>.log(str)</span><br></pre></td></tr></table></figure>
<h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; first &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--结果:</span><br><span class="line">    &lt;p&gt;first&lt;/p&gt;</span><br><span class="line">--&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>支持三元运算<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; gt &gt; 8 ? gt : 8 &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--结果:</span><br><span class="line">    &lt;p&gt;8&lt;/p&gt;</span><br><span class="line">--&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; word | toUpperCase &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--结果: </span><br><span class="line">    &lt;p&gt;AAAAA&lt;/p&gt;</span><br><span class="line">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span><br><span class="line"><span class="comment">// 注册过滤器</span></span><br><span class="line">miniRender.filter(<span class="string">'toUpperCase'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val.toUpperCase()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 移除过滤器</span></span><br><span class="line">miniRender.removeFilter(<span class="string">'toUpperCase'</span>)</span><br><span class="line"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>过滤器仅可用在上边这种普通的取值中</p>
</blockquote>
<h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;IF gt &gt; lt&#125;&#125;</span><br><span class="line">    &lt;p&gt;gt比较大:&#123;&#123;gt&#125;&#125;&lt;/p&gt;</span><br><span class="line">&#123;&#123;ELSEIF lt &lt; gt&#125;&#125;</span><br><span class="line">    &lt;p&gt;lt比较小:&#123;&#123;lt&#125;&#125;&lt;/p&gt;</span><br><span class="line">&#123;&#123;ELSE&#125;&#125;</span><br><span class="line">    &lt;p&gt;都不成立&lt;/p&gt;</span><br><span class="line">&#123;&#123;/IF&#125;&#125;</span><br><span class="line"></span><br><span class="line">&lt;!--结果:</span><br><span class="line">    &lt;p&gt;gt比较大:7&lt;/p&gt;</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--数组--&gt;</span></span><br><span class="line">&#123;&#123;EACH item, index IN array&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>索引:&#123;&#123;index&#125;&#125;  值:&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;&#123;/EACH&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--结果:</span><br><span class="line">    &lt;p&gt;索引:0  值:1&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;索引:1  值:2&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;索引:2  值:3&lt;/p&gt;</span><br><span class="line">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--对象--&gt;</span></span><br><span class="line">&#123;&#123;EACH val,key IN object&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>属性名:&#123;&#123;key&#125;&#125;  属性值:&#123;&#123;val&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;&#123;/EACH&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--结果:</span><br><span class="line">    &lt;p&gt;属性名:key1  属性值:value1&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;属性名:key2  属性值:value2&lt;/p&gt;</span><br><span class="line">--&gt;</span></span><br></pre></td></tr></table></figure>
<p>（完）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个轻量的模板引擎，语法简洁，性能高效&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="https://wangzongxu.github.io/categories/JS/"/>
    
    
      <category term="模板引擎" scheme="https://wangzongxu.github.io/tags/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>猜想新零售</title>
    <link href="https://wangzongxu.github.io/2017/09/21/new-retail/"/>
    <id>https://wangzongxu.github.io/2017/09/21/new-retail/</id>
    <published>2017-09-21T09:09:24.000Z</published>
    <updated>2017-09-21T09:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>猜想未来零售行业<br><a id="more"></a></p>
<blockquote>
<p>此系本人大胆设想，仅代表个人对未来的美好憧憬</p>
</blockquote>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景:"></a>背景:</h3><p>在马云提出新零售战略后不久，阿里成为华联超市的第二大股东。</p>
<h3 id="华联超市简介"><a href="#华联超市简介" class="headerlink" title="华联超市简介:"></a>华联超市简介:</h3><p>华联超市股份有限公司是上海百联的二级公司。截至2016年12月31日，联华超市及其附属公司的总门店数目已经达到3618家，遍布全国19个省份及直辖市。</p>
<h3 id="新零售的“新”"><a href="#新零售的“新”" class="headerlink" title="新零售的“新”"></a>新零售的“新”</h3><p>以个人信用评估和消费习惯为基础，挖掘客户需求，提升客户服务体验，改变传统消费和服务概念。降低商家库存积压趋近0。</p>
<h3 id="消费场景模拟"><a href="#消费场景模拟" class="headerlink" title="消费场景模拟:"></a>消费场景模拟:</h3><p>王先生的家附近有一家华联超市，家里的生活用品一般都会在这家超市购买，应店员邀请，王先生关注了该店的生活号。<br>某天王先生收到一条消息推送，消息向王先生推荐了几个品牌的食盐。王先生不以为然，当他准备做饭的时候，发现盐基本没有了，这才回想起收到的消息，打开消息详情，里边有“30分钟内送货上门”和“门店自取(由于您的距离较近，建议自取)”，的两个选项。</p>
<p>王先生选择了自取，并在线下单支付了一袋盐的价钱。</p>
<p>王先生来到超市，走到“自取柜台”，此时王先生还没开口，服务员就热情的将王先生下单的那带盐拿了过来，“王先生，这是您订购的商品，如果您还有其他需要可以去五自选区，这个我们先帮您保存”，服务员微笑着说说。“好的，正好我还有要买的东西”。</p>
<p>王先生走到自选区，打算买一些菜和饮料，他打开支付宝里边的超市板块，选择了这个超市，手机上提示着‘请在您选购的过程中，将商品码扫描’。王先生拿了一瓶可乐，扫码之后手机上显示着‘已选购商品’:12.5L可口可乐，数量1瓶。总计6元。来到蔬菜区，服务员帮王先生称了两个土豆和两个西红柿。王先生扫描了称上面显示了二维码。</p>
<p>由于王先生信用比较高，他在手机上选择了自行结账，付了款。他看到结账区人的在排队，心想:‘还好我信用比较好’。<br>王先生去自取柜台拿了之前买好的盐，满意的回了家。</p>
<h3 id="商家场景模拟"><a href="#商家场景模拟" class="headerlink" title="商家场景模拟:"></a>商家场景模拟:</h3><p>······</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;猜想未来零售行业&lt;br&gt;
    
    </summary>
    
      <category term="闲谈" scheme="https://wangzongxu.github.io/categories/%E9%97%B2%E8%B0%88/"/>
    
    
      <category term="草稿" scheme="https://wangzongxu.github.io/tags/%E8%8D%89%E7%A8%BF/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="https://wangzongxu.github.io/2017/09/21/regexp/"/>
    <id>https://wangzongxu.github.io/2017/09/21/regexp/</id>
    <published>2017-09-21T09:09:24.000Z</published>
    <updated>2017-09-21T09:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>在常见的字符串检索或替换中，我们需要提供一种模式表示检索工替换的规则 正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串 判断正则是否能匹配给定参数字符串<br><a id="more"></a></p>
<h3 id="1-什么是正则表达式"><a href="#1-什么是正则表达式" class="headerlink" title="1. 什么是正则表达式"></a>1. 什么是正则表达式</h3><p>　　在常见的字符串检索或替换中，我们需要提供一种模式表示检索工替换的规则 正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串 判断正则是否能匹配给定参数字符串</p>
<h3 id="2-JS正则中的特殊字符"><a href="#2-JS正则中的特殊字符" class="headerlink" title="2. JS正则中的特殊字符"></a>2. JS正则中的特殊字符</h3><ul>
<li><p>需要转义的特殊字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( [ &#123; \ ^ $ | ) ? * + .</span><br></pre></td></tr></table></figure>
</li>
<li><p>特殊字符说明</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>特殊字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>$</td>
<td>匹配输入字符串的结尾位置。请使用 \$</td>
</tr>
<tr>
<td>( )</td>
<td>标记一个子表达式的开始和结束位置,请使用\( \)</td>
</tr>
<tr>
<td>*</td>
<td>匹配前面的子表达式零次或多次,请使用 \*</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式一次或多次,请使用 \+</td>
</tr>
<tr>
<td>.</td>
<td>匹配除换行符\n之外的任何单字符,请使用 \.</td>
</tr>
<tr>
<td>[]</td>
<td>标记一个中括号表达式的开始,请使用 \[ 或 \]</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面的子表达式零次或一次,请使用 \?</td>
</tr>
<tr>
<td>\</td>
<td>将下一个字符标记为或特殊字符,请使用 \\</td>
</tr>
<tr>
<td>^</td>
<td>匹配输入字符串的开始位置,请使用 \^</td>
</tr>
<tr>
<td>{}</td>
<td>标记限定符表达式的开始。请使用 \{</td>
</tr>
<tr>
<td>¦</td>
<td>指明两项之间的一个选择,请使用 \¦</td>
</tr>
</tbody>
</table>
<h3 id="3-预定义的特殊字符"><a href="#3-预定义的特殊字符" class="headerlink" title="3. 预定义的特殊字符"></a>3. 预定义的特殊字符</h3><table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>\t</td>
<td>制表符</td>
</tr>
<tr>
<td>\n</td>
<td>制表符</td>
</tr>
<tr>
<td>\r</td>
<td>回车符</td>
</tr>
<tr>
<td>\f</td>
<td>换页符</td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表符</td>
</tr>
<tr>
<td>\0</td>
<td>空字符</td>
</tr>
<tr>
<td>\x0B</td>
<td>垂直tab</td>
</tr>
</tbody>
</table>
<h3 id="4-范围符号"><a href="#4-范围符号" class="headerlink" title="4. 范围符号"></a>4. 范围符号</h3><table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>[]</td>
<td>字符范围</td>
<td>[a-z] [0-9] [a-z0-9]</td>
</tr>
<tr>
<td>[^]</td>
<td>字符范围以外</td>
<td>[^a-z]</td>
</tr>
<tr>
<td>^</td>
<td>行首</td>
<td>^zfpx</td>
</tr>
<tr>
<td>$</td>
<td>行尾</td>
<td>zfpx$</td>
</tr>
<tr>
<td>\b</td>
<td>零宽单词边界</td>
<td>\bhello</td>
</tr>
<tr>
<td>\B</td>
<td>非\b</td>
<td>\Bhello</td>
</tr>
</tbody>
</table>
<h3 id="5-预定义类"><a href="#5-预定义类" class="headerlink" title="5. 预定义类"></a>5. 预定义类</h3><table>
<thead>
<tr>
<th>字符</th>
<th>等同于</th>
<th>含义</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>[^\n\r]</td>
<td>任意字符</td>
<td>/…/.test(‘abc’)</td>
</tr>
<tr>
<td>\d</td>
<td>[0-9]</td>
<td>数字0-9</td>
<td>/\d\d\d/.test(‘123’)</td>
</tr>
<tr>
<td>\D</td>
<td>[^0-9]</td>
<td>非\d,即不是数字0-9</td>
<td>/\D\D\D/.test(‘abc’)</td>
</tr>
<tr>
<td>\w</td>
<td>[a-zA-Z_0-9]</td>
<td>数字0-9、字母a-z及a-z、下划线</td>
<td>/\w\w/.test(‘a_’)</td>
</tr>
<tr>
<td>\W</td>
<td>[^a-zA-Z_0-9]</td>
<td>非\W</td>
<td>/\W\W/.test(‘@#’)</td>
</tr>
<tr>
<td>\s</td>
<td>[\t\n\x0B\f\r]</td>
<td>空格、TAB、换页符、换行符</td>
<td>/\sabc/.test(‘ abc’)</td>
</tr>
<tr>
<td>\S</td>
<td>[^\t\n\x0B\f\r]</td>
<td>非\s</td>
<td>/\Sd/.test(‘a d’)</td>
</tr>
</tbody>
</table>
<h3 id="6-分组"><a href="#6-分组" class="headerlink" title="6. 分组"></a>6. 分组</h3><table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>(x)</td>
<td>分组，并记录匹配到的字符串</td>
<td>/(abc)/</td>
</tr>
<tr>
<td>\n</td>
<td>表示使用分组符(x)匹配到的字符串</td>
<td>/(abc)\1/.test(‘abcabc’)</td>
</tr>
<tr>
<td>(?:x)</td>
<td>仅分组不捕获</td>
<td>/(?:abc)(def)\1/.test(‘abcdefdef’);</td>
</tr>
</tbody>
</table>
<h3 id="7-重复"><a href="#7-重复" class="headerlink" title="7. 重复"></a>7. 重复</h3><table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>a*,a+</td>
<td>重复次数&gt;=0,重复次数&gt;=1 贪婪算法</td>
<td>/abc*.test(‘abccc’)/</td>
</tr>
<tr>
<td>a*? a+?</td>
<td>同a*,a+ 非贪婪算法</td>
<td>/abc*/.test(‘ab’)</td>
</tr>
<tr>
<td>a?</td>
<td>出现0次或1次</td>
<td>/a?bc/.test(‘ab’)</td>
</tr>
<tr>
<td>a¦b</td>
<td>a或者b</td>
<td>/a¦b/.test(‘a’)</td>
</tr>
<tr>
<td>a{n},a{n,},a{n,m}</td>
<td>重复n次，重复&gt;=n次,重复n&lt;=x&lt;=m</td>
<td>/a{2}/.test(‘aa’)</td>
</tr>
</tbody>
</table>
<h3 id="8-前瞻-预查"><a href="#8-前瞻-预查" class="headerlink" title="8. 前瞻(预查)"></a>8. 前瞻(预查)</h3><table>
<thead>
<tr>
<th>正则</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>(?=exp)</td>
<td>正向前瞻</td>
<td>匹配后面是exp的位置</td>
</tr>
<tr>
<td>(?!exp)</td>
<td>负向前瞻</td>
<td>匹配后面不是exp的位置</td>
</tr>
<tr>
<td>(?:exp)</td>
<td>整体匹配</td>
<td>只匹配不想被捕获的时候使用,不能使用 反向引用</td>
</tr>
</tbody>
</table>
<hr>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="string">'abbcdefbg'</span>.match(<span class="regexp">/b+?(?=g)/g</span>); <span class="comment">// ['b'] 前面符合正则</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="string">'abbcdefbg'</span>.match(<span class="regexp">/b+(?!g)/g</span>); <span class="comment">// ['bb'] 前面不符合正则</span></span><br></pre></td></tr></table></figure>
<h3 id="9-标志位"><a href="#9-标志位" class="headerlink" title="9. 标志位"></a>9. 标志位</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两种使用方法：</span></span><br><span class="line">/abc/img.test(<span class="string">'ABC'</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">RegExp</span>(<span class="string">'abc'</span>,<span class="string">'img'</span>);</span><br><span class="line"></span><br><span class="line"><span class="regexp">/abc/g</span>.global <span class="comment">//true</span></span><br><span class="line">/abc/i.ignoreCase <span class="comment">//true</span></span><br><span class="line">/abc/m.multiline <span class="comment">//true</span></span><br><span class="line">/abc/g.source <span class="comment">//true 返回正则的内容</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>global</td>
<td>匹配所有的情况</td>
</tr>
<tr>
<td>ignoreCase</td>
<td>忽略大小写</td>
</tr>
<tr>
<td>multiline</td>
<td>跨行匹配</td>
</tr>
</tbody>
</table>
<h3 id="10-RegExp对象上的方法"><a href="#10-RegExp对象上的方法" class="headerlink" title="10. RegExp对象上的方法"></a>10. RegExp对象上的方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>含义</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>compile</td>
<td>可以改变正则的内容</td>
<td>var reg = /abc/;reg.compile(‘def’);reg.test(‘def’);//true</td>
</tr>
<tr>
<td>exec</td>
<td>用正则匹配字符串获取匹配结果</td>
<td>/abc/.exec(‘abcdef’); // “abc”</td>
</tr>
<tr>
<td>test</td>
<td>如果匹配返回true</td>
<td>/ab/.test(‘ab’)</td>
</tr>
<tr>
<td>toString</td>
<td>返回正则内容</td>
<td>/ab/.toString()</td>
</tr>
</tbody>
</table>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//exec例子:</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"school school"</span>;</span><br><span class="line"><span class="keyword">var</span> patt = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"school"</span>,<span class="string">'g'</span>);</span><br><span class="line"><span class="keyword">var</span> result;</span><br><span class="line"><span class="keyword">while</span> ((result = patt.exec(str)) != <span class="literal">null</span>)  &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">    <span class="built_in">console</span>.log(patt.lastIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-字符串的正则方法"><a href="#11-字符串的正则方法" class="headerlink" title="11. 字符串的正则方法"></a>11. 字符串的正则方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>含义</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>search</td>
<td>查找正则匹配对应的索引</td>
<td>‘abcdefabc’.search(/(abc)\1/)</td>
</tr>
<tr>
<td>replace</td>
<td>替换</td>
<td>‘aabbbcc’.replace(/b+?/); //aa1bbcc</td>
</tr>
<tr>
<td>match</td>
<td>匹配</td>
<td>‘aabbbccbbb’.match(/b+/g) //[“bbb”, “bbb”]</td>
</tr>
<tr>
<td>split</td>
<td>分割字符串</td>
<td>‘aabbbcc’.split(/b+/); // [“aa”,”cc”]</td>
</tr>
</tbody>
</table>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//match例子:</span></span><br><span class="line"><span class="keyword">var</span> path = <span class="string">'/users/:id/:name'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(path.match(<span class="regexp">/:(\w+)/</span>));</span><br><span class="line"><span class="built_in">console</span>.log(path.match(<span class="regexp">/:(\w+)/g</span>));<span class="comment">//如果加g的话不会捕获小分组内容</span></span><br><span class="line"><span class="comment">//replace例子:</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'/users/:id/:name'</span>.replace(<span class="regexp">/:\w+/g</span>,<span class="string">'(\\w+)'</span>));</span><br></pre></td></tr></table></figure>
<h3 id="12-参考"><a href="#12-参考" class="headerlink" title="12. 参考"></a>12. 参考</h3><ul>
<li><a href="http://www.cnblogs.com/rubylouvre/archive/2010/03/09/1681222.html" target="_blank" rel="external">javascript正则表达式</a></li>
<li><a href="https://jex.im/regulex" target="_blank" rel="external">Regulex</a></li>
<li><a href="https://regexper.com/" target="_blank" rel="external">正则表达式可视化工具</a></li>
<li><a href="http://www.w3school.com.cn/jsref/jsref_obj_regexp.asp" target="_blank" rel="external">w3school</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在常见的字符串检索或替换中，我们需要提供一种模式表示检索工替换的规则 正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串 判断正则是否能匹配给定参数字符串&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="https://wangzongxu.github.io/categories/JS/"/>
    
    
      <category term="正则" scheme="https://wangzongxu.github.io/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>Restful</title>
    <link href="https://wangzongxu.github.io/2017/09/21/resuful/"/>
    <id>https://wangzongxu.github.io/2017/09/21/resuful/</id>
    <published>2017-09-21T09:09:24.000Z</published>
    <updated>2017-09-21T09:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>理解RESTful架构 &amp; RESTful API 设计指南<br><a id="more"></a></p>
<p><a href="http://www.ruanyifeng.com/blog/2011/09/restful" target="_blank" rel="external">理解RESTful架构</a><br><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="external">RESTful API 设计指南</a></p>
<blockquote>
<p>摘自：阮一峰网络日志</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;理解RESTful架构 &amp;amp; RESTful API 设计指南&lt;br&gt;
    
    </summary>
    
      <category term="剪切板" scheme="https://wangzongxu.github.io/categories/%E5%89%AA%E5%88%87%E6%9D%BF/"/>
    
    
      <category term="网络" scheme="https://wangzongxu.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
