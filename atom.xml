<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zongxu&#39;s Blog</title>
  <subtitle>The top class of virtue is like water,which benefits all things without any demands for return.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wangzongxu.github.io/"/>
  <updated>2018-03-02T06:45:23.065Z</updated>
  <id>https://wangzongxu.github.io/</id>
  
  <author>
    <name>wangzongxu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>雅虎优化技巧（摘）</title>
    <link href="https://wangzongxu.github.io/2018/03/02/yahoo34/"/>
    <id>https://wangzongxu.github.io/2018/03/02/yahoo34/</id>
    <published>2018-03-02T06:45:23.064Z</published>
    <updated>2018-03-02T06:45:23.065Z</updated>
    
    <content type="html"><![CDATA[<p>雅虎：网站页面性能优化的34条建议：<br><a id="more"></a></p>
<ol>
<li><p>尽量减少HTTP请求次数</p>
<ul>
<li>终端用户响应的时间中，有80%用于下载各项内容。这部分时间包括下载页面中的图像、样式表、脚本、Flash等。通过减少页面中的元素可以减少HTTP请求的次数。这是提高网页速度的关键步骤。</li>
<li>减少页面组件的方法其实就是简化页面设计。那么有没有一种方法既能保持页面内容的丰富性又能达到加快响应时间的目的呢？这里有几条减少HTTP请求次数同时又可能保持页面内容丰富的技术。</li>
<li>合并文件是通过把所有的脚本放到一个文件中来减少HTTP请求的方法，如可以简单地把所有的CSS文件都放入一个样式表中。当脚本或者样式表在不同页面中使用时需要做不同的修改，这可能会相对麻烦点，但即便如此也要把这个方法作为改善页面性能的重要一步。</li>
<li>CSS Sprites是减少图像请求的有效方法。把所有的背景图像都放到一个图片文件中，然后通过CSS的background-image和background-position属性来显示图片的不同部分；</li>
<li>图片地图是把多张图片整合到一张图片中。虽然文件的总体大小不会改变，但是可以减少HTTP请求次数。图片地图只有在图片的所有组成部分在页面中是紧挨在一起的时候才能使用，如导航栏。确定图片的坐标和可能会比较繁琐且容易出错，同时使用图片地图导航也不具有可读性，因此不推荐这种方法；</li>
<li>内联图像是使用data:URL scheme的方法把图像数据加载页面中。这可能会增加页面的大小。把内联图像放到样式表（可缓存）中可以减少HTTP请求同时又避免增加页面文件的大小。但是内联图像现在还没有得到主流浏览器的支持。</li>
<li>减少页面的HTTP请求次数是你首先要做的一步。这是改进首次访问用户等待时间的最重要的方法。如同Tenni Theurer的他的博客Browser Cahe Usage - Exposed!中所说，HTTP请求在无缓存情况下占去了40%到60%的响应时间。让那些初次访问你网站的人获得更加快速的体验吧！</li>
</ul>
</li>
<li><p>减少DNS查找次数</p>
<ul>
<li>域名系统（DNS）提供了域名和IP的对应关系，就像电话本中人名和他们的电话号码的关系一样。当你在浏览器地址栏中输入www.dudo.org时，DNS解析服务器就会返回这个域名对应的IP地址。DNS解析的过程同样也是需要时间的。一般情况下返回给定域名对应的IP地址会花费20到120毫秒的时间。而且在这个过程中浏览器什么都不会做直到DNS查找完毕。</li>
<li>缓存DNS查找可以改善页面性能。这种缓存需要一个特定的缓存服务器，这种服务器一般属于用户的ISP提供商或者本地局域网控制，但是它同样会在用户使用的计算机上产生缓存。DNS信息会保留在操作系统的DNS缓存中（微软Windows系统中DNS Client Service）。大多数浏览器有独立于操作系统以外的自己的缓存。由于浏览器有自己的缓存记录，因此在一次请求中它不会受到操作系统的影响。</li>
<li>Internet Explorer默认情况下对DNS查找记录的缓存时间为30分钟，它在注册表中的键值为DnsCacheTimeout。Firefox对DNS的查找记录缓存时间为1分钟，它在配置文件中的选项为network.dnsCacheExpiration（Fasterfox把这个选项改为了1小时）。</li>
<li>当客户端中的DNS缓存都为空时（浏览器和操作系统都为空），DNS查找的次数和页面中主机名的数量相同。这其中包括页面中URL、图片、脚本文件、样式表、Flash对象等包含的主机名。减少主机名的数量可以减少DNS查找次数。</li>
<li>减少主机名的数量还可以减少页面中并行下载的数量。减少DNS查找次数可以节省响应时间，但是减少并行下载却会增加响应时间。我的指导原则是把这些页面中的内容分割成至少两部分但不超过四部分。这种结果就是在减少DNS查找次数和保持较高程度并行下载两者之间的权衡了。</li>
</ul>
</li>
<li><p>避免跳转</p>
<ul>
<li><p>跳转是使用301和302代码实现的。下面是一个响应代码为301的HTTP头：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 301 Moved Permanently</span><br><span class="line">Location: http://example.com/newuri</span><br><span class="line">Content-Type: text/html</span><br></pre></td></tr></table></figure>
</li>
<li><p>浏览器会把用户指向到Location中指定的URL。头文件中的所有信息在一次跳转中都是必需的，内容部分可以为空。不管他们的名称，301和302响应都不会被缓存除非增加一个额外的头选项，如Expires或者Cache-Control来指定它缓存。meat元素的刷新标签和JavaScript也可以实现URL的跳转，但是如果你必须要跳转的时候，最好的方法就是使用标准的3XXHTTP状态代码，这主要是为了确保“后退”按钮可以正确地使用。</p>
</li>
<li>但是要记住跳转会降低用户体验。在用户和HTML文档中间增加一个跳转，会拖延页面中所有元素的显示，因为在HTML文件被加载前任何文件（图像、Flash等）都不会被下载。</li>
<li>有一种经常被网页开发者忽略却往往十分浪费响应时间的跳转现象。这种现象发生在当URL本该有斜杠（/）却被忽略掉时。例如，当我们要访问<a href="http://astrology.yahoo.com/astrology" target="_blank" rel="external">http://astrology.yahoo.com/astrology</a> 时，实际上返回的是一个包含301代码的跳转，它指向的是<a href="http://astrology.yahoo.com/astrology/" target="_blank" rel="external">http://astrology.yahoo.com/astrology/</a>  （注意末尾的斜杠）。在Apache服务器中可以使用Alias 或者 mod_rewrite或者the DirectorySlash来避免。</li>
<li>连接新网站和旧网站是跳转功能经常被用到的另一种情况。这种情况下往往要连接网站的不同内容然后根据用户的不同类型（如浏览器类型、用户账号所属类型）来进行跳转。使用跳转来实现两个网站的切换十分简单，需要的代码量也不多。尽管使用这种方法对于开发者来说可以降低复杂程度，但是它同样降低用户体验。一个可替代方法就是如果两者在同一台服务器上时使用Alias和mod_rewrite和实现。如果是因为域名的不同而采用跳转，那么可以通过使用Alias或者mod_rewirte建立CNAME（保存一个域名和另外一个域名之间关系的DNS记录）来替代。</li>
</ul>
</li>
<li><p>可缓存的AJAX</p>
<ul>
<li>Ajax经常被提及的一个好处就是由于其从后台服务器传输信息的异步性而为用户带来的反馈的即时性。但是，使用Ajax并不能保证用户不会在等待异步的JavaScript和XML响应上花费时间。在很多应用中，用户是否需要等待响应取决于Ajax如何来使用。例如，在一个基于Web的Email客户端中，用户必须等待Ajax返回符合他们条件的邮件查询结果。记住一点，“异步”并不异味着“即时”，这很重要。</li>
<li><p>为了提高性能，优化Ajax响应是很重要的。提高Ajxa性能的措施中最重要的方法就是使响应具有可缓存性，具体的讨论可以查看Add an Expires or a Cache-Control Header。其它的几条规则也同样适用于Ajax：</p>
<blockquote>
<p>Gizp压缩文件<br>减少DNS查找次数<br>精简JavaScript<br>避免跳转<br>配置ETags</p>
</blockquote>
</li>
<li><p>让我们来看一个例子：一个Web2.0的Email客户端会使用Ajax来自动完成对用户地址薄的下载。如果用户在上次使用过Email web应用程序后没有对地址薄作任何的修改，而且Ajax响应通过Expire或者Cacke-Control头来实现缓存，那么就可以直接从上一次的缓存中读取地址薄了。必须告知浏览器是使用缓存中的地址薄还是发送一个新的请求。这可以通过为读取地址薄的Ajax URL增加一个含有上次编辑时间的时间戳来实现，例如，&amp;t=11900241612等。如果地址薄在上次下载后没有被编辑过，时间戳就不变，则从浏览器的缓存中加载从而减少了一次HTTP请求过程。如果用户修改过地址薄，时间戳就会用来确定新的URL和缓存响应并不匹配，浏览器就会重要请求更新地址薄。</p>
</li>
<li>即使你的Ajxa响应是动态生成的，哪怕它只适用于一个用户，那么它也应该被缓存起来。这样做可以使你的Web2.0应用程序更加快捷。</li>
</ul>
</li>
<li><p>推迟加载内容</p>
<ul>
<li>你可以仔细看一下你的网页，问问自己“哪些内容是页面呈现时所必需首先加载的？哪些内容和结构可以稍后再加载？</li>
<li>把整个过程按照onload事件分隔成两部分，JavaScript是一个理想的选择。例如，如果你有用于实现拖放和动画的JavaScript，那么它就以等待稍后加载，因为页面上的拖放元素是在初始化呈现之后才发生的。其它的例如隐藏部分的内容（用户操作之后才显现的内容）和处于折叠部分的图像也可以推迟加载</li>
<li>工具可以节省你的工作量：YUI Image Loader可以帮你推迟加载折叠部分的图片，YUI Get utility是包含JS和 CSS的便捷方法。比如你可以打开Firebug的Net选项卡看一下Yahoo的首页。</li>
<li>当性能目标和其它网站开发实践一致时就会相得益彰。这种情况下，通过程序提高网站性能的方法告诉我们，在支持JavaScript的情况下，可以先去除用户体验，不过这要保证你的网站在没有JavaScript也可以正常运行。在确定页面运行正常后，再加载脚本来实现如拖放和动画等更加花哨的效果。</li>
</ul>
</li>
<li><p>预加载</p>
<ul>
<li>预加载和后加载看起来似乎恰恰相反，但实际上预加载是为了实现另外一种目标。预加载是在浏览器空闲时请求将来可能会用到的页面内容（如图像、样式表和脚本）。使用这种方法，当用户要访问下一个页面时，页面中的内容大部分已经加载到缓存中了，因此可以大大改善访问速度。</li>
<li>下面提供了几种预加载方法：<ul>
<li>无条件加载：触发onload事件时，直接加载额外的页面内容。以Google.com为例，你可以看一下它的spirit image图像是怎样在onload中加载的。这个spirit image图像在google.com主页中是不需要的，但是却可以在搜索结果页面中用到它。</li>
<li>有条件加载：根据用户的操作来有根据地判断用户下面可能去往的页面并相应的预加载页面内容。在search.yahoo.com中你可以看到如何在你输入内容时加载额外的页面内容。</li>
<li>有预期的加载：载入重新设计过的页面时使用预加载。这种情况经常出现在页面经过重新设计后用户抱怨“新的页面看起来很酷，但是却比以前慢”。问题可能出在用户对于你的旧站点建立了完整的缓存，而对于新站点却没有任何缓存内容。因此你可以在访问新站之前就加载一部内容来避免这种结果的出现。在你的旧站中利用浏览器的空余时间加载新站中用到的图像的和脚本来提高访问速度。</li>
</ul>
</li>
</ul>
</li>
<li><p>减少DOM元素数量</p>
<ul>
<li>一个复杂的页面意味着需要下载更多数据，同时也意味着JavaScript遍历DOM的效率越慢。比如当你增加一个事件句柄时在500和5000个DOM元素中循环效果肯定是不一样的。</li>
<li>大量的DOM元素的存在意味着页面中有可以不用移除内容只需要替换元素标签就可以精简的部分。你在页面布局中使用表格了吗？你有没有仅仅为了布局而引入更多的div元素呢？也许会存在一个适合或者在语意是更贴切的标签可以供你使用。</li>
<li>YUI CSS utilities可以给你的布局带来巨大帮助：grids.css可以帮你实现整体布局，font.css和reset.css可以帮助你移除浏览器默认格式。它提供了一个重新审视你页面中标签的机会，比如只有在语意上有意义时才使用div，而不是因为它具有换行效果才使用它。</li>
<li><p>DOM元素数量很容易计算出来，只需要在Firebug的控制台内输入：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'*'</span>).length</span><br></pre></td></tr></table></figure>
</li>
<li><p>那么多少个DOM元素算是多呢？这可以对照有很好标记使用的类似页面。比如Yahoo!主页是一个内容非常多的页面，但是它只使用了700个元素（HTML标签）。</p>
</li>
</ul>
</li>
<li><p>根据域名划分页面内容</p>
<ul>
<li>把页面内容划分成若干部分可以使你最大限度地实现平行下载。由于DNS查找带来的影响你首先要确保你使用的域名数量在2个到4个之间。例如，你可以把用到的HTML内容和动态内容放在www.example.org上，而把页面各种组件（图片、脚本、CSS)分别存放在statics1.example.org和statics.example.org上。</li>
<li>你可在Tenni Theurer和Patty Chi合写的文章Maximizing Parallel Downloads in the Carpool Lane找到更多相关信息。</li>
</ul>
</li>
<li><p>使iframe的数量最小</p>
<ul>
<li>ifrmae元素可以在父文档中插入一个新的HTML文档。了解iframe的工作理然后才能更加有效地使用它，这一点很重要。</li>
<li>iframe优点：<br>解决加载缓慢的第三方内容如图标和广告等的加载问题<br>Security sandbox并行加载脚本</li>
<li>iframe的缺点：<br>即时内容为空，加载也需要时间会阻止页面加载<br>没有语意</li>
</ul>
</li>
<li><p>不要出现404错误</p>
<ul>
<li>HTTP请求时间消耗是很大的，因此使用HTTP请求来获得一个没有用处的响应（例如404没有找到页面）是完全没有必要的，它只会降低用户体验而不会有一点好处。</li>
<li>有些站点把404错误响应页面改为“你是不是要找<em>*</em>”，这虽然改进了用户体验但是同样也会浪费服务器资源（如数据库等）。最糟糕的情况是指向外部JavaScript的链接出现问题并返回404代码。首先，这种加载会破坏并行加载；其次浏览器会把试图在返回的404响应内容中找到可能有用的部分当作JavaScript代码来执行。</li>
</ul>
</li>
<li><p>使用内容分发网络</p>
<ul>
<li>用户与你网站服务器的接近程度会影响响应时间的长短。把你的网站内容分散到多个、处于不同地域位置的服务器上可以加快下载速度。但是首先我们应该做些什么呢？</li>
<li>按地域布置网站内容的第一步并不是要尝试重新架构你的网站让他们在分发服务器上正常运行。根据应用的需求来改变网站结构，这可能会包括一些比较复杂的任务，如在服务器间同步Session状态和合并数据库更新等。要想缩短用户和内容服务器的距离，这些架构步骤可能是不可避免的。</li>
<li>要记住，在终端用户的响应时间中有80%到90%的响应时间用于下载图像、样式表、脚本、Flash等页面内容。这就是网站性能黄金守则。和重新设计你的应用程序架构这样比较困难的任务相比，首先来分布静态内容会更好一点。这不仅会缩短响应时间，而且对于内容分发网络来说它更容易实现。</li>
<li>内容分发网络（Content Delivery Network，CDN）是由一系列分散到各个不同地理位置上的Web服务器组成的，它提高了网站内容的传输速度。用于向用户传输内容的服务器主要是根据和用户在网络上的靠近程度来指定的。例如，拥有最少网络跳数（network hops）和响应速度最快的服务器会被选定。</li>
<li>一些大型的网络公司拥有自己的CDN，但是使用像Akamai Technologies，Mirror Image Internet， 或者Limelight Networks这样的CDN服务成本却非常高。对于刚刚起步的企业和个人网站来说，可能没有使用CDN的成本预算，但是随着目标用户群的不断扩大和更加全球化，CDN就是实现快速响应所必需的了。以Yahoo来说，他们转移到CDN上的网站程序静态内容节省了终端用户20%以上的响应时间。使用CDN是一个只需要相对简单地修改代码实现显著改善网站访问速度的方法。</li>
</ul>
</li>
<li><p>为文件头指定Expires或Cache-Control这条守则包括两方面的内容：</p>
<ul>
<li>对于静态内容：设置文件头过期时间Expires的值为“Never expire”（永不过期）</li>
<li>对于动态内容：使用恰当的Cache-Control文件头来帮助浏览器进行有条件的请求</li>
<li>网页内容设计现在越来越丰富，这就意味着页面中要包含更多的脚本、样式表、图片和Flash。第一次访问你页面的用户就意味着进行多次的HTTP请求，但是通过使用Expires文件头就可以使这样内容具有缓存性。它避免了接下来的页面访问中不必要的HTTP请求。Expires文件头经常用于图像文件，但是应该在所有的内容都使用他，包括脚本、样式表和Flash等。</li>
<li>浏览器（和代理）使用缓存来减少HTTP请求的大小和次数以加快页面访问速度。Web服务器在HTTP响应中使用Expires文件头来告诉客户端内容需要缓存多长时间。下面这个例子是一个较长时间的Expires文件头，它告诉浏览器这个响应直到2010年4月15日才过期。</li>
<li>Expires: Thu, 15 Apr 2010 20:00:00 GMT</li>
<li>如果你使用的是Apache服务器，可以使用ExpiresDefault来设定相对当前日期的过期时间。下面这个例子是使用ExpiresDefault来设定请求时间后10年过期的文件头：</li>
<li>ExpiresDefault “access plus 10 years”</li>
<li>要切记，如果使用了Expires文件头，当页面内容改变时就必须改变内容的文件名。依Yahoo!来说我们经常使用这样的步骤：在内容的文件名中加上版本号，如yahoo_2.0.6.js。</li>
<li>使用Expires文件头只有会在用户已经访问过你的网站后才会起作用。当用户首次访问你的网站时这对减少HTTP请求次数来说是无效的，因为浏览器的缓存是空的。因此这种方法对于你网站性能的改进情况要依据他们“预缓存”存在时对你页面的点击频率（“预缓存”中已经包含了页面中的所有内容）。Yahoo!建立了一套测量方法，我们发现所有的页面浏览量中有75~85%都有“预缓存”。通过使用Expires文件头，增加了缓存在浏览器中内容的数量，并且可以在用户接下来的请求中再次使用这些内容，这甚至都不需要通过用户发送一个字节的请求。</li>
</ul>
</li>
<li><p>Gzip压缩文件内容</p>
<ul>
<li>网络传输中的HTTP请求和应答时间可以通过前端机制得到显著改善。的确，终端用户的带宽、互联网提供者、与对等交换点的靠近程度等都不是网站开发者所能决定的。但是还有其他因素影响着响应时间。通过减小HTTP响应的大小可以节省HTTP响应时间。</li>
<li>从HTTP/1.1开始，web客户端都默认支持HTTP请求中有Accept-Encoding文件头的压缩格式：   </li>
<li>Accept-Encoding: gzip, deflate</li>
<li>如果web服务器在请求的文件头中检测到上面的代码，就会以客户端列出的方式压缩响应内容。Web服务器把压缩方式通过响应文件头中的Content-Encoding来返回给浏览器。</li>
<li>Content-Encoding: gzip</li>
<li>Gzip是目前最流行也是最有效的压缩方式。这是由GNU项目开发并通过RFC 1952来标准化的。另外仅有的一个压缩格式是deflate，但是它的使用范围有限效果也稍稍逊色。</li>
<li>Gzip大概可以减少70%的响应规模。目前大约有90%通过浏览器传输的互联网交换支持gzip格式。如果你使用的是Apache，gzip模块配置和你的版本有关：Apache 1.3使用mod_zip，而Apache 2.x使用moflate。</li>
<li>浏览器和代理都会存在这样的问题：浏览器期望收到的和实际接收到的内容会存在不匹配的现象。幸好，这种特殊情况随着旧式浏览器使用量的减少在减少。Apache模块会通过自动添加适当的Vary响应文件头来避免这种状况的出现。</li>
<li>服务器根据文件类型来选择需要进行gzip压缩的文件，但是这过于限制了可压缩的文件。大多数web服务器会压缩HTML文档。对脚本和样式表进行压缩同样也是值得做的事情，但是很多web服务器都没有这个功能。实际上，压缩任何一个文本类型的响应，包括XML和JSON，都值得的。图像和PDF文件由于已经压缩过了所以不能再进行gzip压缩。如果试图gizp压缩这些文件的话不但会浪费CPU资源还会增加文件的大小。</li>
<li>Gzip压缩所有可能的文件类型是减少文件体积增加用户体验的简单方法。</li>
</ul>
</li>
<li><p>配置ETag</p>
<ul>
<li><p>Entity tags（ETags）（实体标签）是web服务器和浏览器用于判断浏览器缓存中的内容和服务器中的原始内容是否匹配的一种机制（“实体”就是所说的“内容”，包括图片、脚本、样式表等）。增加ETag为实体的验证提供了一个比使用“last-modified date（上次编辑时间）”更加灵活的机制。Etag是一个识别内容版本号的唯一字符串。唯一的格式限制就是它必须包含在双引号内。原始服务器通过含有ETag文件头的响应指定页面内容的ETag。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Last-Modified: Tue, 12 Dec 2006 03:03:59 GMT</span><br><span class="line">ETag: &quot;10c24bc-4ab-457e1c1f&quot;</span><br><span class="line">Content-Length: 12195</span><br></pre></td></tr></table></figure>
<p>稍后，如果浏览器要验证一个文件，它会使用If-None-Match文件头来把ETag传回给原始服务器。在这个例子中，如果ETag匹配，就会返回一个304状态码，这就节省了12195字节的响应。      </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /i/yahoo.gif HTTP/1.1</span><br><span class="line">Host: us.yimg.com</span><br><span class="line">If-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMT</span><br><span class="line">If-None-Match: &quot;10c24bc-4ab-457e1c1f&quot;</span><br><span class="line">HTTP/1.1 304 Not Modified</span><br></pre></td></tr></table></figure>
</li>
<li><p>ETag的问题在于，它是根据可以辨别网站所在的服务器的具有唯一性的属性来生成的。当浏览器从一台服务器上获得页面内容后到另外一台服务器上进行验证时ETag就会不匹配，这种情况对于使用服务器组和处理请求的网站来说是非常常见的。默认情况下，Apache和IIS都会把数据嵌入ETag中，这会显著减少多服务器间的文件验证冲突。</p>
</li>
<li>Apache 1.3和2.x中的ETag格式为inode-size-timestamp。即使某个文件在不同的服务器上会处于相同的目录下，文件大小、权限、时间戳等都完全相同，但是在不同服务器上他们的内码也是不同的。</li>
<li>IIS 5.0和IIS 6.0处理ETag的机制相似。IIS中的ETag格式为Filetimestamp:ChangeNumber。用ChangeNumber来跟踪IIS配置的改变。网站所用的不同IIS服务器间ChangeNumber也不相同。 不同的服务器上的Apache和IIS即使对于完全相同的内容产生的ETag在也不相同，用户并不会接收到一个小而快的304响应；相反他们会接收一个正常的200响应并下载全部内容。如果你的网站只放在一台服务器上，就不会存在这个问题。但是如果你的网站是架设在多个服务器上，并且使用Apache和IIS产生默认的ETag配置，你的用户获得页面就会相对慢一点，服务器会传输更多的内容，占用更多的带宽，代理也不会有效地缓存你的网站内容。即使你的内容拥有Expires文件头，无论用户什么时候点击“刷新”或者“重载”按钮都会发送相应的GET请求。</li>
<li>如果你没有使用ETag提供的灵活的验证模式，那么干脆把所有的ETag都去掉会更好。Last-Modified文件头验证是基于内容的时间戳的。去掉ETag文件头会减少响应和下次请求中文件的大小。微软的这篇支持文稿讲述了如何去掉ETag。在Apache中，只需要在配置文件中简单添加下面一行代码就可以了：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileETag none</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>尽早刷新输出缓冲</p>
<ul>
<li>当用户请求一个页面时，无论如何都会花费200到500毫秒用于后台组织HTML文件。在这期间，浏览器会一直空闲等待数据返回。在PHP中，你可以使用flush()方法，它允许你把已经编译的好的部分HTML响应文件先发送给浏览器，这时浏览器就会可以下载文件中的内容（脚本等）而后台同时处理剩余的HTML页面。这样做的效果会在后台烦恼或者前台较空闲时更加明显。</li>
<li><p>输出缓冲应用最好的一个地方就是紧跟在head之后，因为HTML的头部分容易生成而且头部往往包含CSS和JavaScript文件，这样浏览器就可以在后台编译剩余HTML的同时并行下载它们。 例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  ... &lt;!-- css, js --&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;?php flush(); ?&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  ... &lt;!-- content --&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了证明使用这项技术的好处，Yahoo!搜索率先研究并完成了用户测试。</p>
</li>
</ul>
</li>
<li><p>使用GET来完成AJAX请求</p>
<ul>
<li>Yahoo!Mail团队发现，当使用XMLHttpRequest时，浏览器中的POST方法是一个“两步走”的过程：首先发送文件头，然后才发送数据。因此使用GET最为恰当，因为它只需发送一个TCP包（除非你有很多cookie）。IE中URL的最大长度为2K，因此如果你要发送一个超过2K的数据时就不能使用GET了。</li>
<li>一个有趣的不同就是POST并不像GET那样实际发送数据。根据HTTP规范，GET意味着“获取”数据，因此当你仅仅获取数据时使用GET更加有意义（从语意上讲也是如此），相反，发送并在服务端保存数据时使用POST。</li>
</ul>
</li>
<li><p>把样式表置于顶部</p>
<ul>
<li>在研究Yahoo!的性能表现时，我们发现把样式表放到文档的head内部似乎会加快页面的下载速度。这是因为把样式表放到head内会使页面有步骤的加载显示。</li>
<li>注重性能的前端服务器往往希望页面有秩序地加载。同时，我们也希望浏览器把已经接收到内容尽可能显示出来。这对于拥有较多内容的页面和网速较慢的用户来说特别重要。向用户返回可视化的反馈，比如进程指针，已经有了较好的研究并形成了正式文档。在我们的研究中HTML页面就是进程指针。当浏览器有序地加载文件头、导航栏、顶部的logo等对于等待页面加载的用户来说都可以作为可视化的反馈。这从整体上改善了用户体验。</li>
<li>把样式表放在文档底部的问题是在包括Internet Explorer在内的很多浏览器中这会中止内容的有序呈现。浏览器中止呈现是为了避免样式改变引起的页面元素重绘。用户不得不面对一个空白页面。</li>
<li>HTML规范清楚指出样式表要放包含在页面的head区域内：“和a不同,link只能出现在文档的head区域内，尽管它可以多次使用它”。无论是引起白屏还是出现没有样式化的内容都不值得去尝试。最好的方案就是按照HTML规范在文档head内加载你的样式表。</li>
</ul>
</li>
<li><p>避免使用CSS表达式（Expression）</p>
<ul>
<li><p>CSS表达式是动态设置CSS属性的强大（但危险）方法。Internet Explorer从第5个版本开始支持CSS表达式。下面的例子中，使用CSS表达式可以实现隔一个小时切换一次背景颜色：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-color: expression( (new Date()).getHours()%2 ? &quot;#B8D4FF&quot; : &quot;#F08A00&quot; );</span><br></pre></td></tr></table></figure>
</li>
<li><p>如上所示，expression中使用了JavaScript表达式。CSS属性根据JavaScript表达式的计算结果来设置。expression方法在其它浏览器中不起作用，因此在跨浏览器的设计中单独针对Internet Explorer设置时会比较有用。</p>
</li>
<li>表达式的问题就在于它的计算频率要比我们想象的多。不仅仅是在页面显示和缩放时，就是在页面滚动、乃至移动鼠标时都会要重新计算一次。给CSS表达式增加一个计数器可以跟踪表达式的计算频率。在页面中随便移动鼠标都可以轻松达到10000次以上的计算量。</li>
<li>一个减少CSS表达式计算次数的方法就是使用一次性的表达式，它在第一次运行时将结果赋给指定的样式属性，并用这个属性来代替CSS表达式。如果样式属性必须在页面周期内动态地改变，使用事件句柄来代替CSS表达式是一个可行办法。如果必须使用CSS表达式，一定要记住它们要计算成千上万次并且可能会对你页面的性能产生影响。</li>
</ul>
</li>
<li><p>使用外部JavaScript和CSS</p>
<ul>
<li>很多性能规则都是关于如何处理外部文件的。但是，在你采取这些措施前你可能会问到一个更基本的问题：JavaScript和CSS是应该放在外部文件中呢还是把它们放在页面本身之内呢？</li>
<li>在实际应用中使用外部文件可以提高页面速度，因为JavaScript和CSS文件都能在浏览器中产生缓存。内置在HTML文档中的JavaScript和CSS则会在每次请求中随HTML文档重新下载。这虽然减少了HTTP请求的次数，却增加了HTML文档的大小。从另一方面来说，如果外部文件中的JavaScript和CSS被浏览器缓存，在没有增加HTTP请求次数的同时可以减少HTML文档的大小。</li>
<li>关键问题是，外部JavaScript和CSS文件缓存的频率和请求HTML文档的次数有关。虽然有一定的难度，但是仍然有一些指标可以一测量它。如果一个会话中用户会浏览你网站中的多个页面，并且这些页面中会重复使用相同的脚本和样式表，缓存外部文件就会带来更大的益处。</li>
<li>许多网站没有功能建立这些指标。对于这些网站来说，最好的坚决方法就是把JavaScript和CSS作为外部文件引用。比较适合使用内置代码的例外就是网站的主页，如Yahoo!主页和My Yahoo!。主页在一次会话中拥有较少（可能只有一次）的浏览量，你可以发现内置JavaScript和CSS对于终端用户来说会加快响应时 间。</li>
<li>对于拥有较大浏览量的首页来说，有一种技术可以平衡内置代码带来的HTTP请求减少与通过使用外部文件进行缓存带来的好处。其中一个就是在首页中内置JavaScript和CSS，但是在页面下载完成后动态下载外部文件，在子页面中使用到这些文件时，它们已经缓存到浏览器了。</li>
</ul>
</li>
<li><p>削减JavaScript和CSS</p>
<ul>
<li>精简是指从去除代码不必要的字符减少文件大小从而节省下载时间。消减代码时，所有的注释、不需要的空白字符（空格、换行、tab缩进）等都要去掉。在JavaScript中，由于需要下载的文件体积变小了从而节省了响应时间。精简JavaScript中目前用到的最广泛的两个工具是JSMin和YUI Compressor。YUI Compressor还可用于精简CSS。</li>
<li>混淆是另外一种可用于源代码优化的方法。这种方法要比精简复杂一些并且在混淆的过程更易产生问题。在对美国前10大网站的调查中发现，精简也可以缩小原来代码体积的21%，而混淆可以达到25%。尽管混淆法可以更好地缩减代码，但是对于JavaScript来说精简的风险更小。</li>
<li>除消减外部的脚本和样式表文件外，script和style代码块也可以并且应该进行消减。即使你用Gzip压缩过脚本和样式表，精简这些文件仍然可以节省5%以上的空间。由于JavaScript和CSS的功能和体积的增加，消减代码将会获得益处。</li>
</ul>
</li>
<li><p>用link代替@import</p>
<ul>
<li>前面的最佳实现中提到CSS应该放置在顶端以利于有序加载呈现。</li>
<li>在IE中，页面底部@import和使用link作用是一样的，因此最好不要使用它。</li>
</ul>
</li>
<li><p>避免使用滤镜</p>
<ul>
<li>IE独有属性AlphaImageLoader用于修正7.0以下版本中显示PNG图片的半透明效果。这个滤镜的问题在于浏览器加载图片时它会终止内容的呈现并且冻结浏览器。在每一个元素（不仅仅是图片）它都会运算一次，增加了内存开支，因此它的问题是多方面的。</li>
<li>完全避免使用AlphaImageLoader的最好方法就是使用PNG8格式来代替，这种格式能在IE中很好地工作。如果你确实需要使用AlphaImageLoader，请使用下划线_filter又使之对IE7以上版本的用户无效。</li>
</ul>
</li>
<li><p>把脚本置于页面底部</p>
<ul>
<li>脚本带来的问题就是它阻止了页面的平行下载。HTTP/1.1 规范建议，浏览器每个主机名的并行下载内容不超过两个。如果你的图片放在多个主机名上，你可以在每个并行下载中同时下载2个以上的文件。但是当下载脚本时，浏览器就不会同时下载其它文件了，即便是主机名不相同。</li>
<li>在某些情况下把脚本移到页面底部可能不太容易。比如说，如果脚本中使用了document.write来插入页面内容，它就不能被往下移动了。这里可能还会有作用域的问题。很多情况下，都会遇到这方面的问题。</li>
<li>一个经常用到的替代方法就是使用延迟脚本。DEFER属性表明脚本中没有包含document.write，它告诉浏览器继续显示。不幸的是，Firefox并不支持DEFER属性。在Internet Explorer中，脚本可能会被延迟但效果也不会像我们所期望的那样。如果脚本可以被延迟，那么它就可以移到页面的底部。这会让你的页面加载的快一点。</li>
</ul>
</li>
<li><p>剔除重复脚本</p>
<ul>
<li>在同一个页面中重复引用JavaScript文件会影响页面的性能。你可能会认为这种情况并不多见。对于美国前10大网站的调查显示其中有两家存在重复引用脚本的情况。有两种主要因素导致一个脚本被重复引用的奇怪现象发生：团队规模和脚本数量。如果真的存在这种情况，重复脚本会引起不必要的HTTP请求和无用的JavaScript运算，这降低了网站性能。</li>
<li>在Internet Explorer中会产生不必要的HTTP请求，而在Firefox却不会。在Internet Explorer中，如果一个脚本被引用两次而且它又不可缓存，它就会在页面加载过程中产生两次HTTP请求。即时脚本可以缓存，当用户重载页面时也会产生额外的HTTP请求。</li>
<li>除增加额外的HTTP请求外，多次运算脚本也会浪费时间。在Internet Explorer和Firefox中不管脚本是否可缓存，它们都存在重复运算JavaScript的问题。</li>
<li><p>一个避免偶尔发生的两次引用同一脚本的方法是在模板中使用脚本管理模块引用脚本。在HTML页面中使用script标签引用脚本的最常见方法就是：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"menu_1.0.17.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在PHP中可以通过创建名为insertScript的方法来替代：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php insertScript(&quot;menu.js&quot;) ?&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了防止多次重复引用脚本，这个方法中还应该使用其它机制来处理脚本，如检查所属目录和为脚本文件名中增加版本号以用于Expire文件头等。</p>
</li>
</ul>
</li>
<li><p>减少DOM访问</p>
<ul>
<li>使用JavaScript访问DOM元素比较慢，因此为了获得更多的应该页面，应该做到：</li>
<li>缓存已经访问过的有关元素</li>
<li>线下更新完节点之后再将它们添加到文档树中</li>
<li>避免使用JavaScript来修改页面布局</li>
<li>有关此方面的更多信息请查看Julien Lecomte在YUI专题中的文章“高性能Ajax应该程序”。</li>
</ul>
</li>
<li><p>开发智能事件处理程序</p>
<ul>
<li>有时候我们会感觉到页面反应迟钝，这是因为DOM树元素中附加了过多的事件句柄并且些事件句病被频繁地触发。这就是为什么说使用event delegation（事件代理）是一种好方法了。如果你在一个div中有10个按钮，你只需要在div上附加一次事件句柄就可以了，而不用去为每一个按钮增加一个句柄。事件冒泡时你可以捕捉到事件并判断出是哪个事件发出的。</li>
<li>你同样也不用为了操作DOM树而等待onload事件的发生。你需要做的就是等待树结构中你要访问的元素出现。你也不用等待所有图像都加载完毕。</li>
<li>你可能会希望用DOMContentLoaded事件来代替onload，但是在所有浏览器都支持它之前你可使用YUI 事件应用程序中的onAvailable方法。</li>
</ul>
</li>
<li><p>减小Cookie体积</p>
<ul>
<li>HTTP coockie可以用于权限验证和个性化身份等多种用途。coockie内的有关信息是通过HTTP文件头来在web服务器和浏览器之间进行交流的。因此保持coockie尽可能的小以减少用户的响应时间十分重要。</li>
<li>有关更多信息可以查看Tenni Theurer和Patty Chi的文章“When the Cookie Crumbles”。这们研究中主要包括：</li>
<li>去除不必要的coockie,使coockie体积尽量小以减少对用户响应的影响注意在适应级别的域名上设置coockie以便使子域响<br>设置合理的过期时间。较早地Expire时间和不要过早去清除coockie，都会改善用户的响应时间。</li>
</ul>
</li>
<li><p>对于页面内容使用无coockie域名</p>
<ul>
<li>当浏览器在请求中同时请求一张静态的图片和发送coockie时，服务器对于这些coockie不会做任何地使用。因此他们只是因为某些负面因素而创建的网络传输。所有你应该确定对于静态内容的请求是无coockie的请求。创建一个子域名并用他来存放所有静态内容。</li>
<li>如果你的域名是www.example.org，你可以在static.example.org上存在静态内容。但是，如果你不是在www.example.org上而是在顶级域名example.org设置了coockie，那么所有对于static.example.org的请求都包含coockie。在这种情况下，你可以再重新购买一个新的域名来存在静态内容，并且要保持这个域名是无coockie的。Yahoo!使用的是ymig.com，YouTube使用的是ytimg.com，Amazon使用的是images-anazon.com等等。</li>
<li>使用无coockie域名存在静态内容的另外一个好处就是一些代理（服务器）可能会拒绝对coockie的内容请求进行缓存。一个相关的建议就是，如果你想确定应该使用example.org还是www.example.org作为你的一主页，你要考虑到coockie带来的影响。忽略掉www会使你除了把coockie设置到*.example.org（是泛域名解析，代表了所有子域名译者dudo注）外没有其它选择，因此出于性能方面的考虑最好是使用带有www的子域名并且在它上面设置coockie。</li>
</ul>
</li>
<li><p>优化图像</p>
<ul>
<li>设计人员完成对页面的设计之后，不要急于将它们上传到web服务器，这里还需要做几件事：</li>
<li>你可以检查一下你的GIF图片中图像颜色的数量是否和调色板规格一致。 使用imagemagick中下面的命令行很容易检查：identify -verbose image.gif</li>
<li>如果你发现图片中只用到了4种颜色，而在调色板的中显示的256色的颜色槽，那么这张图片就还有压缩的空间。</li>
<li>尝试把GIF格式转换成PNG格式，看看是否节省空间。大多数情况下是可以压缩的。由于浏览器支持有限，设计者们往往不太乐意使用PNG格式的图片，不过这都是过去的事情了。现在只有一个问题就是在真彩PNG格式中的alpha通道半透明问题，不过同样的，GIF也不是真彩格式也不支持半透明。因此GIF能做到的，PNG（PNG8）同样也能做到（除了动画）。下面这条简单的命令可以安全地把GIF格式转换为PNG格式：convert image.gif image.png</li>
<li><p>“我们要说的是：给PNG一个施展身手的机会吧！”在所有的PNG图片上运行pngcrush（或者其它PNG优化工具）。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pngcrush image.png -rem alla -reduce -brute result.png</span><br></pre></td></tr></table></figure>
</li>
<li><p>在所有的JPEG图片上运行jpegtran。这个工具可以对图片中的出现的锯齿等做无损操作，同时它还可以用于优化和清除图片中的注释以及其它无用信息（如EXIF信息）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jpegtran -copy none -optimize -perfect src.jpg dest.jpg</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>优化CSS Spirite</p>
<ul>
<li>在Spirite中水平排列你的图片，垂直排列会稍稍增加文件大小；</li>
<li>Spirite中把颜色较近的组合在一起可以降低颜色数，理想状况是低于256色以便适用PNG8格式；</li>
<li>便于移动，不要在Spirite的图像中间留有较大空隙。这虽然不大会增加文件大小但对于用户代理来说它需要更少的内存来把图片解压为像素地图。100x100的图片为1万像素，而1000x1000就是100万像素。</li>
</ul>
</li>
<li><p>不要在HTML中缩放图像</p>
<ul>
<li><p>不要为了在HTML中设置长宽而使用比实际需要大的图片。如果你需要：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">height</span>=<span class="string">"100"</span> <span class="attr">src</span>=<span class="string">"mycat.jpg"</span> <span class="attr">alt</span>=<span class="string">"My Cat"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>那么你的图片（mycat.jpg）就应该是100x100像素而不是把一个500x500像素的图片缩小使用。  </p>
</li>
</ul>
</li>
<li><p>favicon.ico要小而且可缓存</p>
<ul>
<li>favicon.ico是位于服务器根目录下的一个图片文件。它是必定存在的，因为即使你不关心它是否有用，浏览器也会对它发出请求，因此最好不要返回一个404 Not Found的响应。由于是在同一台服务器上，它每被请求一次coockie就会被发送一次。这个图片文件还会影响下载顺序，例如在IE中当你在onload中请求额外的文件时，favicon会在这些额外内容被加载前下载。</li>
<li>因此，为了减少favicon.ico带来的弊端，要做到：</li>
<li>文件尽量地小，最好小于1K</li>
<li>在适当的时候（也就是你不要打算再换favicon.ico的时候，因为更换新文件时不能对它进行重命名）为它设置Expires文件头。你可以很安全地把Expires文件头设置为未来的几个月。你可以通过核对当前favicon.ico的上次编辑时间来作出判断。</li>
<li>Imagemagick可以帮你创建小巧的favicon。</li>
</ul>
</li>
<li><p>保持单个内容小于25K</p>
<ul>
<li>这条限制主要是因为iPhone不能缓存大于25K的文件。注意这里指的是解压缩后的大小。由于单纯gizp压缩可能达不要求，因此精简文件就显得十分重要。</li>
<li>查看更多信息，请参阅Wayne Shea和Tenni Theurer的文件“Performance Research, Part 5: iPhone Cacheability - Making it Stick”。</li>
</ul>
</li>
<li><p>打包组件成复合文本</p>
<ul>
<li>把页面内容打包成复合文本就如同带有多附件的Email，它能够使你在一个HTTP请求中取得多个组件（切记：HTTP请求是很奢侈的）。当你使用这条规则时，首先要确定用户代理是否支持（iPhone就不支持）。</li>
</ul>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;雅虎：网站页面性能优化的34条建议：&lt;br&gt;
    
    </summary>
    
      <category term="剪切板" scheme="https://wangzongxu.github.io/categories/%E5%89%AA%E5%88%87%E6%9D%BF/"/>
    
    
      <category term="前端优化" scheme="https://wangzongxu.github.io/tags/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>中庸</title>
    <link href="https://wangzongxu.github.io/2018/03/02/ZhongYong/"/>
    <id>https://wangzongxu.github.io/2018/03/02/ZhongYong/</id>
    <published>2018-03-02T06:45:23.063Z</published>
    <updated>2018-03-02T06:45:23.064Z</updated>
    
    <content type="html"><![CDATA[<p>喜怒哀乐之未发谓之中，发之皆中节谓之和。</p>
<a id="more"></a>
<blockquote>
<p>中庸之道的主题思想是教育人们自觉地进行自我修养、自我监督、自我教育、自我完善，把自己培养成为具有理想人格，达到至善、至仁、至诚、至道、至德、至圣、合外内之道的理想人物，共创“致中和，天地位焉，万物育焉”的“太平和合”境界。</p>
</blockquote>
<p><a href="https://wangzongxu.gitbooks.io/zhongyong/content/" target="_blank" rel="external">点击阅读</a><br><a href="https://wangzongxu.gitbooks.io/zhongyong/content/" target="_blank" rel="external">https://wangzongxu.gitbooks.io/zhongyong/content/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;喜怒哀乐之未发谓之中，发之皆中节谓之和。&lt;/p&gt;
    
    </summary>
    
      <category term="国学" scheme="https://wangzongxu.github.io/categories/%E5%9B%BD%E5%AD%A6/"/>
    
    
      <category term="电子书" scheme="https://wangzongxu.github.io/tags/%E7%94%B5%E5%AD%90%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>Nginx中alias和root参数区别</title>
    <link href="https://wangzongxu.github.io/2018/03/02/nginx-alias/"/>
    <id>https://wangzongxu.github.io/2018/03/02/nginx-alias/</id>
    <published>2018-03-02T02:21:26.435Z</published>
    <updated>2018-03-02T03:02:22.755Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下二者的区别</p>
<a id="more"></a>
<ul>
<li>alias</li>
</ul>
<p>根据官网的定义是说定义一段指定路径的替代品。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /i/ &#123;</span><br><span class="line">    alias /data/w3/images/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上边会把”/i/“替换为”/data/w3/images/“，例如请求”/i/top.gif”, 响应为”/data/w3/images/top.gif”,<br>注意alias的路径一定要以为”/“结尾，否则会找不到指定文件。</p>
<ul>
<li>root</li>
</ul>
<p>root则是设置请求的根目录，末尾的”/“可有可无。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /i/ &#123;</span><br><span class="line">    root /data/w3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上边会把”/i/“追加到”/data/w3”后边，例如请求”/i/top.gif”，响应为”/data/w3/i/top.gif”。</p>
<ul>
<li>二者分别在什么时候使用？</li>
</ul>
<p>既然alias是替换location匹配的路径，所以当匹配的结果不需要的时候就使用alias：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /img/ &#123;</span><br><span class="line">    alias /data/images/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上边对于”/img/“的请求只是作为标识这个请求资源类型是图片，然而我们并不需要”/img/“这个路径，<br>这个时候使用了alias转发到”/data/images/“路径下。</p>
<p>当location匹配的路径和alias的路径末尾相同时，就该用root</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /img/ &#123;</span><br><span class="line">    alias /data/img/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上边”/img/“和”/data/img/“尾部相同，这个时候应该改写为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /img/ &#123;</span><br><span class="line">    root /data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上边并没有像alias一样会把”/img/“替换掉，而是去”/data/img”下查找请求资源。</p>
<p>（完）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下二者的区别&lt;/p&gt;
    
    </summary>
    
      <category term="网络" scheme="https://wangzongxu.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Nginx" scheme="https://wangzongxu.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>console.log打印漂亮的日志</title>
    <link href="https://wangzongxu.github.io/2018/03/02/console/"/>
    <id>https://wangzongxu.github.io/2018/03/02/console/</id>
    <published>2018-03-02T02:21:06.211Z</published>
    <updated>2018-03-02T02:21:06.211Z</updated>
    
    <content type="html"><![CDATA[<p>打开百度、天猫控制台，你都会发现漂亮的图案，是怎么做的呢？<br><a id="more"></a></p>
<h4 id="了解console方法"><a href="#了解console方法" class="headerlink" title="了解console方法"></a>了解console方法</h4><p>我们都知道console.log可以打印多个参数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>)</span><br></pre></td></tr></table></figure></p>
<h4 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h4><p>在console.log输出的字符串中可以加入以下占位符，不同格式的数据必须使用对应格式的占位符，我们只需用到’%c’，其他的就暂且不谈；</p>
<blockquote>
<p>%s 字符串<br>%d 整数<br>%i 整数<br>%f 浮点数<br>%o 对象的链接<br>%c CSS格式字符串</p>
</blockquote>
<h4 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h4><ul>
<li>如果第一个参数是格式字符串（使用了格式占位符），console.log方法将依次用后面的参数替换占位符，然后再进行输出，使用很简单：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'%cABC'</span>,<span class="string">'color:red'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="https://wangzongxu.github.io/img-cache/console/console1.png" width="300" alt="" align="center"><br>在控制台查看效果，我们发现ABC变成了红色：%c对应第二个参数，这个参数是css字符串，可以包含多个属性，以分号隔开：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'%cABC'</span>,<span class="string">'color:red;font-size:30px'</span>)</span><br></pre></td></tr></table></figure></p>
<p><img src="https://wangzongxu.github.io/img-cache/console/console2.png" width="400" alt="" align="center"><br>此时我们发现字体变大了。</p>
<p>如果你想让‘ABC’有更多的风格，我们只需再加上几个’%c’和对应的参数即可：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'%cA%cB%cC'</span>,<span class="string">'color:red'</span>,<span class="string">'color:blue'</span>,<span class="string">'color:green'</span>)</span><br></pre></td></tr></table></figure></p>
<p><img src="https://wangzongxu.github.io/img-cache/console/console3.png" width="600" alt="" align="center"><br>每一个%c，只对从他后边的字符开始至下一个%c之前的位置起作用，第一个%c到第三个%c的样式，分别对应从第二个参数开始的’color:red’,’color:blue’,’color:green’，如果你想要更多的颜色，可以添加更多占位符。</p>
<h4 id="制作图案"><a href="#制作图案" class="headerlink" title="制作图案"></a>制作图案</h4><p>如果只是简单几种颜色我们很容易控制，但是如果一个图案包含很多颜色，那对于console.log的参数很难把握。<br>下边我们使用一个插件<a href="https://github.com/wangzongxu/web-chalk.git" target="_blank" rel="external">web-chalk</a>来打印一个图案。<br><img src="https://wangzongxu.github.io/img-cache/webchalk/webchalk.png" width="500" alt="" align="center"></p>
<ol>
<li>首先第一步比较重要，也是不容易的，因为需要排版，把组成图案的每一个字符对应准确</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"\n\</span><br><span class="line">        ██          ███████         ███████\n\</span><br><span class="line">      ██  ██        ██     ██     ██\n\</span><br><span class="line">     ██ ▄▄ ██       ███████       ██\n\</span><br><span class="line">    ██      ██      ██     ██     ██\n\</span><br><span class="line">   ██        ██     ███████         ███████   A  B  C\n\</span><br><span class="line">    "</span></span><br></pre></td></tr></table></figure>
<p>这里我先声明一个准备输出的字符串图案，使用的单个字符是一个方块，大家也可以去网上找更多好看的字符尝试，记得在换行的位置加’\n’和该行结束位置的’\’，这个我就不多说了，拼接过字符串的童鞋都知道，当然，如果你使用ES6的模板字符串就不必考虑这么多了。</p>
<ol>
<li>添加占位符</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str_ = <span class="string">"\n\</span><br><span class="line">        &lt;b&gt;██&lt;/b&gt;          &lt;r&gt;███████&lt;/r&gt;         &lt;g&gt;███████&lt;/g&gt;\n\</span><br><span class="line">      &lt;b&gt;██  ██&lt;/b&gt;        &lt;r&gt;██     ██&lt;/r&gt;     &lt;g&gt;██&lt;/g&gt;\n\</span><br><span class="line">     &lt;b&gt;██ ▄▄ ██&lt;/b&gt;       &lt;r&gt;███████&lt;/r&gt;       &lt;g&gt;██&lt;/g&gt;\n\</span><br><span class="line">    &lt;b&gt;██      ██&lt;/b&gt;      &lt;r&gt;██     ██&lt;/r&gt;     &lt;g&gt;██&lt;/g&gt;\n\</span><br><span class="line">   &lt;b&gt;██        ██&lt;/b&gt;     &lt;r&gt;███████&lt;/r&gt;         &lt;g&gt;███████&lt;/g&gt;  &lt;b&gt;A&lt;/b&gt; &lt;r&gt;B&lt;/r&gt; &lt;g&gt;C&lt;/g&gt;\n\</span><br><span class="line">    "</span></span><br></pre></td></tr></table></figure>
<p>我们在每个需要更换颜色的开始位置增加了占位符，虽然看起来字符已经错位，但是并不影响正常输出。</p>
<ol>
<li>注意占位符的数量和顺序，编写console的样式参数并输出：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cssClass = &#123;</span><br><span class="line">    <span class="attr">b</span>: &#123;</span><br><span class="line">        <span class="attr">color</span>: <span class="string">'rgb(29,174,229)'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">r</span>: &#123;</span><br><span class="line">        <span class="attr">color</span>: <span class="string">'rgb(218,14,26)'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">g</span>: &#123;</span><br><span class="line">        <span class="attr">color</span>: <span class="string">'rgb(171,204,3)'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>使用这款插件可以把风格类名作为xml的标签定义样式，用法非常简单。<br>问题请到：<a href="https://github.com/wangzongxu/web-chalk/issues" target="_blank" rel="external">ISSUES</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;打开百度、天猫控制台，你都会发现漂亮的图案，是怎么做的呢？&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="https://wangzongxu.github.io/categories/JS/"/>
    
    
      <category term="JS" scheme="https://wangzongxu.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>一个关于Promise执行顺序的小例子</title>
    <link href="https://wangzongxu.github.io/2018/02/13/promise-demo1/"/>
    <id>https://wangzongxu.github.io/2018/02/13/promise-demo1/</id>
    <published>2018-02-13T08:08:01.355Z</published>
    <updated>2018-03-08T13:53:30.255Z</updated>
    
    <content type="html"><![CDATA[<p>看下边这段代码并说出结果的输出顺序：</p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>))</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">t</span> =&gt;</span> <span class="built_in">console</span>.log(t))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>执行结果在下边，建议先猜测一下</li>
</ul>
<p><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></p>
<ul>
<li><p>执行结果：4，3，2，1</p>
</li>
<li><p>在new Promise的时候，内部代码会立即同步执行，所以先输出4；</p>
</li>
<li><p>此时内部的同步代码已经执行完成，开始执行外部的console.log(3)；</p>
</li>
<li><p>大家纠结的问题应该在1和2谁先输出，此时我们回过头来看resolve(1)和console.log(2)</p>
</li>
<li><p>需要注意的是由于resolve(1)是同步执行的，此时外层Promise并没有执行then方法，也就是说console.log<br>(t)此时并没有被推入任务队列；</p>
</li>
<li><p>resolve(1)执行完以后，执行Promise.resolve(() =&gt; console.log(2))，这句代码的then方法在任务队列里放了一个console.log(2)，再次注意是这里的then率先在任务队列中放置了任务；</p>
</li>
<li><p>接下来才执行到外层Promise的then，这个时候把console.log(t)放入了任务队列；</p>
</li>
<li><p>所以我们先看到输出了2，然后输出的1</p>
</li>
</ul>
<p>（完）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看下边这段代码并说出结果的输出顺序：&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="https://wangzongxu.github.io/categories/JS/"/>
    
    
      <category term="JS" scheme="https://wangzongxu.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>常用Chrome扩展工具</title>
    <link href="https://wangzongxu.github.io/2017/09/21/chromeUtils/"/>
    <id>https://wangzongxu.github.io/2017/09/21/chromeUtils/</id>
    <published>2017-09-21T09:09:24.000Z</published>
    <updated>2017-09-21T09:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用chrome前端开发，就少不了一些扩展程序来提升开发和调试效率，在这里整理一下常用的开发工具：<br><a id="more"></a></p>
<h4 id="Axure-RP-Extension-for-Chrome"><a href="#Axure-RP-Extension-for-Chrome" class="headerlink" title="Axure RP Extension for Chrome"></a>Axure RP Extension for Chrome</h4><p>这个插件可以打开RP原型文件，本身chrome是不支持的。<br><img src="https://wangzongxu.github.io/img-cache/blog/axure.jpeg" width="300" alt="" align="center"></p>
<h4 id="JavaScript-and-CSS-Code-Beautifier"><a href="#JavaScript-and-CSS-Code-Beautifier" class="headerlink" title="JavaScript and CSS Code Beautifier"></a>JavaScript and CSS Code Beautifier</h4><p>用于查看js、css等源码时对其进行高亮、格式化、美化、压缩等操作.<br><img src="https://wangzongxu.github.io/img-cache/blog/beautifulCode.png" width="600" alt="" align="center"></p>
<h4 id="JSON-handle"><a href="#JSON-handle" class="headerlink" title="JSON-handle"></a>JSON-handle</h4><p>它是JSON文档的浏览器和编辑器，可以获得美丽的视图。<br><img src="https://wangzongxu.github.io/img-cache/blog/jsonHandle.png" width="600" alt="" align="center"></p>
<h4 id="Wappalyzer"><a href="#Wappalyzer" class="headerlink" title="Wappalyzer"></a>Wappalyzer</h4><p>可以知道浏览的网站所用的技术。<br><img src="https://wangzongxu.github.io/img-cache/blog/wappalyzer.png" width="300" alt="" align="center"></p>
<h4 id="whistle"><a href="#whistle" class="headerlink" title="whistle"></a>whistle</h4><p>whistle是一款用Node实现的跨平台的Web调试代理工具，支持查看修改http(s)、Websocket连接的请求和响应内容。<a href="https://avwo.github.io/whistle/" target="_blank" rel="external">官方中文教程</a><br><img src="https://wangzongxu.github.io/img-cache/blog/whistle1.png" width="200" alt="" align="center"><br><img src="https://wangzongxu.github.io/img-cache/blog/whistle2.png" width="600" alt="" align="center"><br><img src="https://wangzongxu.github.io/img-cache/blog/whistle3.png" width="600" alt="" align="center"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用chrome前端开发，就少不了一些扩展程序来提升开发和调试效率，在这里整理一下常用的开发工具：&lt;br&gt;
    
    </summary>
    
      <category term="chrome" scheme="https://wangzongxu.github.io/categories/chrome/"/>
    
    
      <category term="chrome" scheme="https://wangzongxu.github.io/tags/chrome/"/>
    
  </entry>
  
  <entry>
    <title>道德经</title>
    <link href="https://wangzongxu.github.io/2017/09/21/TaoTeChing/"/>
    <id>https://wangzongxu.github.io/2017/09/21/TaoTeChing/</id>
    <published>2017-09-21T09:09:24.000Z</published>
    <updated>2017-09-21T09:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>整理了一下道德经诸传本，加粗浅的字面解释；<br>道德经解释仁者见仁智者见智，需要有自己的理解，因为其中的玄妙不是能够用语言可以表达的，正所谓：道可道，非常道。<br><a id="more"></a><br><a href="https://wangzongxu.gitbooks.io/taoteching/content/" target="_blank" rel="external">点击阅读</a><br><a href="https://wangzongxu.gitbooks.io/taoteching/content/" target="_blank" rel="external">https://wangzongxu.gitbooks.io/taoteching/content/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整理了一下道德经诸传本，加粗浅的字面解释；&lt;br&gt;道德经解释仁者见仁智者见智，需要有自己的理解，因为其中的玄妙不是能够用语言可以表达的，正所谓：道可道，非常道。&lt;br&gt;
    
    </summary>
    
      <category term="国学" scheme="https://wangzongxu.github.io/categories/%E5%9B%BD%E5%AD%A6/"/>
    
    
      <category term="电子书" scheme="https://wangzongxu.github.io/tags/%E7%94%B5%E5%AD%90%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>demo之canvas时钟</title>
    <link href="https://wangzongxu.github.io/2017/09/21/date-canvas-demo/"/>
    <id>https://wangzongxu.github.io/2017/09/21/date-canvas-demo/</id>
    <published>2017-09-21T09:09:24.000Z</published>
    <updated>2017-09-21T09:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>偶尔看到网上的动画挺漂亮，自己也来做一个收藏。</p>
<a id="more"></a>
<p><a href="https://wangzongxu.github.io/canvas-demo/time/">点击查看</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;偶尔看到网上的动画挺漂亮，自己也来做一个收藏。&lt;/p&gt;
    
    </summary>
    
      <category term="canvas" scheme="https://wangzongxu.github.io/categories/canvas/"/>
    
    
      <category term="动画" scheme="https://wangzongxu.github.io/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>前端优化技巧</title>
    <link href="https://wangzongxu.github.io/2017/09/21/front-end-optimzation/"/>
    <id>https://wangzongxu.github.io/2017/09/21/front-end-optimzation/</id>
    <published>2017-09-21T09:09:24.000Z</published>
    <updated>2017-09-21T09:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>总结一些前端优化技巧：<br><a id="more"></a></p>
<h3 id="减少HTTP请求"><a href="#减少HTTP请求" class="headerlink" title="减少HTTP请求"></a>减少HTTP请求</h3><ul>
<li>把CSS/JS文件进行合并压缩(前端压缩一下,服务器做一下GZIP压缩),一个页面只有一个CSS/JS。</li>
<li>在移动端页面开发过程中,如果CSS/JS的代码量不是很多的话,我们尽量使用内嵌式。</li>
<li>数据缓存(localStorage):把我们的CSS/JS代码存储到本地,下一次刷新页面的时候直接的在本地缓存中读取即可,不需要重新的发送HTTP请求了(需要更新可以通过JS的版本号来实现更新)。</li>
<li>CSS SPRITE 把静态的资源图片进行合并,合并到一张大图上,通过POSITION定位找到具体的图片,这样的话只需要发送一次HTTP请求即可。</li>
<li>能够用代码(SVG)绘制出来的图片我们尽量不使用IMG来做。</li>
<li>图片的延迟加载：首屏图片等到一段时间在进行加载,其它屏幕的图片当页面滚动到对应区域的时候在进行延迟加载。</li>
<li>静态资源小图可采用BASE64技术进行编码。</li>
<li>数据的异步加载:第一次只请求出部分数据(一般都是一到两屏幕的数据),当我们滚动到的底部的时候在开始加载下面的两屏幕数据(上拉/下拉刷新)。</li>
<li>数据缓存(localStorage):第一次把请求回来的数据保存在自己的本地,在有效时间内,我们刷新页面的时候,只需要把本地的存储数据获取到绑定到页面中即可,不需要重新的发送Ajax请求,直到时间过期,在从新的发送请求,用最新请求的数据替换本地之前存储的数据。</li>
<li>把音视频播放进行延迟加载(PRELOAD=’NONE’),在JS中做延迟播放,播放的时候在加载资源;有条件的话可以把音视频都用文件流的方式进行操作;</li>
</ul>
<h3 id="减少HTTP请求资源的大小"><a href="#减少HTTP请求资源的大小" class="headerlink" title="减少HTTP请求资源的大小"></a>减少HTTP请求资源的大小</h3><ul>
<li><a href="/2017/03/26/yahoo34/">雅虎优化34条建议</a></li>
<li>CSS/JS去除冗余代码(低耦合高内聚)</li>
<li>图片尽量压缩</li>
<li>每一次请求回来的数据尽量少一些,我们可以分批请求</li>
<li>所有的CSS/JS上传到服务器的都是经过压缩过的</li>
</ul>
<h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><ul>
<li>尽量减少不销毁闭包的使用(堆栈内存的释放问题)</li>
<li>尽量多使用异步编程,少使用同步编程</li>
<li>移动端开发,能够使用CSS实现的功能最好也不用JS;能够使用CSS3实现的动画,绝对不用JS;能用TransForm实现的动画尽量用它实现(TransForm开启了硬件加速);能够自己使用原生的JS实现的,绝对不用任何的框架或者类库(多人开发,项目偏大,我们在使用相关的框架);</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结一些前端优化技巧：&lt;br&gt;
    
    </summary>
    
      <category term="前端优化" scheme="https://wangzongxu.github.io/categories/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="前端优化" scheme="https://wangzongxu.github.io/tags/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>ES6函数参数解构典型问题</title>
    <link href="https://wangzongxu.github.io/2017/09/21/decomposition-function-params/"/>
    <id>https://wangzongxu.github.io/2017/09/21/decomposition-function-params/</id>
    <published>2017-09-21T09:09:24.000Z</published>
    <updated>2017-09-21T09:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>函数参数解构的一个典型问题</p>
<a id="more"></a>
<h3 id="首先对比两个例子"><a href="#首先对比两个例子" class="headerlink" title="首先对比两个例子"></a>首先对比两个例子</h3><blockquote>
<p>例子一</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, 0]</span></span><br><span class="line">move(&#123;&#125;); <span class="comment">// [0, 0]</span></span><br><span class="line">move();  <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>例子二</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x, y&#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, undefined]</span></span><br><span class="line">move(&#123;&#125;); <span class="comment">// [undefined, undefined]</span></span><br><span class="line">move(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>不能理解结果的话继续往下看^_^</li>
</ul>
<h3 id="从babel转码看解构原理"><a href="#从babel转码看解构原理" class="headerlink" title="从babel转码看解构原理"></a>从babel转码看解构原理</h3><p>利用babel<a href="https://babeljs.io/repl/" target="_blank" rel="external">在线转码</a>方便学习解构的原理:</p>
<ul>
<li>再次分析函数的参数</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>我们将上边函数参数分为两部分，等号前边 {x = 0, y = 0} 称之为模式，等号后边 {} 是称之为默认参数，如果函数执行时没有传参，则会取默认参数。</li>
</ul>
<blockquote>
<p>babel转码后的例子一</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _ref = <span class="built_in">arguments</span>.length &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">arguments</span>[<span class="number">0</span>] !== <span class="literal">undefined</span> ? <span class="built_in">arguments</span>[<span class="number">0</span>] : &#123;&#125;;</span><br><span class="line">  <span class="comment">// 如果没有传参，那么取默认值空对象&#123;&#125;</span></span><br><span class="line">  <span class="keyword">var</span> _ref$x = _ref.x;</span><br><span class="line">  <span class="comment">// 模式对参数进行解构：取参数的x值</span></span><br><span class="line">  <span class="keyword">var</span> x = _ref$x === <span class="literal">undefined</span> ? <span class="number">0</span> : _ref$x;</span><br><span class="line">  <span class="comment">// 模式中的x有默认值，所以当被解构的参数中没有x，则取模式中的x值：0</span></span><br><span class="line">  <span class="keyword">var</span> _ref$y = _ref.y;</span><br><span class="line">  <span class="comment">// 模式对参数进行解构：取参数的y值</span></span><br><span class="line">  <span class="keyword">var</span> y = _ref$y === <span class="literal">undefined</span> ? <span class="number">0</span> : _ref$y;</span><br><span class="line">  <span class="comment">// 模式中的y有默认值，所以当被解构的参数中没有y，则取模式中的y值：0</span></span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123; <span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span> &#125;);</span><br><span class="line"><span class="comment">// 传递了参数 &#123; x: 3, y: 8 &#125; 则模式对该参数进行解构，结果为：[3, 8]</span></span><br><span class="line">move(&#123; <span class="attr">x</span>: <span class="number">3</span> &#125;);</span><br><span class="line"><span class="comment">// 传递了参数 &#123; x: 3 &#125; 则模式对该参数进行解构，解构过程中x成功取值:3，由于参数中没有y，所以y值取值失败，失败后取模式中的y默认值0，所以结果为：[3, 0]</span></span><br><span class="line">move(&#123;&#125;);</span><br><span class="line"><span class="comment">// 传递了参数空对象&#123;&#125; 则模式对该空对象进行解构，由于该参数中xy都没有，所以都取模式中xy默认值0，最后结果为[0, 0]</span></span><br><span class="line">move();</span><br><span class="line"><span class="comment">// 没有传递参数，则取默认参数空对象 &#123;&#125;，模式对默认参数进行解构，和上边一样，参数中xy都没有，所以都取模式中xy默认值0，最后结果为[0, 0]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>babel转码后的例子二</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _ref2 = <span class="built_in">arguments</span>.length &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">arguments</span>[<span class="number">0</span>] !== <span class="literal">undefined</span> ? <span class="built_in">arguments</span>[<span class="number">0</span>] : &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;;</span><br><span class="line">  <span class="comment">// 如果没有传参，那么取默认值：&#123; x: 0, y: 0 &#125;</span></span><br><span class="line">  <span class="keyword">var</span> x = _ref2.x;</span><br><span class="line">  <span class="comment">// 模式对参数进行解构：取参数的x值</span></span><br><span class="line">  <span class="keyword">var</span> y = _ref2.y;</span><br><span class="line">  <span class="comment">// 模式对参数进行解构：取参数的y值</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123; <span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span> &#125;);</span><br><span class="line"><span class="comment">// 传递了参数 &#123; x: 3, y: 8 &#125; 则模式对该参数进行解构，结果为：[3, 8]</span></span><br><span class="line">move(&#123; <span class="attr">x</span>: <span class="number">3</span> &#125;);</span><br><span class="line"><span class="comment">// 传递了参数 &#123; x: 3 &#125;，模式对该参数进行解构，解构过程中x成功取值:3，由于参数中没有y，所以y值取值失败，此时模式中也没有指定y的默认值，所以结果为：[3, undefined]</span></span><br><span class="line">move(&#123;&#125;);</span><br><span class="line"><span class="comment">// 传递了参数空对象 &#123;&#125;，模式对参数空对象进行解构，xy皆取值失败，模式中xy也并没有默认值，所以最后结果为：[undefined, undefined]</span></span><br><span class="line">move();</span><br><span class="line"><span class="comment">// 没有传递参数，则取默认参数&#123; x: 0, y: 0 &#125;，模式对默认参数进行解构，x取值0，取值0，所以结果为[0, 0]</span></span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>当一个函数执行时要看该函数在定义过程中是否有默认参数，模式中是否有默认值：<br>首先根据是否传参和是否有默认参数来确定参数是谁，然后将模式对参数进行解构。<br>结构过程中如果解构失败要根据模式中是否指定了默认值来确定最后取值。<br>逻辑比较乱，多多练习，慢慢体会。</p>
<ul>
<li>取值过程<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">if (有默认参数) &#123;</span><br><span class="line">    if (执行时传参了) &#123;</span><br><span class="line">        将模式对参数解构</span><br><span class="line">         if (解构成功) &#123;</span><br><span class="line">             最终取值成功解构的值</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             if (模式中制定了默认值) &#123;</span><br><span class="line">                最终取模式中默认值</span><br><span class="line">             &#125; else &#123;</span><br><span class="line">                取值undefined</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">        将模式对默认参数解构</span><br><span class="line">        if (解构成功) &#123;</span><br><span class="line">            最终取值成功解构的值</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (模式中制定了默认值) &#123;</span><br><span class="line">                最终取模式中默认值</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                取值undefined</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    if (执行时传参了) &#123;</span><br><span class="line">       最终以执行传递的参数为准</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">       最终参数为undefined</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>(完)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;函数参数解构的一个典型问题&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="https://wangzongxu.github.io/categories/JS/"/>
    
    
      <category term="JS" scheme="https://wangzongxu.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>esLint入门</title>
    <link href="https://wangzongxu.github.io/2017/09/21/esLint/"/>
    <id>https://wangzongxu.github.io/2017/09/21/esLint/</id>
    <published>2017-09-21T09:09:24.000Z</published>
    <updated>2017-09-21T09:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="esLint入门"><a href="#esLint入门" class="headerlink" title="esLint入门"></a>esLint入门</h3><p>ESLint是用于识别和报告ECMAScript / JavaScript代码书写风格的工具，目的是使代码更加一致并避免错误。 在许多方面，它与JSLint和JSHint类似，但有一些例外：<br><a id="more"></a><br>这里只介绍基本使用各规则，详细可去<a href="http://eslint.org/" target="_blank" rel="external">官方文档</a><br><img src="http://eslint.org/img/logo.svg" width="200" alt="" align="center"></p>
<ul>
<li>ESLint使用<a href="https://github.com/eslint/espree" target="_blank" rel="external">Espree</a>进行JavaScript解析。</li>
<li>ESLint使用AST来评估代码中的模式。</li>
<li>ESLint配置灵活，每个规则都是一个插件，您可以在运行时添加更多。</li>
</ul>
<h4 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h4><p>有两种方法来安装ESLint：全局和本地。</p>
<h5 id="本地安装和使用"><a href="#本地安装和使用" class="headerlink" title="本地安装和使用"></a>本地安装和使用</h5><p>如果要将ESLint作为项目构建系统的一部分，我们建议您在本地进行安装。 你可以使用npm：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install eslint --save-dev</span><br></pre></td></tr></table></figure>
<p>然后应该初始化一个配置文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./node_modules/.bin/eslint --init</span><br></pre></td></tr></table></figure>
<p>之后，您可以在任何文件或目录下运行ESLint，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./node_modules/.bin/eslint yourFile.js</span><br></pre></td></tr></table></figure>
<p>您使用的任何插件或可共享配置也必须在本地安装以与本地安装的ESLint配合使用。</p>
<h5 id="全局安装和使用"><a href="#全局安装和使用" class="headerlink" title="全局安装和使用"></a>全局安装和使用</h5><p>安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g eslint</span><br></pre></td></tr></table></figure>
<p>初始化</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eslint --init</span><br></pre></td></tr></table></figure>
<p>运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eslint yourFile.js</span><br></pre></td></tr></table></figure>
<blockquote>
<p>eslint –init只在根据每个项目设置和配置ESLint，并将ESLint及其插件的本地安装运行在运行的目录中。 如果您希望使用ESLint的全局安装，则配置中使用的任何插件也必须全局安装。</p>
</blockquote>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><blockquote>
<p>如果你是1.0.0之前的版本，请参阅 <a href="http://eslint.org/docs/user-guide/migrating-to-1.0.0" target="_blank" rel="external">migration guide</a>.</p>
</blockquote>
<p>运行eslint –init后，您的目录中将有一个.eslintrc文件。 在其中，您将看到一些如下配置的规则:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"rules"</span>: &#123;</span><br><span class="line">        <span class="attr">"semi"</span>: [<span class="string">"error"</span>, <span class="string">"always"</span>],</span><br><span class="line">        <span class="attr">"quotes"</span>: [<span class="string">"error"</span>, <span class="string">"double"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>属性名“semi”和“quotes”是ESLint中规则的名称。 数组的第一个值是规则的错误级别，可以是以下值之一：</p>
<ul>
<li>“off” 或 0 是关闭规则</li>
<li>“warn” 或 1 将规则作为警告（不影响退出代码）</li>
<li>“error” 或 2 将规则作为错误（退出代码）</li>
</ul>
<p>这三个错误级别允许您细分控制ESLint应用规则（有关更多配置选项和详细信息，请参阅<a href="http://eslint.org/docs/user-guide/configuring" target="_blank" rel="external">配置文档</a>）。</p>
<p>你的 .eslintrc 配置文件将会包含下列选项：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"extends": "eslint:recommended"</span><br></pre></td></tr></table></figure></p>
<p>由于这一行，规则页面上标记为“yes”的所有规则将被打开。 或者，您可以通过在npmjs.com上搜索“eslint-config”来使用其他人创建的配置，例如<a href="https://github.com/sivan/javascript-style-guide/blob/master/es5/README.md" target="_blank" rel="external">Airbnb JavaScript Style Guide</a>、<a href="https://github.com/feross/standard/blob/master/docs/README-zhtw.md" target="_blank" rel="external">standard</a>。 ESLint不会删除您的代码，除非您从共享配置中扩展或在配置中明确地打开规则。</p>
<h3 id="规则-rules"><a href="#规则-rules" class="headerlink" title="规则:rules"></a>规则:rules</h3><p>ESLint中的规则按类别分组，以帮助您了解其目的。</p>
<blockquote>
<p>默认情况下不启用任何规则。 配置文件中的“extends”：“eslint：recommended”属性可以启用报告常见问题的规则，下面有一个为 “yes” 的复选标记。</p>
</blockquote>
<p>命令行加上–fix选项会自动修复下面有扳手 “fix” 的规则报告的问题（目前大部分为空格）。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eslint yourFile.js --fix</span><br></pre></td></tr></table></figure></p>
<h4 id="可能导致的错误"><a href="#可能导致的错误" class="headerlink" title="可能导致的错误"></a>可能导致的错误</h4><p>这些规则与JavaScript代码中可能的语法或逻辑错误有关：</p>
<table>
<thead>
<tr>
<th>eslint:recommended</th>
<th>可被修复</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>x</td>
<td>no-await-in-loop</td>
<td>不允许在循环内使用await</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-compare-neg-zero</td>
<td>不允许与-0比较</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-cond-assign</td>
<td>在条件表达式中禁止使用赋值运算符</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-console</td>
<td>禁止使用console</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-constant-condition</td>
<td>禁止条件下的常量表达式</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-control-regex</td>
<td>禁止正则表达式中的控制字符 ：new RegExp(“\x1f”)</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-debugger</td>
<td>禁止使用debugger</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-dupe-args</td>
<td>禁止函数中定义重复参数</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-dupe-keys</td>
<td>禁止在对象中有重复的属性名</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-duplicate-case</td>
<td>禁止重复的case标签</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-empty</td>
<td>禁止空语句块</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-empty-character-class</td>
<td>禁止在正则表达式中使用空字符集 (/^abc[]/)</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-ex-assign</td>
<td>禁止对 catch 子句的参数重新赋值</td>
</tr>
<tr>
<td>yes</td>
<td>fix</td>
<td>no-extra-boolean-cast</td>
<td>禁止不必要的布尔转换</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>no-extra-parens</td>
<td>禁止不必要的括号 (a * b) + c</td>
</tr>
<tr>
<td>yes</td>
<td>fix</td>
<td>no-extra-semi</td>
<td>禁止不必要的分号</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-func-assign</td>
<td>禁止对 function 声明重新赋值</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-inner-declarations</td>
<td>禁止在嵌套的块中出现 function 或 var 声明</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-invalid-regexp</td>
<td>禁止 RegExp 构造函数中无效的正则表达式字符串</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-irregular-whitespace</td>
<td>禁止在字符串和注释之外不规则的空白</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-obj-calls</td>
<td>禁止直接使用 Object.prototypes 的内置属性</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-prototype-builtins</td>
<td>禁止直接使用 Object.prototypes 的内置属性</td>
</tr>
<tr>
<td>yes</td>
<td>fix</td>
<td>no-regex-spaces</td>
<td>禁止正则表达式字面量中出现多个空格</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-sparse-arrays</td>
<td>禁用稀疏数组</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-template-curly-in-string</td>
<td>禁止常规字符串中使用的模板字符串语法</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-unexpected-multiline</td>
<td>禁止出现令人困惑的多行表达式</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-unreachable</td>
<td>禁止在return、throw、continue 和 break语句之后出现不可达代码</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-unsafe-finally</td>
<td>禁止在finally代码块中使用控制流语句</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>no-unsafe-negation</td>
<td>不允许否定关系运算符左边的操作数</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>use-isnan</td>
<td>要求使用 isNaN() 检查 NaN</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>valid-jsdoc</td>
<td>强制使用有效的 JSDoc 注释</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>valid-typeof</td>
<td>强制 typeof 表达式与有效的字符串进行比较</td>
</tr>
</tbody>
</table>
<h4 id="最佳做法"><a href="#最佳做法" class="headerlink" title="最佳做法"></a>最佳做法</h4><p>这些规则涉及更好的方法来帮助您避免问题：</p>
<table>
<thead>
<tr>
<th>eslint:recommended</th>
<th>可被修复</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>x</td>
<td>accessor-pairs</td>
<td>在对象中强制使用getter和setter</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>array-callback-return</td>
<td>在数组方法的回调中使用返回语句</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>block-scoped-var</td>
<td>强制把变量的使用限制在其定义的作用域范围内</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>class-methods-use-this</td>
<td>强制将在的方法中利用“this”</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>complexity</td>
<td>强制执行一个程序允许的最大循环复杂度</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>curly</td>
<td>对所有控制语句使用一致的括号风格</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>default-case</td>
<td>switch 语句强制 default 分支，也可添加 // no default 注释取消此次警告</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>dot-location</td>
<td>在’.’之前和之后一致的换行符</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>dot-notation</td>
<td>强制使用.号取属性</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>eqeqeq</td>
<td>使用===、!==替代==、!=</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>guard-for-in</td>
<td>要求for-in循环包含一个if语句</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-alert</td>
<td>禁止使用alert，confirm和prompt</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-caller</td>
<td>不允许使用arguments.caller或arguments.callee</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-case-declarations</td>
<td>在case子句中禁止词法声明</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-div-regex</td>
<td>禁止除法操作符显式的出现在正则表达式开始的位置</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>no-else-return</td>
<td>禁止 if 语句中有 return 之后有 else</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-empty-function</td>
<td>禁止出现空函数.如果一个函数包含了一条注释，它将不会被认为有问题</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-empty-pattern</td>
<td>禁止使用空解构模式no-empty-pattern</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-eq-null</td>
<td>禁止在没有类型检查操作符的情况下与 null 进行比较</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-eval</td>
<td>禁用 eval()</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-extend-native</td>
<td>禁止扩展原生类型</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>no-extra-bind</td>
<td>禁止不必要的 .bind() 调用</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>no-extra-label</td>
<td>禁用不必要的标签</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-fallthrough</td>
<td>禁止 case 语句落空</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>no-floating-decimal</td>
<td>禁止数字字面量中使用前导和末尾小数点</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-global-assign</td>
<td>不允许对本地对象或只读全局变量分配</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>no-implicit-coercion</td>
<td>禁止使用短符号进行类型转换(!!fOO)</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-implied-eval</td>
<td>禁止使用类似 eval() 的方法</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-invalid-this</td>
<td>禁止 this 关键字出现在类和类对象之外</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-iterator</td>
<td>禁用 <strong>iterator</strong> 属性</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-labels</td>
<td>禁用标签语句</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-lone-blocks</td>
<td>禁用不必要的嵌套块</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-loop-func</td>
<td>禁止在循环中出现 function 声明和表达式</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-magic-numbers</td>
<td>禁用魔术数字(3.14什么的用常量代替)</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>no-multi-spaces</td>
<td>禁止使用多个空格</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-multi-str</td>
<td>禁止使用多行字符串，在 JavaScript 中，可以在新行之前使用斜线创建多行字符串</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-new</td>
<td>禁止在非赋值或条件语句中使用 new 操作符</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-new-func</td>
<td>禁止对 Function 对象使用 new 操作符</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-new-wrappers</td>
<td>禁止对 String，Number 和 Boolean 使用 new 操作符</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-octal</td>
<td>禁用八进制字面量</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-octal-escape</td>
<td>禁止在字符串中使用八进制转义序列</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-param-reassign</td>
<td>不允许对 function 的参数进行重新赋值</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-proto</td>
<td>禁用 <strong>proto</strong> 属性</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-redeclare</td>
<td>禁止使用 var 多次声明同一变量</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-restricted-properties</td>
<td>禁止某些对象上的某些属性</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-return-assign</td>
<td>禁用指定的通过 require 加载的模块</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-return-await</td>
<td>禁止不必要的return await</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-script-url</td>
<td>禁止使用 javascript: url</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-self-assign</td>
<td>禁止自我赋值</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-self-compare</td>
<td>禁止自身比较</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-sequences</td>
<td>禁用逗号操作符</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-throw-literal</td>
<td>禁止抛出非异常字面量</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-unmodified-loop-condition</td>
<td>禁用一成不变的循环条件</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-unused-expressions</td>
<td>禁止出现未使用过的表达式</td>
</tr>
<tr>
<td>yes</td>
<td>fix</td>
<td>no-unused-labels</td>
<td>禁用未使用过的标签</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-useless-call</td>
<td>禁止不必要的 .call() 和 .apply()</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-useless-concat</td>
<td>禁止不必要的字符串字面量或模板字面量的连接</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-useless-escape</td>
<td>禁用不必要的转义字符</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>no-useless-return</td>
<td>不允许冗余return语句</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-void</td>
<td>禁用 void 操作符</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-warning-comments</td>
<td>禁止在注释中使用特定的警告术语</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-with</td>
<td>禁用 with 语句</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>prefer-promise-reject-errors</td>
<td>要求将Error对象用作“Promise”拒绝原因</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>radix</td>
<td>强制在parseInt()使用基数参数</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>require-await</td>
<td>禁止async函数中没有await表达式</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>vars-on-top</td>
<td>要求所有的 var 声明出现在它们所在的作用域顶部</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>wrap-iife</td>
<td>要求 IIFE 使用括号括起来</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>yoda</td>
<td>要求或禁止 “Yoda” 条件</td>
</tr>
</tbody>
</table>
<h4 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h4><table>
<thead>
<tr>
<th>eslint:recommended</th>
<th>可被修复</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>fix</td>
<td>strict</td>
<td>要求或禁止使用严格模式指令</td>
</tr>
</tbody>
</table>
<h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><table>
<thead>
<tr>
<th>eslint:recommended</th>
<th>可被修复</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>x</td>
<td>init-declarations</td>
<td>要求或禁止 var 声明中的初始化(初值)</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-catch-shadow</td>
<td>不允许 catch 子句的参数与外层作用域中的变量同名</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-delete-var</td>
<td>禁止删除变量</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-restricted-globals</td>
<td>禁用特定的全局变量</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-shadow</td>
<td>禁止 var 声明 与外层作用域的变量同名</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-label-var</td>
<td>不允许标签与变量同名</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-shadow-restricted-names</td>
<td>禁止覆盖受限制的标识符</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-undef</td>
<td>禁用未声明的变量，除非它们在 /*global*/ 注释中被提到</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>no-undef-init</td>
<td>禁止将变量初始化为 undefined</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-undefined</td>
<td>禁止将 undefined 作为标识符</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-unused-vars</td>
<td>禁止出现未使用过的变量</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-use-before-define</td>
<td>不允许在变量定义之前使用它们</td>
</tr>
</tbody>
</table>
<h4 id="Node-js-and-CommonJS"><a href="#Node-js-and-CommonJS" class="headerlink" title="Node.js and CommonJS"></a>Node.js and CommonJS</h4><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>callback-return</td>
<td>回调后需要返回的语句</td>
</tr>
<tr>
<td>global-require</td>
<td>要求 require() 出现在顶层模块作用域中</td>
</tr>
<tr>
<td>handle-callback-err</td>
<td>要求回调函数中有容错处理</td>
</tr>
<tr>
<td>no-mixed-requires</td>
<td>禁止混合常规 var 声明和 require 调用</td>
</tr>
<tr>
<td>no-new-require</td>
<td>禁止调用 require 时使用 new 操作符</td>
</tr>
<tr>
<td>no-path-concat</td>
<td>禁止对 __dirname 和 __filename进行字符串连接</td>
</tr>
<tr>
<td>no-process-env</td>
<td>禁用 process.env</td>
</tr>
<tr>
<td>no-process-exit</td>
<td>禁用 process.exit()</td>
</tr>
<tr>
<td>no-sync</td>
<td>禁用同步方法</td>
</tr>
</tbody>
</table>
<h4 id="风格问题"><a href="#风格问题" class="headerlink" title="风格问题"></a>风格问题</h4><table>
<thead>
<tr>
<th>eslint:recommended</th>
<th>可被修复</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>fix</td>
<td>array-bracket-spacing</td>
<td>指定数组的元素之间要以空格隔开(, 后面)， never参数：[ 之前和 ] 之后不能带空格，always参数：[ 之前和 ] 之后必须带空格</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>block-spacing</td>
<td>禁止或强制在单行代码块中使用空格(禁用)</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>brace-style</td>
<td>强制使用一致的缩进 第二个参数为 tab 时，会使用tab，</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>camelcase</td>
<td>双峰驼命名格式</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>capitalized-comments</td>
<td>执行或不允许评论的第一个字母大写</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>comma-spacing</td>
<td>控制逗号前后的空格</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>comma-dangle</td>
<td>要求不允许逗号</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>comma-style</td>
<td>控制逗号在行尾出现还是在行首出现 (默认行尾)</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>computed-property-spacing</td>
<td>以方括号取对象属性时，[ 后面和 ] 前面是否需要空格, 可选参数 never, always</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>consistent-this</td>
<td>用于指统一在回调函数中指向this的变量名，箭头函数中的this已经可以指向外层调用者，应该没卵用了</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>func-names</td>
<td>强制使用命名的 function 表达式</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>eol-last</td>
<td>文件末尾强制换行</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>indent</td>
<td>执行一致的缩进</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>key-spacing</td>
<td>强制在对象字面量的属性中键和值之间使用一致的间距</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>linebreak-style</td>
<td>强制使用一致的换行风格</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>lines-around-comment</td>
<td>要求在注释周围有空行      ( 要求在块级注释之前有一空行)</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>func-style</td>
<td>强制一致地使用函数声明或函数表达式，方法定义风格，参数：</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>max-nested-callbacks</td>
<td>强制回调函数最大嵌套深度 5层</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>id-blacklist</td>
<td>禁止使用指定的标识符</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>id-length</td>
<td>强制标识符的最新和最大长度</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>id-match</td>
<td>要求标识符匹配一个指定的正则表达式</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>jsx-quotes</td>
<td>强制在 JSX 属性中一致地使用双引号或单引号</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>keyword-spacing</td>
<td>强制在关键字前后使用一致的空格 (前后腰需要)</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>max-len</td>
<td>强制一行的最大长度</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>max-lines</td>
<td>强制最大行数</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>max-params</td>
<td>强制 function 定义中最多允许的参数数量</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>max-statements</td>
<td>强制 function 块最多允许的的语句数量</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>max-statements-per-line</td>
<td>强制每一行中所允许的最大语句数量</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>new-cap</td>
<td>要求构造函数首字母大写  （要求调用 new 操作符时有首字母大小的函数，允许调用首字母大写的函数时没有 new 操作符。）</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>new-parens</td>
<td>要求调用无参构造函数时有圆括号</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>newline-after-var</td>
<td>要求或禁止 var 声明语句后有一行空行</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-array-constructor</td>
<td>禁止使用 Array 构造函数</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-bitwise</td>
<td>禁用按位运算符</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>newline-before-return</td>
<td>要求 return 语句之前有一空行</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>newline-per-chained-call</td>
<td>要求方法链中每个调用都有一个换行符</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-continue</td>
<td>禁用 continue 语句</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-inline-comments</td>
<td>禁止在代码行后使用内联注释</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>no-lonely-if</td>
<td>禁止 if 作为唯一的语句出现在 else 语句中</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-mixed-operators</td>
<td>禁止混合使用不同的操作符</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-mixed-spaces-and-tabs</td>
<td>不允许空格和 tab 混合缩进</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>no-multiple-empty-lines</td>
<td>不允许多个空行</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-negated-condition</td>
<td>不允许否定的表达式</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-nested-ternary</td>
<td>不允许使用嵌套的三元表达式</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-new-object</td>
<td>禁止使用 Object 的构造函数</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-plusplus</td>
<td>禁止使用一元操作符 ++ 和 –</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-restricted-syntax</td>
<td>禁止使用特定的语法</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-spaced-func</td>
<td>禁止 function 标识符和括号之间出现空格</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-ternary</td>
<td>不允许使用三元操作符</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>no-trailing-spaces</td>
<td>禁用行尾空格</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-underscore-dangle</td>
<td>禁止标识符中有悬空下划线_bar</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>no-unneeded-ternary</td>
<td>禁止可以在有更简单的可替代的表达式时使用三元操作符</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>no-whitespace-before-property</td>
<td>禁止属性前有空白</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>object-curly-newline</td>
<td>强制花括号内换行符的一致性</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>object-curly-spacing</td>
<td>强制在花括号中使用一致的空格</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>object-property-newline</td>
<td>强制将对象的属性放在不同的行上</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>one-var</td>
<td>强制函数中的变量要么一起声明要么分开声明</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>one-var-declaration-per-line</td>
<td>要求或禁止在 var 声明周围换行</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>operator-assignment</td>
<td>要求或禁止在可能的情况下要求使用简化的赋值操作符</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>operator-linebreak</td>
<td>强制操作符使用一致的换行符</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>padded-blocks</td>
<td>要求或禁止块内填充</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>quote-props</td>
<td>要求对象字面量属性名称用引号括起来</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>quotes</td>
<td>强制使用一致的反勾号、双引号或单引号</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>require-jsdoc</td>
<td>要求使用 JSDoc 注释</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>semi</td>
<td>要求或禁止使用分号而不是 ASI（这个才是控制行尾部分号的，）</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>semi-spacing</td>
<td>强制分号之前和之后使用一致的空格</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>sort-vars</td>
<td>要求同一个声明块中的变量按顺序排列</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>space-before-blocks</td>
<td>强制在块之前使用一致的空格</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>space-before-function-paren</td>
<td>强制在 function的左括号之前使用一致的空格</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>space-in-parens</td>
<td>强制在圆括号内使用一致的空格</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>space-infix-ops</td>
<td>要求操作符周围有空格</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>space-unary-ops</td>
<td>强制在一元操作符前后使用一致的空格</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>spaced-comment</td>
<td>强制在注释中 // 或 /* 使用一致的空格</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>unicode-bom</td>
<td>要求或禁止 Unicode BOM</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>wrap-regex</td>
<td>要求正则表达式被括号括起来</td>
</tr>
</tbody>
</table>
<h4 id="ECMAScript-6"><a href="#ECMAScript-6" class="headerlink" title="ECMAScript 6"></a>ECMAScript 6</h4><table>
<thead>
<tr>
<th>eslint:recommended</th>
<th>可被修复</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>x</td>
<td>fix</td>
<td>arrow-body-style</td>
<td>要求箭头函数体使用大括号</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>arrow-parens</td>
<td>要求箭头函数的参数使用圆括号</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>constructor-super</td>
<td>强制在子类构造函数中用super()调用父类构造函数，TypeScrip的编译器也会提示</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>generator-star-spacing</td>
<td>强制 generator 函数中 * 号周围使用一致的空格</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-class-assign</td>
<td>禁止修改类声明的变量</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-confusing-arrow</td>
<td>不允许箭头功能，在那里他们可以混淆的比较</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-const-assign</td>
<td>禁止修改 const 声明的变量</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-dupe-class-members</td>
<td>禁止类成员中出现重复的名称</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-duplicate-imports</td>
<td>不允许复制模块的进口</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-new-symbol</td>
<td>禁止 Symbol  的构造函数</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>no-restricted-imports</td>
<td>允许指定模块加载时的进口</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>no-this-before-super</td>
<td>禁止在构造函数中，在调用 super() 之前使用 this 或 super</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>no-useless-computed-key</td>
<td>禁止不必要的计算性能键对象的文字</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>no-var</td>
<td>要求使用 let 或 const 而不是 var</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>object-shorthand</td>
<td>要求或禁止对象字面量中方法和属性使用简写语法</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>prefer-arrow-callback</td>
<td>要求使用箭头函数作为回调</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>prefer-const</td>
<td>要求使用 const 声明那些声明后不再被修改的变量</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>prefer-reflect</td>
<td>要求在合适的地方使用 Reflect 方法</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>prefer-spread</td>
<td>要求使用扩展运算符而非 .apply()</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>prefer-template</td>
<td>要求使用模板字面量而非字符串连接</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>prefer-rest-params</td>
<td>对于arguments使用…rest</td>
</tr>
<tr>
<td>yes</td>
<td>x</td>
<td>require-yield</td>
<td>要求generator 函数内有 yield</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>rest-spread-spacing</td>
<td>“rest”和扩展运算符及其表达式之间的间距</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>sort-imports</td>
<td>强制模块内的 import 排序</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>template-curly-spacing</td>
<td>要求或禁止模板字符串中的嵌入表达式周围空格的使用</td>
</tr>
<tr>
<td>x</td>
<td>fix</td>
<td>yield-star-spacing</td>
<td>强制在 yield<em> 表达式中 </em> 周围使用空格</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;esLint入门&quot;&gt;&lt;a href=&quot;#esLint入门&quot; class=&quot;headerlink&quot; title=&quot;esLint入门&quot;&gt;&lt;/a&gt;esLint入门&lt;/h3&gt;&lt;p&gt;ESLint是用于识别和报告ECMAScript / JavaScript代码书写风格的工具，目的是使代码更加一致并避免错误。 在许多方面，它与JSLint和JSHint类似，但有一些例外：&lt;br&gt;
    
    </summary>
    
      <category term="代码风格" scheme="https://wangzongxu.github.io/categories/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/"/>
    
    
      <category term="代码风格" scheme="https://wangzongxu.github.io/tags/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/"/>
    
  </entry>
  
  <entry>
    <title>hexo</title>
    <link href="https://wangzongxu.github.io/2017/09/21/hexo/"/>
    <id>https://wangzongxu.github.io/2017/09/21/hexo/</id>
    <published>2017-09-21T09:09:24.000Z</published>
    <updated>2017-09-21T09:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。<br><a id="more"></a></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序：</p>
<ul>
<li><a href="http://nodejs.org/" target="_blank" rel="external">node</a></li>
<li><a href="http://git-scm.com/" target="_blank" rel="external">git</a></li>
</ul>
<p>安装hexo</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<blockquote>
<p>node版本5.0或更高导致报错，但不影响hexo的正常使用</p>
</blockquote>
<h3 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h3><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line"><span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>新建完成后，指定文件夹的目录如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>
<h3 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h3><p>网站的 配置 信息，您可以在此配置大部分的参数。</p>
<h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p>应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"hexo-site"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.0"</span>,</span><br><span class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"hexo"</span>: &#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">""</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"hexo"</span>: <span class="string">"^3.0.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-archive"</span>: <span class="string">"^0.1.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-category"</span>: <span class="string">"^0.1.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-index"</span>: <span class="string">"^0.1.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-tag"</span>: <span class="string">"^0.1.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-renderer-ejs"</span>: <span class="string">"^0.1.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-renderer-stylus"</span>: <span class="string">"^0.2.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-renderer-marked"</span>: <span class="string">"^0.2.4"</span>,</span><br><span class="line">    <span class="attr">"hexo-server"</span>: <span class="string">"^0.1.2"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="scaffolds"><a href="#scaffolds" class="headerlink" title="scaffolds"></a>scaffolds</h3><p>模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。<br>Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。</p>
<h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><p>资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</p>
<h3 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h3><p><a href="https://hexo.io/themes/" target="_blank" rel="external">主题</a> 文件夹。Hexo 会根据主题来生成静态页面。</p>
<ol>
<li>在themes文件夹下新建一个文件夹准备存放主题文件，例如命名为’simple’</li>
<li>更改根目录下_config.yml文件中的theme字段的值为 simple（注意空格开头）</li>
<li>选择喜欢的<a href="https://hexo.io/themes/" target="_blank" rel="external">主题</a>并下载解压到刚刚创建的simple文件夹下</li>
<li>命令行执行 hexo server</li>
</ol>
<h3 id="一键部署到Github"><a href="#一键部署到Github" class="headerlink" title="一键部署到Github"></a>一键部署到Github</h3><ol>
<li>在自己github下新建一个仓库并命名为‘github用户名’+’.github.io’</li>
<li><p>编辑根目录下的_config.yml,拖到最下方,找到deploy标签,然后更为如下配置,注意:你自己在修改时,需要将 xxxxx修改为自己的github用户名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repository: https://github.com/xxxxx/xxxxx.github.io.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装插件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git –save</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译<br>执行项目清理和静态网页生成</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br></pre></td></tr></table></figure>
</li>
<li><p>部署</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
</li>
<li><p>完成<br>去自己刚刚建立的github仓库查看是否成功部署</p>
</li>
</ol>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hexo init [blogName] <span class="comment">#初始化博客</span></span><br><span class="line">hexo version <span class="comment">#hexo版本</span></span><br><span class="line">hexo new <span class="string">"我的博客"</span> ==hexo n <span class="string">"我的博客"</span><span class="comment">#新建文章</span></span><br><span class="line">hexo publish  == hexo p <span class="comment">#发表草稿</span></span><br><span class="line">hexo generate == hexo g <span class="comment">#生成</span></span><br><span class="line">hexo clean <span class="comment">#清除缓存文件 (db.json) 和已生成的静态文件 (public)</span></span><br><span class="line">hexo server == hexo s <span class="comment">#启动服务预览</span></span><br><span class="line">hexo deploy ==hexo d <span class="comment">#部署</span></span><br></pre></td></tr></table></figure>
<h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hexo server <span class="comment">#Hexo 会监视文件变动并自动更新，您无须重启服务器。</span></span><br><span class="line">hexo server -s <span class="comment">#静态模式</span></span><br><span class="line">hexo server -p 5000 <span class="comment">#更改端口</span></span><br><span class="line">hexo server -i 192.168.1.1 <span class="comment">#自定义 IP</span></span><br><span class="line"></span><br><span class="line">hexo clean <span class="comment">#清除缓存 网页正常情况下可以忽略此条命令</span></span><br><span class="line">hexo g <span class="comment">#生成静态网页</span></span><br><span class="line">hexo d <span class="comment">#开始部署</span></span><br></pre></td></tr></table></figure>
<h3 id="监视文件变动"><a href="#监视文件变动" class="headerlink" title="监视文件变动"></a>监视文件变动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate <span class="comment">#生成静态文件</span></span><br><span class="line">hexo generate --watch <span class="comment">#监视文件变动自动生成静态文件</span></span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。&lt;br&gt;
    
    </summary>
    
      <category term="博客" scheme="https://wangzongxu.github.io/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="博客" scheme="https://wangzongxu.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>jsonp原理</title>
    <link href="https://wangzongxu.github.io/2017/09/21/jsonp/"/>
    <id>https://wangzongxu.github.io/2017/09/21/jsonp/</id>
    <published>2017-09-21T09:09:24.000Z</published>
    <updated>2017-09-21T09:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>介绍jsonp实现原理</p>
<a id="more"></a>
<h3 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h3><blockquote>
<p>三要素:协议 域名 端口</p>
</blockquote>
<ul>
<li><p>什么是同域请求?<br>一个请求的url三要素与当前页面url的三要素相同的请求叫做同域请求</p>
</li>
<li><p>什么是跨域请求?<br>一个请求的url三要素与当前页面url的三要素只要有一个不同,那么这个请求就是跨域请求.<br>例如：<a href="http://www.baidu.com" target="_blank" rel="external">http://www.baidu.com</a> 和 <a href="http://tieba.baidu.com" target="_blank" rel="external">http://tieba.baidu.com</a> 的域名不一样，造成跨域</p>
</li>
</ul>
<h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><p>它是一种浏览器厂商为了安全,强制添加的一种安全限制.<br>它限制了js在哪些地方(同域请求中)可以用,哪些地方(跨域请求中)不可以用.</p>
<h3 id="如何安全绕过同源策略的限制"><a href="#如何安全绕过同源策略的限制" class="headerlink" title="如何安全绕过同源策略的限制?"></a>如何安全绕过同源策略的限制?</h3><p>平时可能注意过，当img、script、iframe标签的src引用地址是可以引用跨域资源的。比较img script iframe 这三个标签的特点：</p>
<ul>
<li>img的特点</li>
</ul>
<ol>
<li>加载跨域资源时不受同源策略的限制</li>
<li>会把加载过来的内容强制当成图片来显示.如果不是合法图片,则显示裂图.</li>
</ol>
<ul>
<li>script的特点</li>
</ul>
<ol>
<li>加载跨域资源时不受同源策略的限制</li>
<li>会把加载过来的内容强制当成脚本来执行.如果返回的数据不是合法的脚本,则执行出错.</li>
</ol>
<ul>
<li>iframe</li>
</ul>
<ol>
<li>加载跨域资源时不受同源策略的限制</li>
<li>数据可以成功加载进来,但是由于同源策略的限制无法获取里头的内容.</li>
</ol>
<ul>
<li>比较以上特点，我们可以利用script标签的这两个特点,来实现一个跨域请求.</li>
</ul>
<h3 id="jsonp的原理"><a href="#jsonp的原理" class="headerlink" title="jsonp的原理:"></a>jsonp的原理:</h3><ol>
<li>利用script标签实现跨域请求,<script src="http://www.abc.com?callback=functionName"></script></li>
<li>server定义好的那个用来设置返回数据中执行函数的函数名的那个参数就叫callback;(参见示例中的jsonp参数)</li>
<li>callback后面跟的value(参见示例中的randomName方法的执行)必须是全局作用域下的一个函数</li>
<li>server返回的数据格式是固定的: functionName( /*json data*/ );</li>
</ol>
<h3 id="为什么叫jsonp"><a href="#为什么叫jsonp" class="headerlink" title="为什么叫jsonp?"></a>为什么叫jsonp?</h3><ol>
<li>根据返回的数据格式来看：函数名 + json数据<br>即：functionName + json data</li>
<li>用语言表达出来：函数名装入一个json数据<br>即：functionName append a json data</li>
<li>更换主语：json数据填入到一个函数名内<br>即：json data padding a functionName</li>
<li>缩句：json数据填入函数名<br>即：json padding functionName =&gt;</li>
<li>缩句（专注过程）：一个json填充的过程<br>即：json padding</li>
<li>再缩句<br>即：jsonp</li>
</ol>
<h3 id="jsonp的注意事项"><a href="#jsonp的注意事项" class="headerlink" title="jsonp的注意事项:"></a>jsonp的注意事项:</h3><ol>
<li>因为jsonp是通过script的src属性去加载跨域资资源,所以jsonp请求全部都是get方法请求.</li>
<li>get系方法有的特点jsonp全有</li>
<li>所有的jsonp接口必须含有一个callback,否则不是合法的jsonp接口.</li>
<li>所有的jsonp接口必须按照格式返回 =&gt; functionName( /*json data*/ );</li>
</ol>
<h3 id="jsonp为什么不是ajax"><a href="#jsonp为什么不是ajax" class="headerlink" title="jsonp为什么不是ajax?"></a>jsonp为什么不是ajax?</h3><ol>
<li>因为ajax是通过浏览器提供的操作http请求的API来实现的.</li>
<li>jsonp是通过script实现的.所以jsonp不是ajax.</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理模块化兼容：</span></span><br><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params">name, factory</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">'function'</span>) &#123; <span class="comment">// requireJs</span></span><br><span class="line">    define(factory);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">'object'</span> &amp;&amp; <span class="built_in">module</span>.exports) &#123; <span class="comment">// commonJs</span></span><br><span class="line">    <span class="built_in">module</span>.exports = factory();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不支持模块化，将jsonp方法放在window上</span></span><br><span class="line">    <span class="keyword">this</span>[name] = factory();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="string">'jsonp'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定义一些需要的方法:</span></span><br><span class="line">  <span class="keyword">var</span> tools = &#123;</span><br><span class="line">    <span class="comment">// 合并对象</span></span><br><span class="line">    extends: <span class="function"><span class="keyword">function</span>(<span class="params">target, mix</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> mix) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mix.hasOwnProperty(key)) &#123;</span><br><span class="line">          target[key] = mix[key]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 格式化参数</span></span><br><span class="line">    queryString:<span class="function"><span class="keyword">function</span>(<span class="params">str, obj</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> params = [];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">          params.push(key + <span class="string">'='</span> + obj[key])</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">var</span> fields = params.join(<span class="string">'&amp;'</span>);</span><br><span class="line">      <span class="keyword">if</span> (fields.length === <span class="number">0</span>)<span class="keyword">return</span> str;</span><br><span class="line">      <span class="keyword">if</span> (str.indexOf(<span class="string">'?'</span>) &gt; <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> str + fields</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> str + <span class="string">'?'</span> + fields</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 类型判断</span></span><br><span class="line">    type:<span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="regexp">/\[object\s(\w+)\]/</span>.exec(</span><br><span class="line">        <span class="built_in">Object</span>.prototype.toString.call(target)</span><br><span class="line">      )[<span class="number">1</span>];</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 创建全局functionName随机名称</span></span><br><span class="line">    randomName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'jsonp'</span> + <span class="built_in">Math</span>.random().toString().substr(<span class="number">2</span>,<span class="number">7</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对外暴露接口</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">opt</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 定义默认参数</span></span><br><span class="line">    <span class="keyword">var</span> fields = &#123;</span><br><span class="line">      <span class="attr">url</span>: <span class="string">''</span>, <span class="comment">// 接口地址</span></span><br><span class="line">      data: &#123;&#125;, <span class="comment">// 参数（问号传参）</span></span><br><span class="line">      context: <span class="built_in">window</span>, <span class="comment">// success、error、complete三个函数的上下文环境</span></span><br><span class="line">      jsonp: <span class="string">'callback'</span>, <span class="comment">// 与server端约定的jsonp参数名</span></span><br><span class="line">      success: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;, <span class="comment">// 成功的对调</span></span><br><span class="line">      error: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;, <span class="comment">// 失败的回调</span></span><br><span class="line">      complete: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 执行完成的回调</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将用户传入的参数与默认参数融合</span></span><br><span class="line">    tools.extends(fields, opt);</span><br><span class="line">    <span class="comment">// 参数不正确进行报错</span></span><br><span class="line">    <span class="keyword">if</span> (!fields.url) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'url must be string'</span>);</span><br><span class="line">    <span class="keyword">if</span> (tools.type(fields.url) !== <span class="string">'String'</span> ||</span><br><span class="line">        tools.type(fields.jsonp) !== <span class="string">'String'</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'url and jsonp must be string'</span>);</span><br><span class="line">    <span class="keyword">if</span> (tools.type(fields.data) !== <span class="string">'Object'</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'data must be object'</span>);</span><br><span class="line">    <span class="keyword">if</span> (tools.type(fields.success) !== <span class="string">'Function'</span> ||</span><br><span class="line">        tools.type(fields.error) !== <span class="string">'Function'</span> ||</span><br><span class="line">        tools.type(fields.complete) !== <span class="string">'Function'</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'success、error and complete must be function'</span>);</span><br><span class="line">    <span class="comment">// 生成随机全局functionName</span></span><br><span class="line">    <span class="keyword">var</span> tempName = tools.randomName();</span><br><span class="line">    <span class="comment">// 因为functionName也要序列化到url上，所以将functionName加入data参数中</span></span><br><span class="line">    fields.data[fields.jsonp] = tempName;</span><br><span class="line">    <span class="comment">// 序列化生成新url</span></span><br><span class="line">    <span class="keyword">var</span> url = tools.queryString(fields.url, fields.data);</span><br><span class="line">    <span class="comment">// 根据functionName定义全局可执行函数</span></span><br><span class="line">    <span class="built_in">window</span>[tempName] = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 该方法被调用后执行成功的回调并更改上下文环境</span></span><br><span class="line">      fields.success.call(fields.context, data);</span><br><span class="line">      <span class="comment">// 执行完成</span></span><br><span class="line">      complete(tempName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建script标签</span></span><br><span class="line">    createScriptNode(url, tempName);</span><br><span class="line">    <span class="comment">// 这里根据url创建了一个script标签并插入body，将functionName作为其id，以后用来删除</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">createScriptNode</span>(<span class="params">url, tempName</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">      script.id = tempName;</span><br><span class="line">      <span class="comment">// 异步加载，防阻塞</span></span><br><span class="line">      script.async = <span class="literal">true</span>;</span><br><span class="line">      script.src = url;</span><br><span class="line">      <span class="comment">// 处理错误</span></span><br><span class="line">      script.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">          <span class="comment">// 该方法被调用后执行失败的回调并更改上下文环境</span></span><br><span class="line">        fields.error.call(fields.context, err);</span><br><span class="line">        <span class="comment">// 执行完成</span></span><br><span class="line">        complete(tempName);</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// 插入body</span></span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据functionName删除script标签</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">removeScriptNode</span>(<span class="params">tempName</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> script = <span class="built_in">document</span>.getElementById(tempName);</span><br><span class="line">      <span class="built_in">document</span>.body.removeChild(script);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行完成</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">complete</span>(<span class="params">tempName</span>)</span>&#123;</span><br><span class="line">      <span class="comment">// 删除全局可执行函数</span></span><br><span class="line">      <span class="keyword">delete</span> <span class="built_in">window</span>[tempName];</span><br><span class="line">      <span class="comment">// 删除标签</span></span><br><span class="line">      removeScriptNode(tempName);</span><br><span class="line">      <span class="comment">// 执行完成的回调</span></span><br><span class="line">      fields.complete.call(fields.context);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍jsonp实现原理&lt;/p&gt;
    
    </summary>
    
      <category term="jsonp" scheme="https://wangzongxu.github.io/categories/jsonp/"/>
    
    
      <category term="jsonp" scheme="https://wangzongxu.github.io/tags/jsonp/"/>
    
  </entry>
  
  <entry>
    <title>BS 架构概述</title>
    <link href="https://wangzongxu.github.io/2017/09/21/BS/"/>
    <id>https://wangzongxu.github.io/2017/09/21/BS/</id>
    <published>2017-09-21T09:09:24.000Z</published>
    <updated>2017-09-21T09:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>B/S结构即浏览器和服务器结构。<br><a id="more"></a><br></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>它是随着互联网s技术的兴起，对C/S结构的一种变化或者改进的结构。<br>在这种结构下，用户工作界面是通过WWW浏览器来实现，极少部分事务逻辑在前端(Browser)实现，但是主要事务逻辑在服务器端(Server)实现，形成所谓三层3-tier结构。<br>B/S结构是WEB兴起后的一种网络结构模式，WEB浏览器是客户端最主要的应用软件。这种模式统一了客户端，将系统功能实现的核心部分集中到服务器上，简化了系统的开发、维护和使用。<br>客户机上只要安装一个浏览器（Browser），服务器安装Oracle、Sybase、Informix或 SQL Server等数据库。浏览器通过Web Server同数据库进行数据交互。 这样就大大简化了客户端电脑载荷，减轻了系统维护与升级的成本和工作量，降低了用户的总体成本(TCO)。</p>
<h2 id="维护和升级"><a href="#维护和升级" class="headerlink" title="维护和升级"></a>维护和升级</h2><p>软件系统的改进和升级越来越频繁，B/S架构的产品明显体现着更为方便的特性。<br>对一个稍微大一点单位来说，系统管理人员如果需要在几百甚至上千部电脑之间来回奔跑，效率和工作量是可想而知的，但B/S架构的软件只需要管理服务器就行了，所有的客户端只是浏览器，根本不需要做任何的维护。<br>无论用户的规模有多大，有多少分支机构都不会增加任何维护升级的工作量，所有的操作只需要针对服务器进行；如果是异地，只需要把服务器连接专网即可，实现远程维护、升级和共享。所以客户机越来越“瘦”，而服务器越来越“胖”是将来信息化发展的主流方向。<br>今后，软件升级和维护会越来越容易，而使用起来会越来越简单，这对用户人力、物力、时间、费用的节省是显而易见的，惊人的。因此，维护和升级革命的方式是“瘦”客户机，“胖”服务器。</p>
<h2 id="成本与选择"><a href="#成本与选择" class="headerlink" title="成本与选择"></a>成本与选择</h2><p>大家都知道windows在桌面电脑上几乎一统天下，浏览器成为了标准配置。<br>但在服务器操作系统上，windows并不是处于绝对的统治地位。<br>软件的趋势是凡使用B/S架构的应用管理软件，只需安装在Linux服务器上即可，而且安全性高。<br>所以服务器操作系统的选择是很多的，不管选用那种操作系统都可以让大部分人使用windows作为桌面操作系统电脑不受影响，这就使得最流行免费的Linux操作系统快速发展起来，Linux除了操作系统是免费的以外，连数据库也是免费的，这种选择非常盛行。</p>
<h2 id="负荷重"><a href="#负荷重" class="headerlink" title="负荷重"></a>负荷重</h2><p>由于B/S架构管理软件只安装在服务器端（Server）上，网络管理人员只需要管理服务器就行了，用户界面主要事务逻辑在服务器（Server）端完全通过WWW浏览器实现，极少部分事务逻辑在前端（Browser）实现，所有的客户端只有浏览器，网络管理人员只需要做硬件维护。<br>但是，应用服务器运行数据负荷较重，一旦发生服务器“崩溃”等问题，后果不堪设想。因此，许多单位都备有数据库存储服务器，以防万一。</p>
<h2 id="C-S特点"><a href="#C-S特点" class="headerlink" title="C/S特点"></a>C/S特点</h2><p>C/S又称Client/Server或客户/服务器模式。<br>服务器通常采用高性能的PC、工作站或小型机，并采用大型数据库系统，如Oracle、Sybase、Informix或 SQL Server。客户端需要安装专用的客户端软件。<br>C/S的优点是能充分发挥客户端PC的处理能力，很多工作可以在客户端处理后再提交给服务器。对应的优点就是客户端响应速度快。缺点主要有以下几个：  </p>
<p>而随着互联网的飞速发展，移动办公和分布式办公越来越普及，这需要我们的系统具有扩展性。这种方式远程访问需要专门的技术，同时要对系统进行专门的设计来处理分布式的数据。  </p>
<p>客户端需要安装专用的客户端软件。首先涉及到安装的工作量，其次任何一台电脑出问题，如病毒、硬件损坏，都需要进行安装或维护。特别是有很多分部或专卖店的情况，不是工作量的问题，而是路程的问题。还有，系统软件升级时，每一台客户机需要重新安装，其维护和升级成本非常高。  </p>
<p>对客户端的操作系统一般也会有限制。可能适应于Win98，但不能用于win2000或Windows XP。或者不适用于微软新的操作系统等等，更不用说Linux、Unix等。  </p>
<p>Client/Server是建立在局域网的基础上的。Browser/Server是建立在广域网的基础上的。  </p>
<ol>
<li><p>硬件环境不同：C/S 一般建立在专用的网络上，小范围里的网络环境，局域网之间再通过专门服务器提供连接和数据交换服务。B/S 建立在广域网之上的， 不必是专门的网络硬件环境。例如电话上网,，租用设备.，信息管理，有比C/S更强的适应范围，一般只要有操作系统和浏览器就行。</p>
</li>
<li><p>对安全要求不同：C/S 一般面向相对固定的用户群， 对信息安全的控制能力很强， 一般高度机密的信息系统采用C/S 结构适宜，可以通过B/S发布部分可公开信息。B/S 建立在广域网之上, 对安全的控制能力相对弱，面向是不可知的用户群。</p>
</li>
<li><p>对程序架构不同：C/S 程序可以更加注重流程,，可以对权限多层次校验,，对系统运行速度可以较少考虑。B/S 对安全以及访问速度的多重的考虑,，建立在需要更加优化的基础之上，比C/S有更高的要求。 B/S结构的程序架构是发展的趋势，从MS的.Net系列的BizTalk 2000 Exchange 2000等，全面支持网络的构件搭建的系统.。SUN 和IBM推的JavaBean 构件技术等，使 B/S更加成熟。</p>
</li>
<li><p>软件重用不同：C/S 程序可以不可避免的整体性考虑，构件的重用性不如在B/S要求下的构件的重用性好。B/S 对的多重结构,要求构件相对独立的功能，能够相对较好的重用。</p>
</li>
<li><p>系统维护不同：系统维护在是软件生存周期中，开销大。重要C/S 程序由于整体性,，必须整体考察， 处理出现的问题以及系统升级。升级难，可能是再做一个全新的系统。B/S程序由构件组成，方便构件个别的更换，实现系统的无缝升级，系统维护开销减到最小，用户从网上自己下载安装就可以实现升级。</p>
</li>
<li><p>处理问题不同：C/S 程序可以处理用户面固定，并且在相同区域,，安全要求高需求，与操作系统相关，应该都是相同的系统。B/S 建立在广域网上，面向不同的用户群，分散地域，这是C/S无法作到的，与操作系统平台关系最小。</p>
</li>
<li><p>用户接口不同：C/S 多是建立的Window平台上，表现方法有限。对程序员普遍要求较高。B/S 建立在浏览器上,，有更加丰富和生动的表现方式与用户交流，并且大部分难度减低，减低开发成本。</p>
</li>
<li><p>信息流不同：C/S 程序一般是典型的中央集权的机械式处理，交互性相对低。B/S 信息流向可变化， B-B、 B-C、 B-G等信息流向的变化，更象交易中心。</p>
</li>
</ol>
<h5 id="技术比较"><a href="#技术比较" class="headerlink" title="技术比较"></a>技术比较</h5><p>C/S结构软件（即客户机/服务器模式）分为客户机和服务器两层，客户机不是毫无运算能力的输入、输出设备，而是具有了一定的数据处理和数据存储能力，通过把应用软件的计算和数据合理地分配在客户机和服务器两端，可以有效地降低网络通信量和服务器运算量。由于服务器连接个数和数据通信量的限制，这种结构的软件适于在用户数目不多的局域网内使用。国内现阶段的大部分ERP（财务）软件产品即属于此类结构。  </p>
<p>B/S(浏览器/服务器模式)是随着Internet技术的兴起，对C/S结构的一种改进。在这种结构下，软件应用的业务逻辑完全在应用服务器端实现，用户表现完全在Web服务器实现，客户端只需要浏览器即可进行业务处理，是一种全新的软件系统构造技术。这种结构更成为当今应用软件的首选体系结构。e通管理系列产品即属于此类结构。  </p>
<ol>
<li><p>数据安全性比较。由于C/S结构软件的数据分布特性，客户端所发生的火灾、盗抢、地震、病毒、黑客等都成了可怕的数据杀手。另外，对于集团级的异地软件应用，C/S结构的软件必须在各地安装多个服务器，并在多个服务器之间进行数据同步。如此一来，每个数据点上的数据安全都影响了整个应用的数据安全。所以，对于集团级的大型应用来讲，C/S结构软件的安全性是令人无法接受的。对于B/S结构的软件来讲，由于其数据集中存放于总部的数据库服务器，客户端不保存任何业务数据和数据库连接信息，也无需进行什么数据同步，所以这些安全问题也就自然不存在了。</p>
</li>
<li><p>数据一致性比较。在C/S结构软件的解决方案里，对于异地经营的大型集团都采用各地安装区域级服务器，然后再进行数据同步的模式。这些服务器每天必须同步完毕之后，总部才可得到最终的数据。由于局部网络故障造成个别数据库不能同步不说，即使同步上来，各服务器也不是一个时点上的数据，数据永远无法一致，不能用于决策。对于B/S结构的软件来讲，其数据是集中存放的，客户端发生的每一笔业务单据都直接进入到中央数据库，不存在数据一致性的问题。</p>
</li>
<li><p>数据实时性比较。在集团级应用里，C/S结构不可能随时随地看到当前业务的发生情况，看到的都是事后数据；而B/S结构则不同，它可以实时看到当前发生的所有业务，方便了快速决策，有效地避免了企业损失。</p>
</li>
<li><p>数据溯源性比较。由于B/S结构的数据是集中存放的，所以总公司可以直接追溯到各级分支机构（分公司、门店）的原始业务单据，也就是说看到的结果可溯源。大部分C/S结构的软件则不同，为了减少数据通信量，仅仅上传中间报表数据，在总部不可能查到各分支机构（分公司、门店）的原始单据。</p>
</li>
<li><p>服务响应及时性比较。企业的业务流程、业务模式不是一成不变的，随着企业不断发展，必然会不断调整。软件供应商提供的软件也不是完美无缺的，所以，对已经部署的软件产品进行维护、升级是正常的。C/S结构软件，由于其应用是分布的，需要对每一个使用节点进行程序安装，所以，即使非常小的程序缺陷都需要很长的重新部署时间，重新部署时，为了保证各程序版本的一致性，必须暂停一切业务进行更新（即“休克更新”），其服务响应时间基本不可忍受。而B/S结构的软件不同，其应用都集中于总部服务器上，各应用结点并没有任何程序，一个地方更新则全部应用程序更新，可以做到快速服务响应。</p>
</li>
<li><p>网络应用限制比较。C/S结构软件仅适用于局域网内部用户或宽带用户（1兆以上）；而我们的B/S结构软件可以适用于任何网络结构（包括33.6K拨号入网方式），特别适于宽带不能到达的地方（例如迪信通集团的某些分公司，仅靠电话上网即可正常使用软件系统）。</p>
</li>
<li><p>存储模式比较。B/S结构相应数据完全来自于后台数据库，而C/S结构部分数据来源于存储在本地的临时文件，剩余的部分来源于数据库，因此C/S结构响应时间会更快。</p>
</li>
</ol>
<h5 id="商业比较"><a href="#商业比较" class="headerlink" title="商业比较"></a>商业比较</h5><ol>
<li><p>投入成本比较。B/S结构软件一般只有初期一次性投入成本。对于集团来讲，有利于软件项目控制和避免IT黑洞，而C/S结构的软件则不同，随着应用范围的扩大，投资会连绵不绝。</p>
</li>
<li><p>硬件投资保护比较。在对已有硬件投资的保护方面，两种结构也是完全不同的。当应用范围扩大，系统负载上升时，C/S结构软件的一般解决方案是购买更高性能的服务器；而B/S架构则是通过增加服务器的数量来承担更大的负载。</p>
</li>
</ol>
<h2 id="融合"><a href="#融合" class="headerlink" title="融合"></a>融合</h2><p>未来发展趋势，是将B/S与C/S的优势完美地结合起来，就是说，该平台的应用系统既能以B/S的方式发布运行，同时又具有C/S方式的极强的可操作性。</p>
<h2 id="发展前景"><a href="#发展前景" class="headerlink" title="发展前景"></a>发展前景</h2><p>C/S和B/S各有优势，C/S在图形的表现能力上以及运行的速度上肯定是强于B/S模式的，不过缺点就是他需要运行专门的客户端，而且更重要的是它不能跨平台，用c++在windows下写的程序肯定是不能在linux下跑的。<br>而B/S模式就不同了，它不需要专门的客户端，只要浏览器，而浏览器是随操作系统就有的，方便就是他的优势了。<br>而且，B/S是基于网页语言的、与操作系统无关，所以跨平台也是它的优势，而且以后随着网页语言以及浏览器的进步，B/S在表现能力上的处理以及运行的速度上会越来越快，它的缺点将会越来越少。比如，未来的HTML5，在图形的渲染方面以及音频、文件的处理上已经非常强大了。<br>不过，C/S架构也有着不可替代的作用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;B/S结构即浏览器和服务器结构。&lt;br&gt;
    
    </summary>
    
      <category term="剪切板" scheme="https://wangzongxu.github.io/categories/%E5%89%AA%E5%88%87%E6%9D%BF/"/>
    
    
      <category term="网络" scheme="https://wangzongxu.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>http 状态码</title>
    <link href="https://wangzongxu.github.io/2017/09/21/httpStatus/"/>
    <id>https://wangzongxu.github.io/2017/09/21/httpStatus/</id>
    <published>2017-09-21T09:09:24.000Z</published>
    <updated>2017-09-21T09:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>整理一些http状态码。<br><a id="more"></a></p>
<h3 id="1xx信息-Informational"><a href="#1xx信息-Informational" class="headerlink" title="1xx信息 Informational"></a>1xx信息 Informational</h3><table>
<thead>
<tr>
<th>状态码</th>
<th>说明</th>
<th>原文</th>
</tr>
</thead>
<tbody>
<tr>
<td>100</td>
<td>继续</td>
<td>Continue</td>
</tr>
<tr>
<td>101</td>
<td>交换协议</td>
<td>Switching Protocols</td>
</tr>
<tr>
<td>102</td>
<td>加工</td>
<td>Processing</td>
</tr>
</tbody>
</table>
<h3 id="2××成功-Success"><a href="#2××成功-Success" class="headerlink" title="2××成功 Success"></a>2××成功 Success</h3><table>
<thead>
<tr>
<th>状态码</th>
<th>说明</th>
<th>原文</th>
</tr>
</thead>
<tbody>
<tr>
<td>200</td>
<td>成功</td>
<td>OK</td>
</tr>
<tr>
<td>201</td>
<td>创建</td>
<td>Created</td>
</tr>
<tr>
<td>202</td>
<td>接受</td>
<td>Accepted</td>
</tr>
<tr>
<td>203</td>
<td>非权威信息</td>
<td>Non-authoritative Information</td>
</tr>
<tr>
<td>204</td>
<td>无内容</td>
<td>No Content</td>
</tr>
<tr>
<td>205</td>
<td>重置内容</td>
<td>Reset Content</td>
</tr>
<tr>
<td>206</td>
<td>部分内容</td>
<td>artial Content</td>
</tr>
<tr>
<td>207</td>
<td>多状态</td>
<td>Multi-Status</td>
</tr>
<tr>
<td>208</td>
<td>已报告</td>
<td>Already Reported</td>
</tr>
<tr>
<td>226</td>
<td>IM使用</td>
<td>IM Used</td>
</tr>
</tbody>
</table>
<h3 id="3××重定向-Redirection"><a href="#3××重定向-Redirection" class="headerlink" title="3××重定向 Redirection"></a>3××重定向 Redirection</h3><table>
<thead>
<tr>
<th>状态码</th>
<th>说明</th>
<th>原文</th>
</tr>
</thead>
<tbody>
<tr>
<td>300</td>
<td>多项选择</td>
<td>Multiple Choices</td>
</tr>
<tr>
<td>301</td>
<td>永久移动</td>
<td>Moved Permanently</td>
</tr>
<tr>
<td>302</td>
<td>找到</td>
<td>Found</td>
</tr>
<tr>
<td>303</td>
<td>见其他</td>
<td>See Other</td>
</tr>
<tr>
<td>304</td>
<td>未修改</td>
<td>Not Modified</td>
</tr>
<tr>
<td>305</td>
<td>使用代理</td>
<td>Use Proxy</td>
</tr>
<tr>
<td>307</td>
<td>临时重定向</td>
<td>emporary Redirect</td>
</tr>
<tr>
<td>308</td>
<td>永久重定向</td>
<td>Permanent Redirect</td>
</tr>
</tbody>
</table>
<h3 id="4××客户端错误-Client-Error"><a href="#4××客户端错误-Client-Error" class="headerlink" title="4××客户端错误 Client Error"></a>4××客户端错误 Client Error</h3><table>
<thead>
<tr>
<th>状态码</th>
<th>说明</th>
<th>原文</th>
</tr>
</thead>
<tbody>
<tr>
<td>400</td>
<td>错误请求</td>
<td>Bad Request</td>
</tr>
<tr>
<td>401</td>
<td>未经授权</td>
<td>Unauthorized</td>
</tr>
<tr>
<td>402</td>
<td>付款需要</td>
<td>Payment Required</td>
</tr>
<tr>
<td>403</td>
<td>禁止</td>
<td>Forbidden</td>
</tr>
<tr>
<td>404</td>
<td>未找到</td>
<td>Not Found</td>
</tr>
<tr>
<td>405</td>
<td>方法不允许</td>
<td>Method Not Allowed</td>
</tr>
<tr>
<td>406</td>
<td>不可接受</td>
<td>Not Acceptable</td>
</tr>
<tr>
<td>407</td>
<td>代理验证需要</td>
<td>Proxy Authentication Required</td>
</tr>
<tr>
<td>408</td>
<td>请求超时</td>
<td>Request Timeout</td>
</tr>
<tr>
<td>409</td>
<td>冲突</td>
<td>Conflict</td>
</tr>
<tr>
<td>410</td>
<td>过时</td>
<td>Gone</td>
</tr>
<tr>
<td>411</td>
<td>需要长度字段</td>
<td>Length Required</td>
</tr>
<tr>
<td>412</td>
<td>前提条件失败</td>
<td>Precondition Failed</td>
</tr>
<tr>
<td>413</td>
<td>有效负载太大</td>
<td>Payload Too Large</td>
</tr>
<tr>
<td>414</td>
<td>请求URI太长</td>
<td>Request-URI Too Long</td>
</tr>
<tr>
<td>415</td>
<td>不支持的介质类型</td>
<td>Unsupported Media Type</td>
</tr>
<tr>
<td>416</td>
<td>请求范围不满意</td>
<td>Requested Range Not Satisfiable</td>
</tr>
<tr>
<td>417</td>
<td>未满足期望值</td>
<td>Expectation Failed</td>
</tr>
<tr>
<td>418</td>
<td>我是一个茶壶</td>
<td>I’m a teapot</td>
</tr>
<tr>
<td>421</td>
<td>错误请求</td>
<td>Misdirected Request</td>
</tr>
<tr>
<td>422</td>
<td>不可处理的实体</td>
<td>Unprocessable Entity</td>
</tr>
<tr>
<td>423</td>
<td>锁定</td>
<td>Locked</td>
</tr>
<tr>
<td>424</td>
<td>失败的依赖关系</td>
<td>Failed Dependency</td>
</tr>
<tr>
<td>426</td>
<td>需要升级</td>
<td>Upgrade Required</td>
</tr>
<tr>
<td>428</td>
<td>需要前提条件</td>
<td>Precondition Required</td>
</tr>
<tr>
<td>429</td>
<td>太多请求</td>
<td>Too Many Requests</td>
</tr>
<tr>
<td>431</td>
<td>请求标题字段太大</td>
<td>Request Header Fields Too Large</td>
</tr>
<tr>
<td>444</td>
<td>连接没有响应关闭</td>
<td>Connection Closed Without Response</td>
</tr>
<tr>
<td>451</td>
<td>不适用于法律理由</td>
<td>Unavailable For Legal Reasons</td>
</tr>
<tr>
<td>499</td>
<td>客户关闭请求</td>
<td>Client Closed Request</td>
</tr>
</tbody>
</table>
<h3 id="5××服务器错误-Server-Error"><a href="#5××服务器错误-Server-Error" class="headerlink" title="5××服务器错误 Server Error"></a>5××服务器错误 Server Error</h3><table>
<thead>
<tr>
<th>状态码</th>
<th>说明</th>
<th>原文</th>
</tr>
</thead>
<tbody>
<tr>
<td>500</td>
<td>内部服务器错误</td>
<td>Internal Server Error</td>
</tr>
<tr>
<td>501</td>
<td>未实施</td>
<td>Not Implemented</td>
</tr>
<tr>
<td>502</td>
<td>错误的网关</td>
<td>Bad Gateway</td>
</tr>
<tr>
<td>503</td>
<td>服务不可用</td>
<td>Service Unavailable</td>
</tr>
<tr>
<td>504</td>
<td>网关超时</td>
<td>Gateway Timeout</td>
</tr>
<tr>
<td>505</td>
<td>HTTP版本不受支持</td>
<td>HTTP Version Not Supported</td>
</tr>
<tr>
<td>506</td>
<td>变种也谈判</td>
<td>Variant Also Negotiates</td>
</tr>
<tr>
<td>507</td>
<td>存储不足</td>
<td>Insufficient Storage</td>
</tr>
<tr>
<td>508</td>
<td>检测到回路</td>
<td>Loop Detected</td>
</tr>
<tr>
<td>510</td>
<td>未扩展</td>
<td>Not Extended</td>
</tr>
<tr>
<td>511</td>
<td>网络认证需要</td>
<td>Network Authentication Required</td>
</tr>
<tr>
<td>599</td>
<td>网络连接超时错误</td>
<td>Network Connect Timeout Error</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整理一些http状态码。&lt;br&gt;
    
    </summary>
    
      <category term="剪切板" scheme="https://wangzongxu.github.io/categories/%E5%89%AA%E5%88%87%E6%9D%BF/"/>
    
    
      <category term="网络" scheme="https://wangzongxu.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>后台管理系统</title>
    <link href="https://wangzongxu.github.io/2017/09/21/manageOS/"/>
    <id>https://wangzongxu.github.io/2017/09/21/manageOS/</id>
    <published>2017-09-21T09:09:24.000Z</published>
    <updated>2017-09-21T09:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>个人总结内容管理系统（CMS）的心得。<br><a id="more"></a></p>
<p>来到某云计算公司长期以来做的一直是管理系统控制台，，从jquery到vue，颇有心得。</p>
<h2 id="菜单树"><a href="#菜单树" class="headerlink" title="菜单树"></a>菜单树</h2><ul>
<li>关于菜单树，是每个管理系统必有的，作为导航性质的，非常重要的部分，整理好DOM结构，方便多级目录的展开和收起，如果使用vue，react等组件化框架，把菜单树但独立出来即可。</li>
<li>关于图标，一般放在菜单树每一项文字的前边，对于现在浏览器，我们使用的是svg，相对于图片而言，即使放大再多，也不会是真。但是有时候有一点问题，在chrome中，如果页面中的svg过多，可能造成页面解析闪烁，解决方法也比较简单：在加载页面时将svg用js拼接字符串动态插入就好。</li>
</ul>
<h2 id="面包屑"><a href="#面包屑" class="headerlink" title="面包屑"></a>面包屑</h2><ul>
<li>不知道这个名字怎么起的，所谓‘面包屑’就是页面左上角的当前位置，这里非常简单，点击每一步骤都可以进行跳转就可以了，最好的交互是如果当前是表单页面，当用户点击的时候，进行一下确认提示，防止误点导致填写的东西丢失。<br><img src="https://wangzongxu.github.io/img-cache/blog/bread.png" width="200" alt="bread" align="center"></li>
</ul>
<h2 id="列表全选和分页"><a href="#列表全选和分页" class="headerlink" title="列表全选和分页"></a>列表全选和分页</h2><ul>
<li>之前项目使用的jq来做，比较头疼的地方就是这里，因为通常在一个列表管理页面，每一条数据要有删除放入复选框，问题是当用户切换页码之后再次回到原来页数，我们如果不做特殊处理，之前选中复选框选中态会被清除，这样并不利于交互，而如果我们在逻辑处理，实践中证明虽然问题是小，但是导致的代码量增加的不少，而且可维护性和性能降低。权衡之下我们采用了这种分页结构：<br><img src="https://wangzongxu.github.io/img-cache/blog/page.png" width="400" alt="page" align="center"><br>如此之来，用户如果想要选择更多数据，只要切换当夜显示的条数即可，算是一个交互与程序复杂度的这种点吧。</li>
<li>如果项目使用的MVVM框架，则无需考虑以上问题。交互与性能兼并。</li>
</ul>
<h2 id="分步创建和编辑"><a href="#分步创建和编辑" class="headerlink" title="分步创建和编辑"></a>分步创建和编辑</h2><p>创建和编辑功能也是管理系统中不可缺失的一部分，复杂度很高，其中包括：表单验证，编辑回填，文字转义等多重问题，以下图为例：<br><img src="https://wangzongxu.github.io/img-cache/blog/step.png" width="400" alt="step" align="center"></p>
<ul>
<li>按常理来我们将这三步骤分成三个页面来做。因为这样方便代码维护，可读性也比较高，于是我们这么做了，完成之后发现一个问题：用户在这三步中是可以任意来回切换的，切换之后再回来仍然需要显示之前填写的东西。但是我们做的是三个页面，如果要保存用户的数据，还要用本地存储，过程十分繁琐。</li>
<li>如果不想考虑上一个问题，我们可以从刚开始吧这三步骤放到一个页面里，用户点击上下步骤的时候，保留当期步骤，让其他步骤隐藏即可。我们发现即使切换步骤，也不会丢失之前数据，但是试想一下，三个页面的逻辑都放在一个页面中，无论加载速度，可读性和维护性都不敢直视，上千行代码也没的说。</li>
<li>其实这里还是建议使用vue，感觉真的是为做这种系统而生的，他有个动态组件功能，允许我们把这个三个步骤单独为三个组件，当用户切换步骤的时候，我们只是控制的组件的展示，还可以将切换出取的其他步骤保存在缓存中，使得用户再次回来这个步骤，之前的数据仍然不变。这样即保证的代码的质量，也保证的用户的体验。</li>
</ul>
<h2 id="弹窗"><a href="#弹窗" class="headerlink" title="弹窗"></a>弹窗</h2><p>弹窗作为用户获得信息的重要途径，当然需要认真设计一下：</p>
<ul>
<li>将弹窗基本分为三类，确认弹窗（confirm），提示弹窗（alert/toast），操作弹窗。</li>
<li>操作弹窗即一些用提供给用户管理的大型弹窗，也可以叫做一个小的‘轻页面’，比如用户要在一个管理组里添加成员，点击添加按钮，页面跳出一个弹窗，里边展示着可以添加的每个。</li>
<li>由于操作弹窗的功能各异，样式也就不用。所以我们一般把确认和提示弹窗做成通用封装到一个全局工具包中，方便随时操作，而操作弹窗则依照实际情况而定。</li>
<li>关于弹窗，不论大小，有一点比较好的体验：当弹窗展示的过程中，我们将页面的宽高都设为100%，即禁止屏幕滚动，防止在弹窗在展示时页面可以滚动，最重要的是如果我们的操作弹窗非常高，以至于超出屏幕高度，这时候肯定要进行滚动展示，当弹窗内出现滚动条时，如果同时页面也有滚动条，这会导致页面不仅看起来非常丑，而且操作上很奇怪。如果我们将页面全屏防止滚动就可以去掉页面滚动条，只保留弹窗内滚动条，这样一个小小的细节使得不论看起来和操作上都比较完美。</li>
</ul>
<h2 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h2><p>字符转义和我们做的项目相关，如果项目不允许用户输入特殊符号，我们做了输入限制，就不会有此问题。如果允许输入特殊字符（这里仍要防止XSS攻击），我们就要做相应处理。</p>
<ul>
<li>我们的项目中，对于特殊字符，后台会一律转码，比如我们在填写表单的时候输入的是&amp;，再次编辑的时候就变成了&amp;.</li>
<li>一般单独封装一个转义的函数，将已知的‘码’都预设在里边，传入被后台转义之后的，返回正常显示的特殊符号，函数比较简单，就不在此费口舌了。</li>
<li>需要注意的两个地方就是列表的数据和编辑某一项的时候，需要转义。</li>
</ul>
<h2 id="字符超长剪裁"><a href="#字符超长剪裁" class="headerlink" title="字符超长剪裁"></a>字符超长剪裁</h2><p>对于列表中某一个字段可能过长，导致页面显示错乱</p>
<ul>
<li><p>添加css字符剪裁<br><img src="https://wangzongxu.github.io/img-cache/blog/ellipsis.png" width="200" alt="ellipsis" align="center"></p>
</li>
<li><p>添加title，让用户能够看到完整的文字。</p>
</li>
</ul>
<h2 id="loading"><a href="#loading" class="headerlink" title="loading"></a>loading</h2><p>关于loading，可以让用户知道操作的进行状态，没有它，用户点击了一个按钮以后，会认为没有反馈。</p>
<ul>
<li>一般我们吧loading分为两种：列表loading 和 操作loading</li>
<li>列表loading就是当用户进入列表页面的时候，或者切换页码的时候，我们应该对用户友好提示‘加载中…’，如果加载成功的话，就隐藏该提示，如果加载失败，就显示错误信息。这里也有一点：列表加载错误的提示建议不使用弹窗形式，因为在加载过程中用户看得是这个列表，我们一般把列表loading就放在列表位置，当失败的时候将loading文字更改一下，用户一目了然,没必要在使用弹窗提示。<br><img src="https://wangzongxu.github.io/img-cache/blog/list-loading.png" width="auto" alt="list-loading" align="center"></li>
<li>操作loading是当用户进行分步创建新的数据的时候，点击下一步的时候，此时一般我们都会进行和后台数据交互，反应可能会有延迟，这是需要给用户一个友好的loading，用意是告诉用户我们正在加载中，别着急。<br><img src="https://wangzongxu.github.io/img-cache/blog/screen-loading1.png" width="400" alt="screen-loading1" align="center"></li>
</ul>
<h2 id="二次封装ajax"><a href="#二次封装ajax" class="headerlink" title="二次封装ajax"></a>二次封装ajax</h2><p>一般我们的接口数据返回格式会和后台约定好下边格式：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"code"</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="attr">"msg"</span>: <span class="string">"执行成功"</span>,</span><br><span class="line">  <span class="attr">"data"</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>code是返回状态，成功为200,注意这个不是网络状态码，只是与后台的约定。</li>
<li>依照以上数据，正常情况我们写ajax的时候，会这样写(jq为例)：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">'xxx'</span>,</span><br><span class="line">  <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123; <span class="comment">// 网络请求成功</span></span><br><span class="line">    <span class="keyword">if</span> (data.code === <span class="number">200</span>) &#123; <span class="comment">// 操作成功</span></span><br><span class="line">      <span class="comment">// do something ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 操作失败</span></span><br><span class="line">      <span class="comment">// do something ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; <span class="comment">// 网络错误</span></span><br><span class="line">    alert(<span class="string">'网络错误，请重试'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>看得出，成功只有一种情况，而错误会有两种情况，即网络错误和后台返回的code不是200的操作错误，<br>如果每个数据请求都这么写，代码会很冗余，举例简单将其封装一下：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myAjax</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  $.ajax(&#123;</span><br><span class="line">    <span class="attr">url</span>: obj.url,</span><br><span class="line">    <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123; <span class="comment">// 网络请求成功</span></span><br><span class="line">      <span class="keyword">if</span> (data.code === <span class="number">200</span>) &#123; <span class="comment">// 操作成功</span></span><br><span class="line">        <span class="comment">// do something ...</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 操作失败</span></span><br><span class="line">        obj.error(data.msg);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; <span class="comment">// 网络错误</span></span><br><span class="line">      obj.error(<span class="string">'网络错误，请重试'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如此一来，我们就可以少处理一个错误：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">myAjax(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">'xxx'</span>,</span><br><span class="line">  <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123; <span class="comment">// 成功</span></span><br><span class="line">    <span class="comment">// do something ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; <span class="comment">// 错误</span></span><br><span class="line">    alert(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h2><p>在用户创建信息的时候，通常我们会进行前端输入验证：</p>
<ul>
<li>建议使用统一验证插件，方便团队中其他人维护的便捷性（vue的话建议<a href="http://vee-validate.logaretm.com/" target="_blank" rel="external">vee-validate</a>）</li>
<li>多人开发要统一错误提示方式和提示用语。</li>
</ul>
<h2 id="日历插件"><a href="#日历插件" class="headerlink" title="日历插件"></a>日历插件</h2><p>列表中和表单中选择时间也是必不可少的</p>
<ul>
<li>用了很多插件，发现无论拓展性，稳定性都不如心意，推荐一款：</li>
<li><a href="http://www.my97.net/index.asp" target="_blank" rel="external">My97 DatePicker</a></li>
</ul>
<h2 id="连点问题"><a href="#连点问题" class="headerlink" title="连点问题"></a>连点问题</h2><p>连点问题是个需要重视的问题，比如用户在创建信息的时候点击完成，用户连点了多次，会造成多次请求，可能导致最终的创建信息失败。</p>
<ul>
<li>在loading中我们就处理过，在点击按钮的时候添加loading效果，其实稍加改动便可解决连点问题</li>
<li>给loading图添加一个大背景，让其全屏展示即可，应为此时的用户再也点不到按钮了，直到得到后台的反馈之后才可再次点击。<br><img src="https://wangzongxu.github.io/img-cache/blog/screen-loading2.png" width="400" alt="screen-loading2" align="center"></li>
</ul>
<p>(完)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;个人总结内容管理系统（CMS）的心得。&lt;br&gt;
    
    </summary>
    
      <category term="前端心得" scheme="https://wangzongxu.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="交互" scheme="https://wangzongxu.github.io/tags/%E4%BA%A4%E4%BA%92/"/>
    
  </entry>
  
  <entry>
    <title>一个轻量的模板引擎</title>
    <link href="https://wangzongxu.github.io/2017/09/21/mini-render/"/>
    <id>https://wangzongxu.github.io/2017/09/21/mini-render/</id>
    <published>2017-09-21T09:09:24.000Z</published>
    <updated>2017-09-21T09:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>一个轻量的模板引擎，语法简洁，性能高效</p>
<a id="more"></a>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install mini-render --save</span><br><span class="line">// 或者</span><br><span class="line">&lt;script src=<span class="string">'miniRender.js'</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="定义一些数据"><a href="#定义一些数据" class="headerlink" title="定义一些数据"></a>定义一些数据</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123;</span><br><span class="line">    <span class="attr">gt</span>: <span class="number">7</span>,</span><br><span class="line">    <span class="attr">lt</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="attr">first</span>: <span class="string">'first'</span>,</span><br><span class="line">    <span class="attr">array</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">    <span class="attr">object</span>: &#123;</span><br><span class="line">         <span class="attr">key1</span>: <span class="string">'value1'</span>,</span><br><span class="line">        <span class="attr">key2</span>: <span class="string">'value2'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">word</span>: <span class="string">'aaaaa'</span>,</span><br><span class="line">    <span class="attr">empty</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 渲染元素模板</span></span><br><span class="line">miniRender.renderElement(<span class="string">'#box'</span>, data)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以返回渲染结果</span></span><br><span class="line"><span class="keyword">var</span> str = miniRender.renderString(<span class="string">'&lt;div&gt;&#123;&#123;word&#125;&#125;&lt;/div&gt;'</span>, data)</span><br><span class="line"><span class="built_in">console</span>.log(str)</span><br></pre></td></tr></table></figure>
<h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; first &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--结果:</span><br><span class="line">    &lt;p&gt;first&lt;/p&gt;</span><br><span class="line">--&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>支持三元运算<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; gt &gt; 8 ? gt : 8 &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--结果:</span><br><span class="line">    &lt;p&gt;8&lt;/p&gt;</span><br><span class="line">--&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; word | toUpperCase &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--结果: </span><br><span class="line">    &lt;p&gt;AAAAA&lt;/p&gt;</span><br><span class="line">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span><br><span class="line"><span class="comment">// 注册过滤器</span></span><br><span class="line">miniRender.filter(<span class="string">'toUpperCase'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val.toUpperCase()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 移除过滤器</span></span><br><span class="line">miniRender.removeFilter(<span class="string">'toUpperCase'</span>)</span><br><span class="line"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>过滤器仅可用在上边这种普通的取值中</p>
</blockquote>
<h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;IF gt &gt; lt&#125;&#125;</span><br><span class="line">    &lt;p&gt;gt比较大:&#123;&#123;gt&#125;&#125;&lt;/p&gt;</span><br><span class="line">&#123;&#123;ELSEIF lt &lt; gt&#125;&#125;</span><br><span class="line">    &lt;p&gt;lt比较小:&#123;&#123;lt&#125;&#125;&lt;/p&gt;</span><br><span class="line">&#123;&#123;ELSE&#125;&#125;</span><br><span class="line">    &lt;p&gt;都不成立&lt;/p&gt;</span><br><span class="line">&#123;&#123;/IF&#125;&#125;</span><br><span class="line"></span><br><span class="line">&lt;!--结果:</span><br><span class="line">    &lt;p&gt;gt比较大:7&lt;/p&gt;</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--数组--&gt;</span></span><br><span class="line">&#123;&#123;EACH item, index IN array&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>索引:&#123;&#123;index&#125;&#125;  值:&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;&#123;/EACH&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--结果:</span><br><span class="line">    &lt;p&gt;索引:0  值:1&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;索引:1  值:2&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;索引:2  值:3&lt;/p&gt;</span><br><span class="line">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--对象--&gt;</span></span><br><span class="line">&#123;&#123;EACH val,key IN object&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>属性名:&#123;&#123;key&#125;&#125;  属性值:&#123;&#123;val&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;&#123;/EACH&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--结果:</span><br><span class="line">    &lt;p&gt;属性名:key1  属性值:value1&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;属性名:key2  属性值:value2&lt;/p&gt;</span><br><span class="line">--&gt;</span></span><br></pre></td></tr></table></figure>
<p>（完）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个轻量的模板引擎，语法简洁，性能高效&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="https://wangzongxu.github.io/categories/JS/"/>
    
    
      <category term="模板引擎" scheme="https://wangzongxu.github.io/tags/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>猜想新零售</title>
    <link href="https://wangzongxu.github.io/2017/09/21/new-retail/"/>
    <id>https://wangzongxu.github.io/2017/09/21/new-retail/</id>
    <published>2017-09-21T09:09:24.000Z</published>
    <updated>2017-09-21T09:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>猜想未来零售行业<br><a id="more"></a></p>
<blockquote>
<p>此系本人大胆设想，仅代表个人对未来的美好憧憬</p>
</blockquote>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景:"></a>背景:</h3><p>在马云提出新零售战略后不久，阿里成为华联超市的第二大股东。</p>
<h3 id="华联超市简介"><a href="#华联超市简介" class="headerlink" title="华联超市简介:"></a>华联超市简介:</h3><p>华联超市股份有限公司是上海百联的二级公司。截至2016年12月31日，联华超市及其附属公司的总门店数目已经达到3618家，遍布全国19个省份及直辖市。</p>
<h3 id="新零售的“新”"><a href="#新零售的“新”" class="headerlink" title="新零售的“新”"></a>新零售的“新”</h3><p>以个人信用评估和消费习惯为基础，挖掘客户需求，提升客户服务体验，改变传统消费和服务概念。降低商家库存积压趋近0。</p>
<h3 id="消费场景模拟"><a href="#消费场景模拟" class="headerlink" title="消费场景模拟:"></a>消费场景模拟:</h3><p>王先生的家附近有一家华联超市，家里的生活用品一般都会在这家超市购买，应店员邀请，王先生关注了该店的生活号。<br>某天王先生收到一条消息推送，消息向王先生推荐了几个品牌的食盐。王先生不以为然，当他准备做饭的时候，发现盐基本没有了，这才回想起收到的消息，打开消息详情，里边有“30分钟内送货上门”和“门店自取(由于您的距离较近，建议自取)”，的两个选项。</p>
<p>王先生选择了自取，并在线下单支付了一袋盐的价钱。</p>
<p>王先生来到超市，走到“自取柜台”，此时王先生还没开口，服务员就热情的将王先生下单的那带盐拿了过来，“王先生，这是您订购的商品，如果您还有其他需要可以去五自选区，这个我们先帮您保存”，服务员微笑着说说。“好的，正好我还有要买的东西”。</p>
<p>王先生走到自选区，打算买一些菜和饮料，他打开支付宝里边的超市板块，选择了这个超市，手机上提示着‘请在您选购的过程中，将商品码扫描’。王先生拿了一瓶可乐，扫码之后手机上显示着‘已选购商品’:12.5L可口可乐，数量1瓶。总计6元。来到蔬菜区，服务员帮王先生称了两个土豆和两个西红柿。王先生扫描了称上面显示了二维码。</p>
<p>由于王先生信用比较高，他在手机上选择了自行结账，付了款。他看到结账区人的在排队，心想:‘还好我信用比较好’。<br>王先生去自取柜台拿了之前买好的盐，满意的回了家。</p>
<h3 id="商家场景模拟"><a href="#商家场景模拟" class="headerlink" title="商家场景模拟:"></a>商家场景模拟:</h3><p>······</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;猜想未来零售行业&lt;br&gt;
    
    </summary>
    
      <category term="闲谈" scheme="https://wangzongxu.github.io/categories/%E9%97%B2%E8%B0%88/"/>
    
    
      <category term="草稿" scheme="https://wangzongxu.github.io/tags/%E8%8D%89%E7%A8%BF/"/>
    
  </entry>
  
  <entry>
    <title>关于浏览器缓存</title>
    <link href="https://wangzongxu.github.io/2017/09/21/cache_control/"/>
    <id>https://wangzongxu.github.io/2017/09/21/cache_control/</id>
    <published>2017-09-21T09:09:24.000Z</published>
    <updated>2017-09-21T09:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器缓存，也就是客户端缓存，既是网页性能优化里面静态资源相关优化的一大利器，也是无数web开发人员在工作过程不可避免的一大问题，所以在产品开发的时候我们总是想办法避免缓存产生，而在产品发布之时又在想策略管理缓存提升网页的访问速度。了解浏览器的缓存命中原理，是开发web应用的基础。<br><a id="more"></a></p>
<h3 id="浏览器缓存基本介绍"><a href="#浏览器缓存基本介绍" class="headerlink" title="浏览器缓存基本介绍"></a>浏览器缓存基本介绍</h3><blockquote>
<p>它分为强缓存和协商缓存：</p>
</blockquote>
<ol>
<li><p>浏览器在加载资源时，先根据这个资源的一些http header判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。比如某个css文件，如果浏览器在加载它所在的网页时，这个css文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个css，连请求都不会发送到网页所在服务器；</p>
</li>
<li><p>当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些http header验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源；</p>
</li>
<li><p>强缓存与协商缓存的共同点是：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：强缓存不发请求到服务器，协商缓存会发请求到服务器。</p>
</li>
<li><p>当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。</p>
</li>
</ol>
<h3 id="强缓存原理"><a href="#强缓存原理" class="headerlink" title="强缓存原理"></a>强缓存原理</h3><ul>
<li><p>浏览器对某个资源的请求命中了强缓存时，返回的http状态为200，在chrome的开发者工具的network里面size会显示为from disk cache，比如天猫的首页里就有很多静态资源配置了强缓存，用network可以看到有不少请求就是从缓存中加载的：<br><img src="https://wangzongxu.github.io/img-cache/blog/强缓存原理配图1.png" alt="强缓存原理配图"></p>
</li>
<li><p>强缓存是利用Expires或者Cache-Control这两个http response header实现的，它们都用来表示资源在客户端缓存的有效期。</p>
</li>
<li><p>Expires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回，用GMT格式的字符串表示，如：Expires:Thu, 31 Dec 2037 23:55:55 GMT，它的缓存原理是：]</p>
<ol>
<li><p>1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Expires的header，如：<br><img src="https://wangzongxu.github.io/img-cache/blog/expires.png" alt="Expires"></p>
</li>
<li><p>浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来（所以缓存命中的请求返回的header并不是来自服务器，而是来自之前缓存的header）；</p>
</li>
<li><p>浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的Expires跟当前的请求时间比较，如果请求时间在Expires指定的时间之前，就能命中缓存，否则就不行。</p>
</li>
<li><p>如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header在重新加载的时候会被更新。</p>
</li>
</ol>
</li>
<li><p>Expires是较老的强缓存管理header，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。所以在http1.1的时候，提出了一个新的header，就是Cache-Control，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示，如：Cache-Control:max-age=315360000，它的缓存原理是：</p>
<ol>
<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Cache-Control的header，如<br><img src="https://wangzongxu.github.io/img-cache/blog/cache-control.png" alt="Cache-Control"></li>
<li><p>浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来；</p>
</li>
<li><p>浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。</p>
</li>
<li><p>如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header在重新加载的时候会被更新。</p>
</li>
</ol>
</li>
<li><p>Cache-Control描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较Expires，Cache-Control的缓存管理更有效，安全一些。</p>
</li>
<li><p>这两个header可以只启用一个，也可以同时启用，当response header中，Expires和Cache-Control同时存在时，Cache-Control优先级高于Expires。<br><img src="https://wangzongxu.github.io/img-cache/blog/expires-and-control.png" alt="expires-and-control"></p>
</li>
</ul>
<h3 id="强缓存的管理"><a href="#强缓存的管理" class="headerlink" title="强缓存的管理"></a>强缓存的管理</h3><ul>
<li><p>前面介绍的是强缓存的原理，在实际应用中我们会碰到需要强缓存的场景和不需要强缓存的场景，通常有2种方式来设置是否启用强缓存：</p>
<ol>
<li><p>通过代码的方式，在web服务器返回的响应中添加Expires和Cache-Control Header；</p>
</li>
<li><p>通过配置web服务器的方式，让web服务器在响应资源的时候统一添加Expires和Cache-Control Header。</p>
</li>
</ol>
</li>
<li><p>比如在javaweb里面，我们可以使用类似下面的代码设置强缓存：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.util.Date date = <span class="keyword">new</span> java.util.Date();    </span><br><span class="line">response.setDateHeader(<span class="string">"Expires"</span>,date.getTime()+<span class="number">20000</span>); <span class="comment">//Expires:过时期限值</span></span><br><span class="line">response.setHeader(<span class="string">"Cache-Control"</span>, <span class="string">"public"</span>); <span class="comment">//Cache-Control来控制页面的缓存与否,public:浏览器和缓存服务器都可以缓存页面信息；</span></span><br><span class="line">response.setHeader(<span class="string">"Pragma"</span>, <span class="string">"Pragma"</span>); <span class="comment">//Pragma:设置页面是否缓存，为Pragma则缓存，no-cache则不缓存</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以通过类似下面的java代码设置不启用强缓存：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader( <span class="string">"Pragma"</span>, <span class="string">"no-cache"</span> );   </span><br><span class="line">response.setDateHeader(<span class="string">"Expires"</span>, <span class="number">0</span>);   </span><br><span class="line">response.addHeader( <span class="string">"Cache-Control"</span>, <span class="string">"no-cache"</span> );<span class="comment">//浏览器和缓存服务器都不应该缓存页面信息</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>tomcat还提供了一个ExpiresFilter专门用来配置强缓存，具体使用的方式可参考tomcat的官方文档：<a href="http://tomcat.apache.org/tomcat-7.0-doc/config/filter.html#Expires_Filter" target="_blank" rel="external">http://tomcat.apache.org/tomcat-7.0-doc/config/filter.html#Expires_Filter</a></p>
</blockquote>
<ul>
<li><p>nginx和apache作为专业的web服务器，都有专门的配置文件，可以配置expires和cache-control，这方面的知识，如果你对运维感兴趣的话，可以在百度上搜索“nginx 设置 expires cache-control”或“apache 设置 expires cache-control”都能找到不少相关的文章。</p>
</li>
<li><p>由于在开发的时候不会专门去配置强缓存，而浏览器又默认会缓存图片，css和js等静态资源，所以开发环境下经常会因为强缓存导致资源没有及时更新而看不到最新的效果，解决这个问题的方法有很多，常用的有以下几种：</p>
<ol>
<li><p>直接ctrl+f5，这个办法能解决页面直接引用的资源更新的问题；</p>
</li>
<li><p>使用浏览器的隐私模式开发；</p>
</li>
<li><p>如果用的是chrome，可以f12在network那里把缓存给禁掉（这是个非常有效的方法）：<br><img src="https://wangzongxu.github.io/img-cache/blog/disabled-cache.png" alt="disabled-cache"></p>
</li>
<li><p>在开发阶段，给资源加上一个动态的参数，如css/index.css?v=0.0001，由于每次资源的修改都要更新引用的位置，同时修改参数的值，所以操作起来不是很方便，除非你是在动态页面比如jsp里开发就可以用服务器变量来解决（v=${sysRnd}），或者你能用一些前端的构建工具来处理这个参数修改的问题；</p>
</li>
<li><p>如果资源引用的页面，被嵌入到了一个iframe里面，可以在iframe的区域右键单击重新加载该页面，以chrome为例：<br><img src="https://wangzongxu.github.io/img-cache/blog/重新加载框架.png" alt="重新加载框架"></p>
</li>
<li><p>如果缓存问题出现在ajax请求中，最有效的解决办法就是ajax的请求地址追加随机数；</p>
</li>
<li><p>还有一种情况就是动态设置iframe的src时，有可能也会因为缓存问题，导致看不到最新的效果，这时候在要设置的src后面添加随机数也能解决问题；</p>
</li>
<li><p>如果你用的是grunt和gulp这种前端工具开发，通过它们的插件比如grunt-contrib-connect来启动一个静态服务器，则完全不用担心开发阶段的资源更新问题，因为在这个静态服务器下的所有资源返回的respone header中，cache-control始终被设置为不缓存：<br><img src="https://wangzongxu.github.io/img-cache/blog/disabled-cache-control.png" alt="disabled-cache-control"></p>
</li>
</ol>
</li>
</ul>
<h3 id="强缓存的应用"><a href="#强缓存的应用" class="headerlink" title="强缓存的应用"></a>强缓存的应用</h3><ul>
<li><p>强缓存是前端性能优化最有力的工具，没有之一，对于有大量静态资源的网页，一定要利用强缓存，提高响应速度。通常的做法是，为这些静态资源全部配置一个超时时间超长的Expires或Cache-Control，这样用户在访问网页时，只会在第一次加载时从服务器请求静态资源，其它时候只要缓存没有失效并且用户没有强制刷新的条件下都会从自己的缓存中加载，比如前面提到过的京东首页缓存的资源，它的缓存过期时间都设置到了2026年：<br><img src="https://wangzongxu.github.io/img-cache/blog/cache-2026.png" alt="cache-2026"></p>
</li>
<li><p>然而这种缓存配置方式会带来一个新的问题，就是发布时资源更新的问题，比如某一张图片，在用户访问第一个版本的时候已经缓存到了用户的电脑上，当网站发布新版本，替换了这个图片时，已经访问过第一个版本的用户由于缓存的设置，导致在默认的情况下不会请求服务器最新的图片资源，除非他清掉或禁用缓存或者强制刷新，否则就看不到最新的图片效果。</p>
</li>
<li><p>这个问题已经有成熟的解决方案，具体内容可阅读知乎这篇文章详细了解：<a href="http://www.zhihu.com/question/20790576" target="_blank" rel="external">http://www.zhihu.com/question/20790576</a></p>
</li>
<li><p>文章提到的东西都属于理论上的解决方案，不过现在已经有很多前端工具能够实际地解决这个问题，由于每个工具涉及到的内容细节都有很多，本文没有办法一一深入介绍。有兴趣的可以去了解下grunt gulp webpack fis 还有edp这几个工具，基于这几个工具都能解决这个问题，尤其是fis和edp是百度推出的前端开发平台，有现成的文档可以参考：</p>
</li>
</ul>
<p><a href="http://fis.baidu.com/fis3/api/index.html" target="_blank" rel="external">http://fis.baidu.com/fis3/api/index.html</a>   </p>
<p><a href="http://ecomfe.github.io/edp/doc/initialization/install/" target="_blank" rel="external">http://ecomfe.github.io/edp/doc/initialization/install/</a></p>
<ul>
<li>强缓存还有一点需要注意的是，通常都是针对静态资源使用，动态资源需要慎用，除了服务端页面可以看作动态资源外，那些引用静态资源的html也可以看作是动态资源，如果这种html也被缓存，当这些html更新之后，可能就没有机制能够通知浏览器这些html有更新，尤其是前后端分离的应用里，页面都是纯html页面，每个访问地址可能都是直接访问html页面，这些页面通常不加强缓存，以保证浏览器访问这些页面时始终请求服务器最新的资源。</li>
</ul>
<h3 id="协商缓存的原理"><a href="#协商缓存的原理" class="headerlink" title="协商缓存的原理"></a>协商缓存的原理</h3><ul>
<li><p>当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串，比如你打开京东的首页，按f12打开开发者工具，再按f5刷新页面，查看network，可以看到有不少请求就是命中了协商缓存的<br><img src="https://wangzongxu.github.io/img-cache/blog/304.png" alt="304"></p>
</li>
<li><p>查看单个请求的Response Header，也能看到304的状态码和Not Modified的字符串，只要看到这个就可说明这个资源是命中了协商缓存，然后从客户端缓存中加载的，而不是服务器最新的资源：<br><img src="https://wangzongxu.github.io/img-cache/blog/304-detail.png" alt="304-detail"></p>
</li>
<li><p>协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的。</p>
</li>
<li><p>【Last-Modified，If-Modified-Since】的控制缓存的原理是：</p>
<ol>
<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间：<br><img src="https://wangzongxu.github.io/img-cache/blog/Last-Modified.png" alt="Last-Modified"></li>
<li>浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值：<br><img src="https://wangzongxu.github.io/img-cache/blog/If-Modified-Since.png" alt="If-Modified-Since"></li>
<li>服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header：<br><img src="https://wangzongxu.github.io/img-cache/blog/304res.png" alt="304res"></li>
<li><p>浏览器收到304的响应后，就会从缓存中加载资源。</p>
</li>
<li><p>如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值。</p>
</li>
</ol>
</li>
<li><p>【Last-Modified，If-Modified-Since】都是根据服务器时间返回的header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个header配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对header来管理协商缓存，这对header就是【ETag、If-None-Match】。它们的缓存管理的方式是：</p>
<ol>
<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题：<br><img src="https://wangzongxu.github.io/img-cache/blog/ETag.png" alt="ETag"></li>
<li>浏览器再次跟服务器请求这个资源时，在request的header上加上If-None-Match的header，这个header的值就是上一次请求时返回的ETag的值：<br><img src="https://wangzongxu.github.io/img-cache/blog/if-none-match.png" alt="if-none-match"></li>
<li>服务器再次收到资源请求时，根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化：<br><img src="https://wangzongxu.github.io/img-cache/blog/ETag.png" alt="ETag"></li>
<li>浏览器收到304的响应后，就会从缓存中加载资源。</li>
</ol>
</li>
</ul>
<h3 id="协商缓存的管理"><a href="#协商缓存的管理" class="headerlink" title="协商缓存的管理"></a>协商缓存的管理</h3><ul>
<li><p>协商缓存跟强缓存不一样，强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。大部分web服务器都默认开启协商缓存，而且是同时启用【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】，比如apache:<br><img src="https://wangzongxu.github.io/img-cache/blog/etagandlast.png" alt="etagandlast"></p>
</li>
<li><p>如果没有协商缓存，每个到服务器的请求，就都得返回资源内容，这样服务器的性能会极差。</p>
</li>
<li><p>【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】一般都是同时启用，这是为了处理Last-Modified不可靠的情况。有一种场景需要注意：</p>
</li>
<li><p>分布式系统里多台机器间文件的Last-Modified必须保持一致，以免负载均衡到不同机器导致比对失败；</p>
</li>
<li><p>分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样）；</p>
</li>
<li><p>京东页面的资源请求，返回的repsones header就只有Last-Modified，没有ETag：<br><img src="https://wangzongxu.github.io/img-cache/blog/only-lastmodify.png" alt="only-lastmodify"></p>
</li>
<li><p>协商缓存需要配合强缓存使用，你看前面这个截图中，除了Last-Modified这个header，还有强缓存的相关header，因为如果不启用强缓存的话，协商缓存根本没有意义。</p>
</li>
</ul>
<h3 id="浏览器行为对缓存的影响"><a href="#浏览器行为对缓存的影响" class="headerlink" title="浏览器行为对缓存的影响"></a>浏览器行为对缓存的影响</h3><ul>
<li><p>如果资源已经被浏览器缓存下来，在缓存失效之前，再次请求时，默认会先检查是否命中强缓存，如果强缓存命中则直接读取缓存，如果强缓存没有命中则发请求到服务器检查是否命中协商缓存，如果协商缓存命中，则告诉浏览器还是可以从缓存读取，否则才从服务器返回最新的资源。这是默认的处理方式，这个方式可能被浏览器的行为改变：</p>
<ol>
<li><p>当ctrl+f5强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；</p>
</li>
<li><p>当f5刷新网页时，跳过强缓存，但是会检查协商缓存；</p>
</li>
</ol>
</li>
<li><p>参考出处：<a href="http://www.cnblogs.com/lyzg/p/5125934.html" target="_blank" rel="external">http://www.cnblogs.com/lyzg/p/5125934.html</a></p>
</li>
</ul>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="https://wangzongxu.github.io/img-cache/blog/browser-cache.jpeg" alt="流程图"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浏览器缓存，也就是客户端缓存，既是网页性能优化里面静态资源相关优化的一大利器，也是无数web开发人员在工作过程不可避免的一大问题，所以在产品开发的时候我们总是想办法避免缓存产生，而在产品发布之时又在想策略管理缓存提升网页的访问速度。了解浏览器的缓存命中原理，是开发web应用的基础。&lt;br&gt;
    
    </summary>
    
      <category term="剪切板" scheme="https://wangzongxu.github.io/categories/%E5%89%AA%E5%88%87%E6%9D%BF/"/>
    
    
      <category term="浏览器缓存" scheme="https://wangzongxu.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Chrome配置跨域</title>
    <link href="https://wangzongxu.github.io/2017/09/21/chromeConf/"/>
    <id>https://wangzongxu.github.io/2017/09/21/chromeConf/</id>
    <published>2017-09-21T09:09:24.000Z</published>
    <updated>2017-09-21T09:09:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为前端码农在项目开发中时常需要和后台进行接口联调，如果是前后端分离的情况下，本地开发调试后台接口的话，涉及到跨域问题比较令人头疼，很多人不知道其实chrome可以配置这一点：<br><a id="more"></a></p>
<h3 id="Chrome配置跨域"><a href="#Chrome配置跨域" class="headerlink" title="Chrome配置跨域"></a>Chrome配置跨域</h3><ul>
<li><p>windows环境下：</p>
<ol>
<li>在任意位置新建一个Chrome快捷方式，</li>
<li>右键点击快捷方式并打开属性，</li>
<li>在属性弹窗的选项中找到目标选项，</li>
<li>在目标选项中添加禁用安全限制配置(注意空格开头)<br>–disable-web-security –user-data-dir=C:\MyChromeDevUserData</li>
<li>点击确定，然后打开这个快捷方式，发现搜索框下边有一黄条提示就成功了，接下来就可以试一下请求跨域的资源了。</li>
</ol>
</li>
<li><p>mac环境下：</p>
<ol>
<li>先将Chrome完全退出，</li>
<li>打开命令行，</li>
<li>输入open -a’Google Chrome’ –args –disable-web-security –user-data-dir=/Users/这里输入你的mac用户名/MyChromeDevUserData/</li>
<li>配置完成，尝试请求跨域资源。</li>
</ol>
</li>
</ul>
<h3 id="顺便整理一些chrome配置参数"><a href="#顺便整理一些chrome配置参数" class="headerlink" title="顺便整理一些chrome配置参数"></a>顺便整理一些chrome配置参数</h3><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>–purge-memory-button</td>
<td>在Chrome的任务管理器中增加内存清理功能</td>
</tr>
<tr>
<td>–allow-outdated-plugins</td>
<td>不停用过期的插件。</td>
</tr>
<tr>
<td>–allow-running-insecure-content</td>
<td>默认情况下，https 页面不允许从 http 链接引用 javascript/css/plug-ins。添加这一参数会放行这些内容。</td>
</tr>
<tr>
<td>–allow-scripting-gallery</td>
<td>允许拓展脚本在官方应用中心生效。默认情况下，出于安全因素考虑这些脚本都会被阻止。</td>
</tr>
<tr>
<td>–disable-popup-blocking</td>
<td>禁用弹出拦截</td>
</tr>
<tr>
<td>–disable-javascript</td>
<td>禁用JavaScript</td>
</tr>
<tr>
<td>–disable-java</td>
<td>禁用Java</td>
</tr>
<tr>
<td>–disable-plugins</td>
<td>禁用插件</td>
</tr>
<tr>
<td>–-disable-images</td>
<td>禁用图像</td>
</tr>
<tr>
<td>–disable-accelerated-video</td>
<td>停用 GPU 加速视频。</td>
</tr>
<tr>
<td>–disable-dart</td>
<td>停用 Dart。</td>
</tr>
<tr>
<td>–disable-desktop-notifications</td>
<td>禁用桌面通知，在 Windows 中桌面通知默认是启用的。</td>
</tr>
<tr>
<td>–disable-extensions</td>
<td>禁用拓展。</td>
</tr>
<tr>
<td>–disable-file-system</td>
<td>停用 FileSystem API。</td>
</tr>
<tr>
<td>–disable-preconnect</td>
<td>停用 TCP/IP 预连接。</td>
</tr>
<tr>
<td>–disable-remote-fonts</td>
<td>关闭远程字体支持。SVG 中字体不受此参数影响。</td>
</tr>
<tr>
<td>–disable-speech-input</td>
<td>停用语音输入。</td>
</tr>
<tr>
<td>–disable-web-security</td>
<td>不遵守同源策略。</td>
</tr>
<tr>
<td>–user-data-dir=（chrome资料路径</td>
<td>代表自定义指定Chrome的资料路径</td>
</tr>
<tr>
<td>–disk-cache-dir</td>
<td>将缓存设置在给定的路径。</td>
</tr>
<tr>
<td>–disk-cache-size</td>
<td>设置缓存大小上限，以字节为单位。</td>
</tr>
<tr>
<td>–dns-prefetch-disable</td>
<td>停用DNS预读。</td>
</tr>
<tr>
<td>–enable-print-preview</td>
<td>启用打印预览。</td>
</tr>
<tr>
<td>–extensions-update-frequency</td>
<td>设定拓展自动更新频率，以秒为单位。</td>
</tr>
<tr>
<td>–incognito</td>
<td>让浏览器直接以隐身模式启动。</td>
</tr>
<tr>
<td>–keep-alive-for-test</td>
<td>最后一个标签关闭后仍保持浏览器进程。（某种意义上可以提高热启动速度，不过你最好得有充足的内存）</td>
</tr>
<tr>
<td>–kiosk</td>
<td>启用kiosk模式。（一种类似于全屏的浏览模式）</td>
</tr>
<tr>
<td>–lang</td>
<td>使用指定的语言。</td>
</tr>
<tr>
<td>–no-displaying-insecure-content</td>
<td>默认情况下，https 页面允许从 http 链接引用图片/字体/框架。添加这一参数会阻止这些内容。</td>
</tr>
<tr>
<td>–no-first-run</td>
<td>跳过 Chromium 首次运行检查。</td>
</tr>
<tr>
<td>–no-referrers</td>
<td>不发送 Http-Referer 头。</td>
</tr>
<tr>
<td>–no-sandbox</td>
<td>彻底停用沙箱。</td>
</tr>
<tr>
<td>–no-startup-window</td>
<td>启动时不建立窗口。</td>
</tr>
<tr>
<td>–proxy-pac-url</td>
<td>使用给定 URL 的 pac 代理脚本。（也可以使用本地文件，如 –proxy-pac-url=”file:\\c:\proxy.pac”）</td>
</tr>
<tr>
<td>–proxy-server</td>
<td>使用给定的代理服务器，这个参数只对 http 和 https 有效。（例如 –proxy-server=127.0.0.1:8087 ）</td>
</tr>
<tr>
<td>–single-process</td>
<td>以单进程模式运行 Chromium。（启动时浏览器会给出不安全警告）</td>
</tr>
<tr>
<td>–start-maximized</td>
<td>启动时最大化。</td>
</tr>
<tr>
<td>–user-agent</td>
<td>使用给定的 User-Agent 字符串</td>
</tr>
<tr>
<td>–process-per-tab</td>
<td>每个分页使用单独进程</td>
</tr>
<tr>
<td>–process-per-site</td>
<td>每个站点使用单独进程</td>
</tr>
<tr>
<td>–in-process-plugins</td>
<td>插件不启用单独进程</td>
</tr>
<tr>
<td>–omnibox-popup-count=”num”</td>
<td>将网址列弹出的提示选单数量改为num个</td>
</tr>
<tr>
<td>–enable-vertical-tabs</td>
<td>调整chrome游览器标签存放在左边，非顶部</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为前端码农在项目开发中时常需要和后台进行接口联调，如果是前后端分离的情况下，本地开发调试后台接口的话，涉及到跨域问题比较令人头疼，很多人不知道其实chrome可以配置这一点：&lt;br&gt;
    
    </summary>
    
      <category term="chrome" scheme="https://wangzongxu.github.io/categories/chrome/"/>
    
    
      <category term="chrome" scheme="https://wangzongxu.github.io/tags/chrome/"/>
    
  </entry>
  
</feed>
